"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/langsmith";
exports.ids = ["vendor-chunks/langsmith"];
exports.modules = {

/***/ "(rsc)/./node_modules/langsmith/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/langsmith/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AutoBatchQueue: () => (/* binding */ AutoBatchQueue),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   DEFAULT_MAX_SIZE_BYTES: () => (/* binding */ DEFAULT_MAX_SIZE_BYTES),\n/* harmony export */   DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES: () => (/* binding */ DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES),\n/* harmony export */   mergeRuntimeEnvIntoRun: () => (/* binding */ mergeRuntimeEnvIntoRun)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./experimental/otel/translator.js */ \"(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletons/otel.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/otel.js\");\n/* harmony import */ var _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/async_caller.js */ \"(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\");\n/* harmony import */ var _utils_messages_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/messages.js */ \"(rsc)/./node_modules/langsmith/dist/utils/messages.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/prompts.js */ \"(rsc)/./node_modules/langsmith/dist/utils/prompts.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/fast-safe-stringify/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction mergeRuntimeEnvIntoRun(run, cachedEnvVars, omitTracedRuntimeInfo) {\n    if (omitTracedRuntimeInfo) {\n        return run;\n    }\n    const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getRuntimeEnvironment)();\n    const envVars = cachedEnvVars ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n    const extra = run.extra ?? {};\n    const metadata = extra.metadata;\n    run.extra = {\n        ...extra,\n        runtime: {\n            ...runtimeEnv,\n            ...extra?.runtime\n        },\n        metadata: {\n            ...envVars,\n            ...envVars.revision_id || \"revision_id\" in run && run.revision_id ? {\n                revision_id: (\"revision_id\" in run ? run.revision_id : undefined) ?? envVars.revision_id\n            } : {},\n            ...metadata\n        }\n    };\n    return run;\n}\nconst getTracingSamplingRate = (configRate)=>{\n    const samplingRateStr = configRate?.toString() ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"TRACING_SAMPLING_RATE\");\n    if (samplingRateStr === undefined) {\n        return undefined;\n    }\n    const samplingRate = parseFloat(samplingRateStr);\n    if (samplingRate < 0 || samplingRate > 1) {\n        throw new Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${samplingRate}`);\n    }\n    return samplingRate;\n};\n// utility functions\nconst isLocalhost = (url)=>{\n    const strippedUrl = url.replace(\"http://\", \"\").replace(\"https://\", \"\");\n    const hostname = strippedUrl.split(\"/\")[0].split(\":\")[0];\n    return hostname === \"localhost\" || hostname === \"127.0.0.1\" || hostname === \"::1\";\n};\nasync function toArray(iterable) {\n    const result = [];\n    for await (const item of iterable){\n        result.push(item);\n    }\n    return result;\n}\nfunction trimQuotes(str) {\n    if (str === undefined) {\n        return undefined;\n    }\n    return str.trim().replace(/^\"(.*)\"$/, \"$1\").replace(/^'(.*)'$/, \"$1\");\n}\nconst handle429 = async (response)=>{\n    if (response?.status === 429) {\n        const retryAfter = parseInt(response.headers.get(\"retry-after\") ?? \"10\", 10) * 1000;\n        if (retryAfter > 0) {\n            await new Promise((resolve)=>setTimeout(resolve, retryAfter));\n            // Return directly after calling this check\n            return true;\n        }\n    }\n    // Fall back to existing status checks\n    return false;\n};\nfunction _formatFeedbackScore(score) {\n    if (typeof score === \"number\") {\n        // Truncate at 4 decimal places\n        return Number(score.toFixed(4));\n    }\n    return score;\n}\nconst DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES = 24 * 1024 * 1024;\n/** Default maximum memory (1GB) for queue size limits. */ const DEFAULT_MAX_SIZE_BYTES = 1024 * 1024 * 1024; // 1GB\nconst SERVER_INFO_REQUEST_TIMEOUT_MS = 10000;\n/** Maximum number of operations to batch in a single request. */ const DEFAULT_BATCH_SIZE_LIMIT = 100;\nconst DEFAULT_API_URL = \"https://api.smith.langchain.com\";\nclass AutoBatchQueue {\n    constructor(maxSizeBytes){\n        Object.defineProperty(this, \"items\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"sizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"maxSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSizeBytes = maxSizeBytes ?? DEFAULT_MAX_SIZE_BYTES;\n    }\n    peek() {\n        return this.items[0];\n    }\n    push(item) {\n        let itemPromiseResolve;\n        const itemPromise = new Promise((resolve)=>{\n            // Setting itemPromiseResolve is synchronous with promise creation:\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise\n            itemPromiseResolve = resolve;\n        });\n        const size = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(item.item, `Serializing run with id: ${item.item.id}`).length;\n        // Check if adding this item would exceed the size limit\n        // Allow the run if the queue is empty (to support large single traces)\n        if (this.sizeBytes + size > this.maxSizeBytes && this.items.length > 0) {\n            console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${item.item.id}. ` + `Current queue size: ${this.sizeBytes} bytes, attempted addition: ${size} bytes.`);\n            // Resolve immediately to avoid blocking caller\n            itemPromiseResolve();\n            return itemPromise;\n        }\n        this.items.push({\n            action: item.action,\n            payload: item.item,\n            otelContext: item.otelContext,\n            apiKey: item.apiKey,\n            apiUrl: item.apiUrl,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            itemPromiseResolve: itemPromiseResolve,\n            itemPromise,\n            size\n        });\n        this.sizeBytes += size;\n        return itemPromise;\n    }\n    pop({ upToSizeBytes, upToSize }) {\n        if (upToSizeBytes < 1) {\n            throw new Error(\"Number of bytes to pop off may not be less than 1.\");\n        }\n        const popped = [];\n        let poppedSizeBytes = 0;\n        // Pop items until we reach or exceed the size limit\n        while(poppedSizeBytes + (this.peek()?.size ?? 0) < upToSizeBytes && this.items.length > 0 && popped.length < upToSize){\n            const item = this.items.shift();\n            if (item) {\n                popped.push(item);\n                poppedSizeBytes += item.size;\n                this.sizeBytes -= item.size;\n            }\n        }\n        // If there is an item on the queue we were unable to pop,\n        // just return it as a single batch.\n        if (popped.length === 0 && this.items.length > 0) {\n            const item = this.items.shift();\n            popped.push(item);\n            poppedSizeBytes += item.size;\n            this.sizeBytes -= item.size;\n        }\n        return [\n            popped.map((it)=>({\n                    action: it.action,\n                    item: it.payload,\n                    otelContext: it.otelContext,\n                    apiKey: it.apiKey,\n                    apiUrl: it.apiUrl,\n                    size: it.size\n                })),\n            ()=>popped.forEach((it)=>it.itemPromiseResolve())\n        ];\n    }\n}\nclass Client {\n    get _fetch() {\n        return this.fetchImplementation || (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._getFetchImplementation)(this.debug);\n    }\n    constructor(config = {}){\n        Object.defineProperty(this, \"apiKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"apiUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"webUrl\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"workspaceId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"caller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchIngestCaller\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout_ms\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tenantId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: null\n        });\n        Object.defineProperty(this, \"hideInputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"hideOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"omitTracedRuntimeInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingSampleRate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"filteredPostUuids\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Set()\n        });\n        Object.defineProperty(this, \"autoBatchTracing\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"autoBatchQueue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"autoBatchAggregationDelayMs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 250\n        });\n        Object.defineProperty(this, \"batchSizeBytesLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"batchSizeLimit\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchOptions\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"settings\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"blockOnRootRunFinalization\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_TRACING_BACKGROUND\") === \"false\"\n        });\n        Object.defineProperty(this, \"traceBatchConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 5\n        });\n        Object.defineProperty(this, \"_serverInfo\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"_getServerInfoPromise\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"manualFlushMode\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"langSmithToOTELTranslator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"fetchImplementation\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cachedLSEnvVarsForMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"multipartStreamingDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"_multipartDisabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"debug\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnvironmentVariable)(\"LANGSMITH_DEBUG\") === \"true\"\n        });\n        const defaultConfig = Client.getDefaultClientConfig();\n        this.tracingSampleRate = getTracingSamplingRate(config.tracingSamplingRate);\n        this.apiUrl = trimQuotes(config.apiUrl ?? defaultConfig.apiUrl) ?? \"\";\n        if (this.apiUrl.endsWith(\"/\")) {\n            this.apiUrl = this.apiUrl.slice(0, -1);\n        }\n        this.apiKey = trimQuotes(config.apiKey ?? defaultConfig.apiKey);\n        this.webUrl = trimQuotes(config.webUrl ?? defaultConfig.webUrl);\n        if (this.webUrl?.endsWith(\"/\")) {\n            this.webUrl = this.webUrl.slice(0, -1);\n        }\n        this.workspaceId = trimQuotes(config.workspaceId ?? (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"WORKSPACE_ID\"));\n        this.timeout_ms = config.timeout_ms ?? 90000;\n        this.caller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            ...config.callerOptions ?? {},\n            maxRetries: 4,\n            debug: config.debug ?? this.debug\n        });\n        this.traceBatchConcurrency = config.traceBatchConcurrency ?? this.traceBatchConcurrency;\n        if (this.traceBatchConcurrency < 1) {\n            throw new Error(\"Trace batch concurrency must be positive.\");\n        }\n        this.debug = config.debug ?? this.debug;\n        this.fetchImplementation = config.fetchImplementation;\n        // Use maxIngestMemoryBytes for both queues\n        const maxMemory = config.maxIngestMemoryBytes ?? DEFAULT_MAX_SIZE_BYTES;\n        this.batchIngestCaller = new _utils_async_caller_js__WEBPACK_IMPORTED_MODULE_2__.AsyncCaller({\n            maxRetries: 4,\n            maxConcurrency: this.traceBatchConcurrency,\n            maxQueueSizeBytes: maxMemory,\n            ...config.callerOptions ?? {},\n            onFailedResponseHook: handle429,\n            debug: config.debug ?? this.debug\n        });\n        this.hideInputs = config.hideInputs ?? config.anonymizer ?? defaultConfig.hideInputs;\n        this.hideOutputs = config.hideOutputs ?? config.anonymizer ?? defaultConfig.hideOutputs;\n        this.omitTracedRuntimeInfo = config.omitTracedRuntimeInfo ?? false;\n        this.autoBatchTracing = config.autoBatchTracing ?? this.autoBatchTracing;\n        this.autoBatchQueue = new AutoBatchQueue(maxMemory);\n        this.blockOnRootRunFinalization = config.blockOnRootRunFinalization ?? this.blockOnRootRunFinalization;\n        this.batchSizeBytesLimit = config.batchSizeBytesLimit;\n        this.batchSizeLimit = config.batchSizeLimit;\n        this.fetchOptions = config.fetchOptions || {};\n        this.manualFlushMode = config.manualFlushMode ?? this.manualFlushMode;\n        if ((0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getOtelEnabled)()) {\n            this.langSmithToOTELTranslator = new _experimental_otel_translator_js__WEBPACK_IMPORTED_MODULE_0__.LangSmithToOTELTranslator();\n        }\n        // Cache metadata env vars once during construction to avoid repeatedly scanning process.env\n        this.cachedLSEnvVarsForMetadata = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvVarsMetadata)();\n    }\n    static getDefaultClientConfig() {\n        const apiKey = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"API_KEY\");\n        const apiUrl = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"ENDPOINT\") ?? DEFAULT_API_URL;\n        const hideInputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_INPUTS\") === \"true\";\n        const hideOutputs = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"HIDE_OUTPUTS\") === \"true\";\n        return {\n            apiUrl: apiUrl,\n            apiKey: apiKey,\n            webUrl: undefined,\n            hideInputs: hideInputs,\n            hideOutputs: hideOutputs\n        };\n    }\n    getHostUrl() {\n        if (this.webUrl) {\n            return this.webUrl;\n        } else if (isLocalhost(this.apiUrl)) {\n            this.webUrl = \"http://localhost:3000\";\n            return this.webUrl;\n        } else if (this.apiUrl.endsWith(\"/api/v1\")) {\n            this.webUrl = this.apiUrl.replace(\"/api/v1\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.includes(\"/api\") && !this.apiUrl.split(\".\", 1)[0].endsWith(\"api\")) {\n            this.webUrl = this.apiUrl.replace(\"/api\", \"\");\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"dev\")) {\n            this.webUrl = \"https://dev.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"eu\")) {\n            this.webUrl = \"https://eu.smith.langchain.com\";\n            return this.webUrl;\n        } else if (this.apiUrl.split(\".\", 1)[0].includes(\"beta\")) {\n            this.webUrl = \"https://beta.smith.langchain.com\";\n            return this.webUrl;\n        } else {\n            this.webUrl = \"https://smith.langchain.com\";\n            return this.webUrl;\n        }\n    }\n    get headers() {\n        const headers = {\n            \"User-Agent\": `langsmith-js/${_index_js__WEBPACK_IMPORTED_MODULE_5__.__version__}`\n        };\n        if (this.apiKey) {\n            headers[\"x-api-key\"] = `${this.apiKey}`;\n        }\n        if (this.workspaceId) {\n            headers[\"x-tenant-id\"] = this.workspaceId;\n        }\n        return headers;\n    }\n    _getPlatformEndpointPath(path) {\n        // Check if apiUrl already ends with /v1 or /v1/ to avoid double /v1/v1/ paths\n        const needsV1Prefix = this.apiUrl.slice(-3) !== \"/v1\" && this.apiUrl.slice(-4) !== \"/v1/\";\n        return needsV1Prefix ? `/v1/platform/${path}` : `/platform/${path}`;\n    }\n    async processInputs(inputs) {\n        if (this.hideInputs === false) {\n            return inputs;\n        }\n        if (this.hideInputs === true) {\n            return {};\n        }\n        if (typeof this.hideInputs === \"function\") {\n            return this.hideInputs(inputs);\n        }\n        return inputs;\n    }\n    async processOutputs(outputs) {\n        if (this.hideOutputs === false) {\n            return outputs;\n        }\n        if (this.hideOutputs === true) {\n            return {};\n        }\n        if (typeof this.hideOutputs === \"function\") {\n            return this.hideOutputs(outputs);\n        }\n        return outputs;\n    }\n    async prepareRunCreateOrUpdateInputs(run) {\n        const runParams = {\n            ...run\n        };\n        if (runParams.inputs !== undefined) {\n            runParams.inputs = await this.processInputs(runParams.inputs);\n        }\n        if (runParams.outputs !== undefined) {\n            runParams.outputs = await this.processOutputs(runParams.outputs);\n        }\n        return runParams;\n    }\n    async _getResponse(path, queryParams) {\n        const paramsString = queryParams?.toString() ?? \"\";\n        const url = `${this.apiUrl}${path}?${paramsString}`;\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(url, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n            return res;\n        });\n        return response;\n    }\n    async _get(path, queryParams) {\n        const response = await this._getResponse(path, queryParams);\n        return response.json();\n    }\n    async *_getPaginated(path, queryParams = new URLSearchParams(), transform) {\n        let offset = Number(queryParams.get(\"offset\")) || 0;\n        const limit = Number(queryParams.get(\"limit\")) || 100;\n        while(true){\n            queryParams.set(\"offset\", String(offset));\n            queryParams.set(\"limit\", String(limit));\n            const url = `${this.apiUrl}${path}?${queryParams}`;\n            const response = await this.caller.call(async ()=>{\n                const res = await this._fetch(url, {\n                    method: \"GET\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const items = transform ? transform(await response.json()) : await response.json();\n            if (items.length === 0) {\n                break;\n            }\n            yield items;\n            if (items.length < limit) {\n                break;\n            }\n            offset += items.length;\n        }\n    }\n    async *_getCursorPaginatedList(path, body = null, requestMethod = \"POST\", dataKey = \"runs\") {\n        const bodyParams = body ? {\n            ...body\n        } : {};\n        while(true){\n            const body = JSON.stringify(bodyParams);\n            const response = await this.caller.call(async ()=>{\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: requestMethod,\n                    headers: {\n                        ...this.headers,\n                        \"Content-Type\": \"application/json\"\n                    },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `fetch ${path}`);\n                return res;\n            });\n            const responseBody = await response.json();\n            if (!responseBody) {\n                break;\n            }\n            if (!responseBody[dataKey]) {\n                break;\n            }\n            yield responseBody[dataKey];\n            const cursors = responseBody.cursors;\n            if (!cursors) {\n                break;\n            }\n            if (!cursors.next) {\n                break;\n            }\n            bodyParams.cursor = cursors.next;\n        }\n    }\n    // Allows mocking for tests\n    _shouldSample() {\n        if (this.tracingSampleRate === undefined) {\n            return true;\n        }\n        return Math.random() < this.tracingSampleRate;\n    }\n    _filterForSampling(runs, patch = false) {\n        if (this.tracingSampleRate === undefined) {\n            return runs;\n        }\n        if (patch) {\n            const sampled = [];\n            for (const run of runs){\n                if (!this.filteredPostUuids.has(run.trace_id)) {\n                    sampled.push(run);\n                } else if (run.id === run.trace_id) {\n                    this.filteredPostUuids.delete(run.trace_id);\n                }\n            }\n            return sampled;\n        } else {\n            // For new runs, sample at trace level to maintain consistency\n            const sampled = [];\n            for (const run of runs){\n                const traceId = run.trace_id ?? run.id;\n                // If we've already made a decision about this trace, follow it\n                if (this.filteredPostUuids.has(traceId)) {\n                    continue;\n                }\n                // For new traces, apply sampling\n                if (run.id === traceId) {\n                    if (this._shouldSample()) {\n                        sampled.push(run);\n                    } else {\n                        this.filteredPostUuids.add(traceId);\n                    }\n                } else {\n                    // Child runs follow their trace's sampling decision\n                    sampled.push(run);\n                }\n            }\n            return sampled;\n        }\n    }\n    async _getBatchSizeLimitBytes() {\n        const serverInfo = await this._ensureServerInfo();\n        return this.batchSizeBytesLimit ?? serverInfo?.batch_ingest_config?.size_limit_bytes ?? DEFAULT_UNCOMPRESSED_BATCH_SIZE_LIMIT_BYTES;\n    }\n    /**\n     * Get the maximum number of operations to batch in a single request.\n     */ async _getBatchSizeLimit() {\n        const serverInfo = await this._ensureServerInfo();\n        return this.batchSizeLimit ?? serverInfo?.batch_ingest_config?.size_limit ?? DEFAULT_BATCH_SIZE_LIMIT;\n    }\n    async _getDatasetExamplesMultiPartSupport() {\n        const serverInfo = await this._ensureServerInfo();\n        return serverInfo.instance_flags?.dataset_examples_multipart_enabled ?? false;\n    }\n    drainAutoBatchQueue({ batchSizeLimitBytes, batchSizeLimit }) {\n        const promises = [];\n        while(this.autoBatchQueue.items.length > 0){\n            const [batch, done] = this.autoBatchQueue.pop({\n                upToSizeBytes: batchSizeLimitBytes,\n                upToSize: batchSizeLimit\n            });\n            if (!batch.length) {\n                done();\n                break;\n            }\n            const batchesByDestination = batch.reduce((acc, item)=>{\n                const apiUrl = item.apiUrl ?? this.apiUrl;\n                const apiKey = item.apiKey ?? this.apiKey;\n                const isDefault = item.apiKey === this.apiKey && item.apiUrl === this.apiUrl;\n                const batchKey = isDefault ? \"default\" : `${apiUrl}|${apiKey}`;\n                if (!acc[batchKey]) {\n                    acc[batchKey] = [];\n                }\n                acc[batchKey].push(item);\n                return acc;\n            }, {});\n            const batchPromises = [];\n            for (const [batchKey, batch] of Object.entries(batchesByDestination)){\n                const batchPromise = this._processBatch(batch, {\n                    apiUrl: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[0],\n                    apiKey: batchKey === \"default\" ? undefined : batchKey.split(\"|\")[1]\n                });\n                batchPromises.push(batchPromise);\n            }\n            // Wait for all batches to complete, then call the overall done callback\n            const allBatchesPromise = Promise.all(batchPromises).finally(done);\n            promises.push(allBatchesPromise);\n        }\n        return Promise.all(promises);\n    }\n    async _processBatch(batch, options) {\n        if (!batch.length) {\n            return;\n        }\n        // Calculate total batch size for queue tracking\n        const batchSizeBytes = batch.reduce((sum, item)=>sum + (item.size ?? 0), 0);\n        try {\n            if (this.langSmithToOTELTranslator !== undefined) {\n                this._sendBatchToOTELTranslator(batch);\n            } else {\n                const ingestParams = {\n                    runCreates: batch.filter((item)=>item.action === \"create\").map((item)=>item.item),\n                    runUpdates: batch.filter((item)=>item.action === \"update\").map((item)=>item.item)\n                };\n                const serverInfo = await this._ensureServerInfo();\n                const useMultipart = !this._multipartDisabled && (serverInfo?.batch_ingest_config?.use_multipart_endpoint ?? true);\n                if (useMultipart) {\n                    const useGzip = serverInfo?.instance_flags?.gzip_body_enabled;\n                    try {\n                        await this.multipartIngestRuns(ingestParams, {\n                            ...options,\n                            useGzip,\n                            sizeBytes: batchSizeBytes\n                        });\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    } catch (e) {\n                        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                            // Fallback to batch ingest if multipart endpoint returns 404\n                            // Disable multipart for future requests\n                            this._multipartDisabled = true;\n                            await this.batchIngestRuns(ingestParams, {\n                                ...options,\n                                sizeBytes: batchSizeBytes\n                            });\n                        } else {\n                            throw e;\n                        }\n                    }\n                } else {\n                    await this.batchIngestRuns(ingestParams, {\n                        ...options,\n                        sizeBytes: batchSizeBytes\n                    });\n                }\n            }\n        } catch (e) {\n            console.error(\"Error exporting batch:\", e);\n        }\n    }\n    _sendBatchToOTELTranslator(batch) {\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const otelContextMap = new Map();\n            const operations = [];\n            for (const item of batch){\n                if (item.item.id && item.otelContext) {\n                    otelContextMap.set(item.item.id, item.otelContext);\n                    if (item.action === \"create\") {\n                        operations.push({\n                            operation: \"post\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item\n                        });\n                    } else {\n                        operations.push({\n                            operation: \"patch\",\n                            id: item.item.id,\n                            trace_id: item.item.trace_id ?? item.item.id,\n                            run: item.item\n                        });\n                    }\n                }\n            }\n            this.langSmithToOTELTranslator.exportBatch(operations, otelContextMap);\n        }\n    }\n    async processRunOperation(item) {\n        clearTimeout(this.autoBatchTimeout);\n        this.autoBatchTimeout = undefined;\n        item.item = mergeRuntimeEnvIntoRun(item.item, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        const itemPromise = this.autoBatchQueue.push(item);\n        if (this.manualFlushMode) {\n            // Rely on manual flushing in serverless environments\n            return itemPromise;\n        }\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        if (this.autoBatchQueue.sizeBytes > sizeLimitBytes || this.autoBatchQueue.items.length > sizeLimit) {\n            void this.drainAutoBatchQueue({\n                batchSizeLimitBytes: sizeLimitBytes,\n                batchSizeLimit: sizeLimit\n            });\n        }\n        if (this.autoBatchQueue.items.length > 0) {\n            this.autoBatchTimeout = setTimeout(()=>{\n                this.autoBatchTimeout = undefined;\n                void this.drainAutoBatchQueue({\n                    batchSizeLimitBytes: sizeLimitBytes,\n                    batchSizeLimit: sizeLimit\n                });\n            }, this.autoBatchAggregationDelayMs);\n        }\n        return itemPromise;\n    }\n    async _getServerInfo() {\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/info`, {\n                method: \"GET\",\n                headers: {\n                    Accept: \"application/json\"\n                },\n                signal: AbortSignal.timeout(SERVER_INFO_REQUEST_TIMEOUT_MS),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get server info\");\n            return res;\n        });\n        const json = await response.json();\n        if (this.debug) {\n            console.log(\"\\n=== LangSmith Server Configuration ===\\n\" + JSON.stringify(json, null, 2) + \"\\n\");\n        }\n        return json;\n    }\n    async _ensureServerInfo() {\n        if (this._getServerInfoPromise === undefined) {\n            this._getServerInfoPromise = (async ()=>{\n                if (this._serverInfo === undefined) {\n                    try {\n                        this._serverInfo = await this._getServerInfo();\n                    } catch (e) {\n                        console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${e.status ?? \"Unspecified status code\"} ${e.message}`);\n                    }\n                }\n                return this._serverInfo ?? {};\n            })();\n        }\n        return this._getServerInfoPromise.then((serverInfo)=>{\n            if (this._serverInfo === undefined) {\n                this._getServerInfoPromise = undefined;\n            }\n            return serverInfo;\n        });\n    }\n    async _getSettings() {\n        if (!this.settings) {\n            this.settings = this._get(\"/settings\");\n        }\n        return await this.settings;\n    }\n    /**\n     * Flushes current queued traces.\n     */ async flush() {\n        const sizeLimitBytes = await this._getBatchSizeLimitBytes();\n        const sizeLimit = await this._getBatchSizeLimit();\n        await this.drainAutoBatchQueue({\n            batchSizeLimitBytes: sizeLimitBytes,\n            batchSizeLimit: sizeLimit\n        });\n    }\n    _cloneCurrentOTELContext() {\n        const otel_trace = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)();\n        const otel_context = (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELContext)();\n        if (this.langSmithToOTELTranslator !== undefined) {\n            const currentSpan = otel_trace.getActiveSpan();\n            if (currentSpan) {\n                return otel_trace.setSpan(otel_context.active(), currentSpan);\n            }\n        }\n        return undefined;\n    }\n    async createRun(run, options) {\n        if (!this._filterForSampling([\n            run\n        ]).length) {\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        const session_name = run.project_name;\n        delete run.project_name;\n        const runCreate = await this.prepareRunCreateOrUpdateInputs({\n            session_name,\n            ...run,\n            start_time: run.start_time ?? Date.now()\n        });\n        if (this.autoBatchTracing && runCreate.trace_id !== undefined && runCreate.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            void this.processRunOperation({\n                action: \"create\",\n                item: runCreate,\n                otelContext,\n                apiKey: options?.apiKey,\n                apiUrl: options?.apiUrl\n            }).catch(console.error);\n            return;\n        }\n        const mergedRunCreateParam = mergeRuntimeEnvIntoRun(runCreate, this.cachedLSEnvVarsForMetadata, this.omitTracedRuntimeInfo);\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(mergedRunCreateParam, `Creating run with id: ${mergedRunCreateParam.id}`);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async batchIngestRuns({ runCreates, runUpdates }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        let preparedCreateParams = await Promise.all(runCreates?.map((create)=>this.prepareRunCreateOrUpdateInputs(create)) ?? []);\n        let preparedUpdateParams = await Promise.all(runUpdates?.map((update)=>this.prepareRunCreateOrUpdateInputs(update)) ?? []);\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        const rawBatch = {\n            post: preparedCreateParams,\n            patch: preparedUpdateParams\n        };\n        if (!rawBatch.post.length && !rawBatch.patch.length) {\n            return;\n        }\n        const batchChunks = {\n            post: [],\n            patch: []\n        };\n        for (const k of [\n            \"post\",\n            \"patch\"\n        ]){\n            const key = k;\n            const batchItems = rawBatch[key].reverse();\n            let batchItem = batchItems.pop();\n            while(batchItem !== undefined){\n                // Type is wrong but this is a deprecated code path anyway\n                batchChunks[key].push(batchItem);\n                batchItem = batchItems.pop();\n            }\n        }\n        if (batchChunks.post.length > 0 || batchChunks.patch.length > 0) {\n            const runIds = batchChunks.post.map((item)=>item.id).concat(batchChunks.patch.map((item)=>item.id)).join(\",\");\n            await this._postBatchIngestRuns((0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(batchChunks, `Ingesting runs with ids: ${runIds}`), options);\n        }\n    }\n    async _postBatchIngestRuns(body, options) {\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\",\n            Accept: \"application/json\"\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        await this.batchIngestCaller.callWithOptions({\n            sizeBytes: options?.sizeBytes\n        }, async ()=>{\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/batch`, {\n                method: \"POST\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"batch create run\", true);\n            return res;\n        });\n    }\n    /**\n     * Batch ingest/upsert multiple runs in the Langsmith system.\n     * @param runs\n     */ async multipartIngestRuns({ runCreates, runUpdates }, options) {\n        if (runCreates === undefined && runUpdates === undefined) {\n            return;\n        }\n        // transform and convert to dicts\n        const allAttachments = {};\n        let preparedCreateParams = [];\n        for (const create of runCreates ?? []){\n            const preparedCreate = await this.prepareRunCreateOrUpdateInputs(create);\n            if (preparedCreate.id !== undefined && preparedCreate.attachments !== undefined) {\n                allAttachments[preparedCreate.id] = preparedCreate.attachments;\n            }\n            delete preparedCreate.attachments;\n            preparedCreateParams.push(preparedCreate);\n        }\n        let preparedUpdateParams = [];\n        for (const update of runUpdates ?? []){\n            preparedUpdateParams.push(await this.prepareRunCreateOrUpdateInputs(update));\n        }\n        // require trace_id and dotted_order\n        const invalidRunCreate = preparedCreateParams.find((runCreate)=>{\n            return runCreate.trace_id === undefined || runCreate.dotted_order === undefined;\n        });\n        if (invalidRunCreate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when creating a run`);\n        }\n        const invalidRunUpdate = preparedUpdateParams.find((runUpdate)=>{\n            return runUpdate.trace_id === undefined || runUpdate.dotted_order === undefined;\n        });\n        if (invalidRunUpdate !== undefined) {\n            throw new Error(`Multipart ingest requires \"trace_id\" and \"dotted_order\" to be set when updating a run`);\n        }\n        // combine post and patch dicts where possible\n        if (preparedCreateParams.length > 0 && preparedUpdateParams.length > 0) {\n            const createById = preparedCreateParams.reduce((params, run)=>{\n                if (!run.id) {\n                    return params;\n                }\n                params[run.id] = run;\n                return params;\n            }, {});\n            const standaloneUpdates = [];\n            for (const updateParam of preparedUpdateParams){\n                if (updateParam.id !== undefined && createById[updateParam.id]) {\n                    createById[updateParam.id] = {\n                        ...createById[updateParam.id],\n                        ...updateParam\n                    };\n                } else {\n                    standaloneUpdates.push(updateParam);\n                }\n            }\n            preparedCreateParams = Object.values(createById);\n            preparedUpdateParams = standaloneUpdates;\n        }\n        if (preparedCreateParams.length === 0 && preparedUpdateParams.length === 0) {\n            return;\n        }\n        // send the runs in multipart requests\n        const accumulatedContext = [];\n        const accumulatedParts = [];\n        for (const [method, payloads] of [\n            [\n                \"post\",\n                preparedCreateParams\n            ],\n            [\n                \"patch\",\n                preparedUpdateParams\n            ]\n        ]){\n            for (const originalPayload of payloads){\n                // collect fields to be sent as separate parts\n                const { inputs, outputs, events, extra, error, serialized, attachments, ...payload } = originalPayload;\n                const fields = {\n                    inputs,\n                    outputs,\n                    events,\n                    extra,\n                    error,\n                    serialized\n                };\n                // encode the main run payload\n                const stringifiedPayload = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(payload, `Serializing for multipart ingestion of run with id: ${payload.id}`);\n                accumulatedParts.push({\n                    name: `${method}.${payload.id}`,\n                    payload: new Blob([\n                        stringifiedPayload\n                    ], {\n                        type: `application/json; length=${stringifiedPayload.length}`\n                    })\n                });\n                // encode the fields we collected\n                for (const [key, value] of Object.entries(fields)){\n                    if (value === undefined) {\n                        continue;\n                    }\n                    const stringifiedValue = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(value, `Serializing ${key} for multipart ingestion of run with id: ${payload.id}`);\n                    accumulatedParts.push({\n                        name: `${method}.${payload.id}.${key}`,\n                        payload: new Blob([\n                            stringifiedValue\n                        ], {\n                            type: `application/json; length=${stringifiedValue.length}`\n                        })\n                    });\n                }\n                // encode the attachments\n                if (payload.id !== undefined) {\n                    const attachments = allAttachments[payload.id];\n                    if (attachments) {\n                        delete allAttachments[payload.id];\n                        for (const [name, attachment] of Object.entries(attachments)){\n                            let contentType;\n                            let content;\n                            if (Array.isArray(attachment)) {\n                                [contentType, content] = attachment;\n                            } else {\n                                contentType = attachment.mimeType;\n                                content = attachment.data;\n                            }\n                            // Validate that the attachment name doesn't contain a '.'\n                            if (name.includes(\".\")) {\n                                console.warn(`Skipping attachment '${name}' for run ${payload.id}: Invalid attachment name. ` + `Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);\n                                continue;\n                            }\n                            accumulatedParts.push({\n                                name: `attachment.${payload.id}.${name}`,\n                                payload: new Blob([\n                                    content\n                                ], {\n                                    type: `${contentType}; length=${content.byteLength}`\n                                })\n                            });\n                        }\n                    }\n                }\n                // compute context\n                accumulatedContext.push(`trace=${payload.trace_id},id=${payload.id}`);\n            }\n        }\n        await this._sendMultipartRequest(accumulatedParts, accumulatedContext.join(\"; \"), options);\n    }\n    async _createNodeFetchBody(parts, boundary) {\n        // Create multipart form data manually using Blobs\n        const chunks = [];\n        for (const part of parts){\n            // Add field boundary\n            chunks.push(new Blob([\n                `--${boundary}\\r\\n`\n            ]));\n            chunks.push(new Blob([\n                `Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`,\n                `Content-Type: ${part.payload.type}\\r\\n\\r\\n`\n            ]));\n            chunks.push(part.payload);\n            chunks.push(new Blob([\n                \"\\r\\n\"\n            ]));\n        }\n        // Add final boundary\n        chunks.push(new Blob([\n            `--${boundary}--\\r\\n`\n        ]));\n        // Combine all chunks into a single Blob\n        const body = new Blob(chunks);\n        // Convert Blob to ArrayBuffer for compatibility\n        const arrayBuffer = await body.arrayBuffer();\n        return arrayBuffer;\n    }\n    async _createMultipartStream(parts, boundary) {\n        const encoder = new TextEncoder();\n        // Create a ReadableStream for streaming the multipart data\n        // Only do special handling if we're using node-fetch\n        const stream = new ReadableStream({\n            async start (controller) {\n                // Helper function to write a chunk to the stream\n                const writeChunk = async (chunk)=>{\n                    if (typeof chunk === \"string\") {\n                        controller.enqueue(encoder.encode(chunk));\n                    } else {\n                        controller.enqueue(chunk);\n                    }\n                };\n                // Write each part to the stream\n                for (const part of parts){\n                    // Write boundary and headers\n                    await writeChunk(`--${boundary}\\r\\n`);\n                    await writeChunk(`Content-Disposition: form-data; name=\"${part.name}\"\\r\\n`);\n                    await writeChunk(`Content-Type: ${part.payload.type}\\r\\n\\r\\n`);\n                    // Write the payload\n                    const payloadStream = part.payload.stream();\n                    const reader = payloadStream.getReader();\n                    try {\n                        let result;\n                        while(!(result = await reader.read()).done){\n                            controller.enqueue(result.value);\n                        }\n                    } finally{\n                        reader.releaseLock();\n                    }\n                    await writeChunk(\"\\r\\n\");\n                }\n                // Write final boundary\n                await writeChunk(`--${boundary}--\\r\\n`);\n                controller.close();\n            }\n        });\n        return stream;\n    }\n    async _sendMultipartRequest(parts, context, options) {\n        // Create multipart form data boundary\n        const boundary = \"----LangSmithFormBoundary\" + Math.random().toString(36).slice(2);\n        const isNodeFetch = (0,_singletons_fetch_js__WEBPACK_IMPORTED_MODULE_10__._globalFetchImplementationIsNodeFetch)();\n        const buildBuffered = ()=>this._createNodeFetchBody(parts, boundary);\n        const buildStream = ()=>this._createMultipartStream(parts, boundary);\n        const sendWithRetry = async (bodyFactory)=>{\n            return this.batchIngestCaller.callWithOptions({\n                sizeBytes: options?.sizeBytes\n            }, async ()=>{\n                const body = await bodyFactory();\n                const headers = {\n                    ...this.headers,\n                    \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n                };\n                if (options?.apiKey !== undefined) {\n                    headers[\"x-api-key\"] = options.apiKey;\n                }\n                let transformedBody = body;\n                if (options?.useGzip && typeof body === \"object\" && \"pipeThrough\" in body) {\n                    transformedBody = body.pipeThrough(new CompressionStream(\"gzip\"));\n                    headers[\"Content-Encoding\"] = \"gzip\";\n                }\n                const response = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/multipart`, {\n                    method: \"POST\",\n                    headers,\n                    body: transformedBody,\n                    duplex: \"half\",\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(response, `Failed to send multipart request`, true);\n                return response;\n            });\n        };\n        try {\n            let res;\n            let streamedAttempt = false;\n            // attempt stream only if not disabled and not using node-fetch or Bun\n            if (!isNodeFetch && !this.multipartStreamingDisabled && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getEnv)() !== \"bun\") {\n                streamedAttempt = true;\n                res = await sendWithRetry(buildStream);\n            } else {\n                res = await sendWithRetry(buildBuffered);\n            }\n            // if stream fails, fallback to buffered body\n            if ((!this.multipartStreamingDisabled || streamedAttempt) && res.status === 422 && (options?.apiUrl ?? this.apiUrl) !== DEFAULT_API_URL) {\n                console.warn(`Streaming multipart upload to ${options?.apiUrl ?? this.apiUrl}/runs/multipart failed. ` + `This usually means the host does not support chunked uploads. ` + `Retrying with a buffered upload for operation \"${context}\".`);\n                // Disable streaming for future requests\n                this.multipartStreamingDisabled = true;\n                // retry with fully-buffered body\n                res = await sendWithRetry(buildBuffered);\n            }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e) {\n            // Re-throw 404 errors so caller can fall back to batch ingest\n            if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.isLangSmithNotFoundError)(e)) {\n                throw e;\n            }\n            console.warn(`${e.message.trim()}\\n\\nContext: ${context}`);\n        }\n    }\n    async updateRun(runId, run, options) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        if (run.inputs) {\n            run.inputs = await this.processInputs(run.inputs);\n        }\n        if (run.outputs) {\n            run.outputs = await this.processOutputs(run.outputs);\n        }\n        // TODO: Untangle types\n        const data = {\n            ...run,\n            id: runId\n        };\n        if (!this._filterForSampling([\n            data\n        ], true).length) {\n            return;\n        }\n        if (this.autoBatchTracing && data.trace_id !== undefined && data.dotted_order !== undefined) {\n            const otelContext = this._cloneCurrentOTELContext();\n            if (run.end_time !== undefined && data.parent_run_id === undefined && this.blockOnRootRunFinalization && !this.manualFlushMode) {\n                // Trigger batches as soon as a root trace ends and wait to ensure trace finishes\n                // in serverless environments.\n                await this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl\n                }).catch(console.error);\n                return;\n            } else {\n                void this.processRunOperation({\n                    action: \"update\",\n                    item: data,\n                    otelContext,\n                    apiKey: options?.apiKey,\n                    apiUrl: options?.apiUrl\n                }).catch(console.error);\n            }\n            return;\n        }\n        const headers = {\n            ...this.headers,\n            \"Content-Type\": \"application/json\"\n        };\n        if (options?.apiKey !== undefined) {\n            headers[\"x-api-key\"] = options.apiKey;\n        }\n        if (options?.workspaceId !== undefined) {\n            headers[\"x-tenant-id\"] = options.workspaceId;\n        }\n        const body = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(run, `Serializing payload to update run with id: ${runId}`);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${options?.apiUrl ?? this.apiUrl}/runs/${runId}`, {\n                method: \"PATCH\",\n                headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update run\", true);\n            return res;\n        });\n    }\n    async readRun(runId, { loadChildRuns } = {\n        loadChildRuns: false\n    }) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        let run = await this._get(`/runs/${runId}`);\n        if (loadChildRuns) {\n            run = await this._loadChildRuns(run);\n        }\n        return run;\n    }\n    async getRunUrl({ runId, run, projectOpts }) {\n        if (run !== undefined) {\n            let sessionId;\n            if (run.session_id) {\n                sessionId = run.session_id;\n            } else if (projectOpts?.projectName) {\n                sessionId = (await this.readProject({\n                    projectName: projectOpts?.projectName\n                })).id;\n            } else if (projectOpts?.projectId) {\n                sessionId = projectOpts?.projectId;\n            } else {\n                const project = await this.readProject({\n                    projectName: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_4__.getLangSmithEnvironmentVariable)(\"PROJECT\") || \"default\"\n                });\n                sessionId = project.id;\n            }\n            const tenantId = await this._getTenantId();\n            return `${this.getHostUrl()}/o/${tenantId}/projects/p/${sessionId}/r/${run.id}?poll=true`;\n        } else if (runId !== undefined) {\n            const run_ = await this.readRun(runId);\n            if (!run_.app_path) {\n                throw new Error(`Run ${runId} has no app_path`);\n            }\n            const baseUrl = this.getHostUrl();\n            return `${baseUrl}${run_.app_path}`;\n        } else {\n            throw new Error(\"Must provide either runId or run\");\n        }\n    }\n    async _loadChildRuns(run) {\n        const childRuns = await toArray(this.listRuns({\n            isRoot: false,\n            projectId: run.session_id,\n            traceId: run.trace_id\n        }));\n        const treemap = {};\n        const runs = {};\n        // TODO: make dotted order required when the migration finishes\n        childRuns.sort((a, b)=>(a?.dotted_order ?? \"\").localeCompare(b?.dotted_order ?? \"\"));\n        for (const childRun of childRuns){\n            if (childRun.parent_run_id === null || childRun.parent_run_id === undefined) {\n                throw new Error(`Child run ${childRun.id} has no parent`);\n            }\n            if (childRun.dotted_order?.startsWith(run.dotted_order ?? \"\") && childRun.id !== run.id) {\n                if (!(childRun.parent_run_id in treemap)) {\n                    treemap[childRun.parent_run_id] = [];\n                }\n                treemap[childRun.parent_run_id].push(childRun);\n                runs[childRun.id] = childRun;\n            }\n        }\n        run.child_runs = treemap[run.id] || [];\n        for(const runId in treemap){\n            if (runId !== run.id) {\n                runs[runId].child_runs = treemap[runId];\n            }\n        }\n        return run;\n    }\n    /**\n     * List runs from the LangSmith server.\n     * @param projectId - The ID of the project to filter by.\n     * @param projectName - The name of the project to filter by.\n     * @param parentRunId - The ID of the parent run to filter by.\n     * @param traceId - The ID of the trace to filter by.\n     * @param referenceExampleId - The ID of the reference example to filter by.\n     * @param startTime - The start time to filter by.\n     * @param isRoot - Indicates whether to only return root runs.\n     * @param runType - The run type to filter by.\n     * @param error - Indicates whether to filter by error runs.\n     * @param id - The ID of the run to filter by.\n     * @param query - The query string to filter by.\n     * @param filter - The filter string to apply to the run spans.\n     * @param traceFilter - The filter string to apply on the root run of the trace.\n     * @param treeFilter - The filter string to apply on other runs in the trace.\n     * @param limit - The maximum number of runs to retrieve.\n     * @returns {AsyncIterable<Run>} - The runs.\n     *\n     * @example\n     * // List all runs in a project\n     * const projectRuns = client.listRuns({ projectName: \"<your_project>\" });\n     *\n     * @example\n     * // List LLM and Chat runs in the last 24 hours\n     * const todaysLLMRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   start_time: new Date(Date.now() - 24 * 60 * 60 * 1000),\n     *   run_type: \"llm\",\n     * });\n     *\n     * @example\n     * // List traces in a project\n     * const rootRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   execution_order: 1,\n     * });\n     *\n     * @example\n     * // List runs without errors\n     * const correctRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   error: false,\n     * });\n     *\n     * @example\n     * // List runs by run ID\n     * const runIds = [\n     *   \"a36092d2-4ad5-4fb4-9c0d-0dba9a2ed836\",\n     *   \"9398e6be-964f-4aa4-8ae9-ad78cd4b7074\",\n     * ];\n     * const selectedRuns = client.listRuns({ run_ids: runIds });\n     *\n     * @example\n     * // List all \"chain\" type runs that took more than 10 seconds and had `total_tokens` greater than 5000\n     * const chainRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(eq(run_type, \"chain\"), gt(latency, 10), gt(total_tokens, 5000))',\n     * });\n     *\n     * @example\n     * // List all runs called \"extractor\" whose root of the trace was assigned feedback \"user_score\" score of 1\n     * const goodExtractorRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'eq(name, \"extractor\")',\n     *   traceFilter: 'and(eq(feedback_key, \"user_score\"), eq(feedback_score, 1))',\n     * });\n     *\n     * @example\n     * // List all runs that started after a specific timestamp and either have \"error\" not equal to null or a \"Correctness\" feedback score equal to 0\n     * const complexRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(gt(start_time, \"2023-07-15T12:34:56Z\"), or(neq(error, null), and(eq(feedback_key, \"Correctness\"), eq(feedback_score, 0.0))))',\n     * });\n     *\n     * @example\n     * // List all runs where `tags` include \"experimental\" or \"beta\" and `latency` is greater than 2 seconds\n     * const taggedRuns = client.listRuns({\n     *   projectName: \"<your_project>\",\n     *   filter: 'and(or(has(tags, \"experimental\"), has(tags, \"beta\")), gt(latency, 2))',\n     * });\n     */ async *listRuns(props) {\n        const { projectId, projectName, parentRunId, traceId, referenceExampleId, startTime, executionOrder, isRoot, runType, error, id, query, filter, traceFilter, treeFilter, limit, select, order } = props;\n        let projectIds = [];\n        if (projectId) {\n            projectIds = Array.isArray(projectId) ? projectId : [\n                projectId\n            ];\n        }\n        if (projectName) {\n            const projectNames = Array.isArray(projectName) ? projectName : [\n                projectName\n            ];\n            const projectIds_ = await Promise.all(projectNames.map((name)=>this.readProject({\n                    projectName: name\n                }).then((project)=>project.id)));\n            projectIds.push(...projectIds_);\n        }\n        const default_select = [\n            \"app_path\",\n            \"completion_cost\",\n            \"completion_tokens\",\n            \"dotted_order\",\n            \"end_time\",\n            \"error\",\n            \"events\",\n            \"extra\",\n            \"feedback_stats\",\n            \"first_token_time\",\n            \"id\",\n            \"inputs\",\n            \"name\",\n            \"outputs\",\n            \"parent_run_id\",\n            \"parent_run_ids\",\n            \"prompt_cost\",\n            \"prompt_tokens\",\n            \"reference_example_id\",\n            \"run_type\",\n            \"session_id\",\n            \"start_time\",\n            \"status\",\n            \"tags\",\n            \"total_cost\",\n            \"total_tokens\",\n            \"trace_id\"\n        ];\n        const body = {\n            session: projectIds.length ? projectIds : null,\n            run_type: runType,\n            reference_example: referenceExampleId,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            execution_order: executionOrder,\n            parent_run: parentRunId,\n            start_time: startTime ? startTime.toISOString() : null,\n            error,\n            id,\n            limit,\n            trace: traceId,\n            select: select ? select : default_select,\n            is_root: isRoot,\n            order\n        };\n        if (body.select.includes(\"child_run_ids\")) {\n            (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.\");\n        }\n        let runsYielded = 0;\n        for await (const runs of this._getCursorPaginatedList(\"/runs/query\", body)){\n            if (limit) {\n                if (runsYielded >= limit) {\n                    break;\n                }\n                if (runs.length + runsYielded > limit) {\n                    const newRuns = runs.slice(0, limit - runsYielded);\n                    yield* newRuns;\n                    break;\n                }\n                runsYielded += runs.length;\n                yield* runs;\n            } else {\n                yield* runs;\n            }\n        }\n    }\n    async *listGroupRuns(props) {\n        const { projectId, projectName, groupBy, filter, startTime, endTime, limit, offset } = props;\n        const sessionId = projectId || (await this.readProject({\n            projectName\n        })).id;\n        const baseBody = {\n            session_id: sessionId,\n            group_by: groupBy,\n            filter,\n            start_time: startTime ? startTime.toISOString() : null,\n            end_time: endTime ? endTime.toISOString() : null,\n            limit: Number(limit) || 100\n        };\n        let currentOffset = Number(offset) || 0;\n        const path = \"/runs/group\";\n        const url = `${this.apiUrl}${path}`;\n        while(true){\n            const currentBody = {\n                ...baseBody,\n                offset: currentOffset\n            };\n            // Remove undefined values from the payload\n            const filteredPayload = Object.fromEntries(Object.entries(currentBody).filter(([_, value])=>value !== undefined));\n            const body = JSON.stringify(filteredPayload);\n            const response = await this.caller.call(async ()=>{\n                const res = await this._fetch(url, {\n                    method: \"POST\",\n                    headers: {\n                        ...this.headers,\n                        \"Content-Type\": \"application/json\"\n                    },\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions,\n                    body\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `Failed to fetch ${path}`);\n                return res;\n            });\n            const items = await response.json();\n            const { groups, total } = items;\n            if (groups.length === 0) {\n                break;\n            }\n            for (const thread of groups){\n                yield thread;\n            }\n            currentOffset += groups.length;\n            if (currentOffset >= total) {\n                break;\n            }\n        }\n    }\n    async getRunStats({ id, trace, parentRun, runType, projectNames, projectIds, referenceExampleIds, startTime, endTime, error, query, filter, traceFilter, treeFilter, isRoot, dataSourceType }) {\n        let projectIds_ = projectIds || [];\n        if (projectNames) {\n            projectIds_ = [\n                ...projectIds || [],\n                ...await Promise.all(projectNames.map((name)=>this.readProject({\n                        projectName: name\n                    }).then((project)=>project.id)))\n            ];\n        }\n        const payload = {\n            id,\n            trace,\n            parent_run: parentRun,\n            run_type: runType,\n            session: projectIds_,\n            reference_example: referenceExampleIds,\n            start_time: startTime,\n            end_time: endTime,\n            error,\n            query,\n            filter,\n            trace_filter: traceFilter,\n            tree_filter: treeFilter,\n            is_root: isRoot,\n            data_source_type: dataSourceType\n        };\n        // Remove undefined values from the payload\n        const filteredPayload = Object.fromEntries(Object.entries(payload).filter(([_, value])=>value !== undefined));\n        const body = JSON.stringify(filteredPayload);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/runs/stats`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run stats\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async shareRun(runId, { shareId } = {}) {\n        const data = {\n            run_id: runId,\n            share_token: shareId || uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]()\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share run\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            throw new Error(\"Invalid response from server\");\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async unshareRun(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare run\", true);\n            return res;\n        });\n    }\n    async readRunSharedLink(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/runs/${runId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read run shared link\");\n            return res;\n        });\n        const result = await response.json();\n        if (result === null || !(\"share_token\" in result)) {\n            return undefined;\n        }\n        return `${this.getHostUrl()}/public/${result[\"share_token\"]}/r`;\n    }\n    async listSharedRuns(shareToken, { runIds } = {}) {\n        const queryParams = new URLSearchParams({\n            share_token: shareToken\n        });\n        if (runIds !== undefined) {\n            for (const runId of runIds){\n                queryParams.append(\"id\", runId);\n            }\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/runs${queryParams}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared runs\");\n            return res;\n        });\n        const runs = await response.json();\n        return runs;\n    }\n    async readDatasetSharedSchema(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset shared schema\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async shareDataset(datasetId, datasetName) {\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Either datasetId or datasetName must be given\");\n        }\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId = dataset.id;\n        }\n        const data = {\n            dataset_id: datasetId\n        };\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"PUT\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"share dataset\");\n            return res;\n        });\n        const shareSchema = await response.json();\n        shareSchema.url = `${this.getHostUrl()}/public/${shareSchema.share_token}/d`;\n        return shareSchema;\n    }\n    async unshareDataset(datasetId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/share`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"unshare dataset\", true);\n            return res;\n        });\n    }\n    async readSharedDataset(shareToken) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(shareToken);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/datasets`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read shared dataset\");\n            return res;\n        });\n        const dataset = await response.json();\n        return dataset;\n    }\n    /**\n     * Get shared examples.\n     *\n     * @param {string} shareToken The share token to get examples for. A share token is the UUID (or LangSmith URL, including UUID) generated when explicitly marking an example as public.\n     * @param {Object} [options] Additional options for listing the examples.\n     * @param {string[] | undefined} [options.exampleIds] A list of example IDs to filter by.\n     * @returns {Promise<Example[]>} The shared examples.\n     */ async listSharedExamples(shareToken, options) {\n        const params = {};\n        if (options?.exampleIds) {\n            params.id = options.exampleIds;\n        }\n        const urlParams = new URLSearchParams();\n        Object.entries(params).forEach(([key, value])=>{\n            if (Array.isArray(value)) {\n                value.forEach((v)=>urlParams.append(key, v));\n            } else {\n                urlParams.append(key, value);\n            }\n        });\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/public/${shareToken}/examples?${urlParams.toString()}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"list shared examples\");\n            return res;\n        });\n        const result = await response.json();\n        if (!response.ok) {\n            if (\"detail\" in result) {\n                throw new Error(`Failed to list shared examples.\\nStatus: ${response.status}\\nMessage: ${Array.isArray(result.detail) ? result.detail.join(\"\\n\") : \"Unspecified error\"}`);\n            }\n            throw new Error(`Failed to list shared examples: ${response.status} ${response.statusText}`);\n        }\n        return result.map((example)=>({\n                ...example,\n                _hostUrl: this.getHostUrl()\n            }));\n    }\n    async createProject({ projectName, description = null, metadata = null, upsert = false, projectExtra = null, referenceDatasetId = null }) {\n        const upsert_ = upsert ? `?upsert=true` : \"\";\n        const endpoint = `${this.apiUrl}/sessions${upsert_}`;\n        const extra = projectExtra || {};\n        if (metadata) {\n            extra[\"metadata\"] = metadata;\n        }\n        const body = {\n            name: projectName,\n            extra,\n            description\n        };\n        if (referenceDatasetId !== null) {\n            body[\"reference_dataset_id\"] = referenceDatasetId;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(endpoint, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async updateProject(projectId, { name = null, description = null, metadata = null, projectExtra = null, endTime = null }) {\n        const endpoint = `${this.apiUrl}/sessions/${projectId}`;\n        let extra = projectExtra;\n        if (metadata) {\n            extra = {\n                ...extra || {},\n                metadata\n            };\n        }\n        const body = JSON.stringify({\n            name,\n            extra,\n            description,\n            end_time: endTime ? new Date(endTime).toISOString() : null\n        });\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(endpoint, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update project\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async hasProject({ projectId, projectName }) {\n        // TODO: Add a head request\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}${path}?${params}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"has project\");\n            return res;\n        });\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        try {\n            const result = await response.json();\n            if (!response.ok) {\n                return false;\n            }\n            // If it's OK and we're querying by name, need to check the list is not empty\n            if (Array.isArray(result)) {\n                return result.length > 0;\n            }\n            // projectId querying\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async readProject({ projectId, projectName, includeStats }) {\n        let path = \"/sessions\";\n        const params = new URLSearchParams();\n        if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId);\n            path += `/${projectId}`;\n        } else if (projectName !== undefined) {\n            params.append(\"name\", projectName);\n        } else {\n            throw new Error(\"Must provide projectName or projectId\");\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Project[id=${projectId}, name=${projectName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async getProjectUrl({ projectId, projectName }) {\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide either projectName or projectId\");\n        }\n        const project = await this.readProject({\n            projectId,\n            projectName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/projects/p/${project.id}`;\n    }\n    async getDatasetUrl({ datasetId, datasetName }) {\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const dataset = await this.readDataset({\n            datasetId,\n            datasetName\n        });\n        const tenantId = await this._getTenantId();\n        return `${this.getHostUrl()}/o/${tenantId}/datasets/${dataset.id}`;\n    }\n    async _getTenantId() {\n        if (this._tenantId !== null) {\n            return this._tenantId;\n        }\n        const queryParams = new URLSearchParams({\n            limit: \"1\"\n        });\n        for await (const projects of this._getPaginated(\"/sessions\", queryParams)){\n            this._tenantId = projects[0].tenant_id;\n            return projects[0].tenant_id;\n        }\n        throw new Error(\"No projects found to resolve tenant.\");\n    }\n    async *listProjects({ projectIds, name, nameContains, referenceDatasetId, referenceDatasetName, includeStats, datasetVersion, referenceFree, metadata } = {}) {\n        const params = new URLSearchParams();\n        if (projectIds !== undefined) {\n            for (const projectId of projectIds){\n                params.append(\"id\", projectId);\n            }\n        }\n        if (name !== undefined) {\n            params.append(\"name\", name);\n        }\n        if (nameContains !== undefined) {\n            params.append(\"name_contains\", nameContains);\n        }\n        if (referenceDatasetId !== undefined) {\n            params.append(\"reference_dataset\", referenceDatasetId);\n        } else if (referenceDatasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName: referenceDatasetName\n            });\n            params.append(\"reference_dataset\", dataset.id);\n        }\n        if (includeStats !== undefined) {\n            params.append(\"include_stats\", includeStats.toString());\n        }\n        if (datasetVersion !== undefined) {\n            params.append(\"dataset_version\", datasetVersion);\n        }\n        if (referenceFree !== undefined) {\n            params.append(\"reference_free\", referenceFree.toString());\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const projects of this._getPaginated(\"/sessions\", params)){\n            yield* projects;\n        }\n    }\n    async deleteProject({ projectId, projectName }) {\n        let projectId_;\n        if (projectId === undefined && projectName === undefined) {\n            throw new Error(\"Must provide projectName or projectId\");\n        } else if (projectId !== undefined && projectName !== undefined) {\n            throw new Error(\"Must provide either projectName or projectId, not both\");\n        } else if (projectId === undefined) {\n            projectId_ = (await this.readProject({\n                projectName\n            })).id;\n        } else {\n            projectId_ = projectId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(projectId_);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/sessions/${projectId_}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete session ${projectId_} (${projectName})`, true);\n            return res;\n        });\n    }\n    async uploadCsv({ csvFile, fileName, inputKeys, outputKeys, description, dataType, name }) {\n        const url = `${this.apiUrl}/datasets/upload`;\n        const formData = new FormData();\n        formData.append(\"file\", csvFile, fileName);\n        inputKeys.forEach((key)=>{\n            formData.append(\"input_keys\", key);\n        });\n        outputKeys.forEach((key)=>{\n            formData.append(\"output_keys\", key);\n        });\n        if (description) {\n            formData.append(\"description\", description);\n        }\n        if (dataType) {\n            formData.append(\"data_type\", dataType);\n        }\n        if (name) {\n            formData.append(\"name\", name);\n        }\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload CSV\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async createDataset(name, { description, dataType, inputsSchema, outputsSchema, metadata } = {}) {\n        const body = {\n            name,\n            description,\n            extra: metadata ? {\n                metadata\n            } : undefined\n        };\n        if (dataType) {\n            body.data_type = dataType;\n        }\n        if (inputsSchema) {\n            body.inputs_schema_definition = inputsSchema;\n        }\n        if (outputsSchema) {\n            body.outputs_schema_definition = outputsSchema;\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create dataset\");\n            return res;\n        });\n        const result = await response.json();\n        return result;\n    }\n    async readDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        // limit to 1 result\n        const params = new URLSearchParams({\n            limit: \"1\"\n        });\n        if (datasetId && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n            path += `/${datasetId}`;\n        } else if (datasetName) {\n            params.append(\"name\", datasetName);\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        const response = await this._get(path, params);\n        let result;\n        if (Array.isArray(response)) {\n            if (response.length === 0) {\n                throw new Error(`Dataset[id=${datasetId}, name=${datasetName}] not found`);\n            }\n            result = response[0];\n        } else {\n            result = response;\n        }\n        return result;\n    }\n    async hasDataset({ datasetId, datasetName }) {\n        try {\n            await this.readDataset({\n                datasetId,\n                datasetName\n            });\n            return true;\n        } catch (e) {\n            if (// eslint-disable-next-line no-instanceof/no-instanceof\n            e instanceof Error && e.message.toLocaleLowerCase().includes(\"not found\")) {\n                return false;\n            }\n            throw e;\n        }\n    }\n    async diffDatasetVersions({ datasetId, datasetName, fromVersion, toVersion }) {\n        let datasetId_ = datasetId;\n        if (datasetId_ === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        const urlParams = new URLSearchParams({\n            from_version: typeof fromVersion === \"string\" ? fromVersion : fromVersion.toISOString(),\n            to_version: typeof toVersion === \"string\" ? toVersion : toVersion.toISOString()\n        });\n        const response = await this._get(`/datasets/${datasetId_}/versions/diff`, urlParams);\n        return response;\n    }\n    async readDatasetOpenaiFinetuning({ datasetId, datasetName }) {\n        const path = \"/datasets\";\n        if (datasetId !== undefined) {\n        // do nothing\n        } else if (datasetName !== undefined) {\n            datasetId = (await this.readDataset({\n                datasetName\n            })).id;\n        } else {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const response = await this._getResponse(`${path}/${datasetId}/openai_ft`);\n        const datasetText = await response.text();\n        const dataset = datasetText.trim().split(\"\\n\").map((line)=>JSON.parse(line));\n        return dataset;\n    }\n    async *listDatasets({ limit = 100, offset = 0, datasetIds, datasetName, datasetNameContains, metadata } = {}) {\n        const path = \"/datasets\";\n        const params = new URLSearchParams({\n            limit: limit.toString(),\n            offset: offset.toString()\n        });\n        if (datasetIds !== undefined) {\n            for (const id_ of datasetIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (datasetName !== undefined) {\n            params.append(\"name\", datasetName);\n        }\n        if (datasetNameContains !== undefined) {\n            params.append(\"name_contains\", datasetNameContains);\n        }\n        if (metadata !== undefined) {\n            params.append(\"metadata\", JSON.stringify(metadata));\n        }\n        for await (const datasets of this._getPaginated(path, params)){\n            yield* datasets;\n        }\n    }\n    /**\n     * Update a dataset\n     * @param props The dataset details to update\n     * @returns The updated dataset\n     */ async updateDataset(props) {\n        const { datasetId, datasetName, ...update } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify(update);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset\");\n            return res;\n        });\n        return await response.json();\n    }\n    /**\n     * Updates a tag on a dataset.\n     *\n     * If the tag is already assigned to a different version of this dataset,\n     * the tag will be moved to the new version. The as_of parameter is used to\n     * determine which version of the dataset to apply the new tags to.\n     *\n     * It must be an exact version of the dataset to succeed. You can\n     * use the \"readDatasetVersion\" method to find the exact version\n     * to apply the tags to.\n     * @param params.datasetId The ID of the dataset to update. Must be provided if \"datasetName\" is not provided.\n     * @param params.datasetName The name of the dataset to update. Must be provided if \"datasetId\" is not provided.\n     * @param params.asOf The timestamp of the dataset to apply the new tags to.\n     * @param params.tag The new tag to apply to the dataset.\n     */ async updateDatasetTag(props) {\n        const { datasetId, datasetName, asOf, tag } = props;\n        if (!datasetId && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        }\n        const _datasetId = datasetId ?? (await this.readDataset({\n            datasetName\n        })).id;\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(_datasetId);\n        const body = JSON.stringify({\n            as_of: typeof asOf === \"string\" ? asOf : asOf.toISOString(),\n            tag\n        });\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${_datasetId}/tags`, {\n                method: \"PUT\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset tags\", true);\n            return res;\n        });\n    }\n    async deleteDataset({ datasetId, datasetName }) {\n        let path = \"/datasets\";\n        let datasetId_ = datasetId;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        if (datasetId_ !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n            path += `/${datasetId_}`;\n        } else {\n            throw new Error(\"Must provide datasetName or datasetId\");\n        }\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async indexDataset({ datasetId, datasetName, tag }) {\n        let datasetId_ = datasetId;\n        if (!datasetId_ && !datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ && datasetName) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (!datasetId_) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            tag: tag\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/index`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"index dataset\");\n            return res;\n        });\n        await response.json();\n    }\n    /**\n     * Lets you run a similarity search query on a dataset.\n     *\n     * Requires the dataset to be indexed. Please see the `indexDataset` method to set up indexing.\n     *\n     * @param inputs      The input on which to run the similarity search. Must have the\n     *                    same schema as the dataset.\n     *\n     * @param datasetId   The dataset to search for similar examples.\n     *\n     * @param limit       The maximum number of examples to return. Will return the top `limit` most\n     *                    similar examples in order of most similar to least similar. If no similar\n     *                    examples are found, random examples will be returned.\n     *\n     * @param filter      A filter string to apply to the search. Only examples will be returned that\n     *                    match the filter string. Some examples of filters\n     *\n     *                    - eq(metadata.mykey, \"value\")\n     *                    - and(neq(metadata.my.nested.key, \"value\"), neq(metadata.mykey, \"value\"))\n     *                    - or(eq(metadata.mykey, \"value\"), eq(metadata.mykey, \"othervalue\"))\n     *\n     * @returns           A list of similar examples.\n     *\n     *\n     * @example\n     * dataset_id = \"123e4567-e89b-12d3-a456-426614174000\"\n     * inputs = {\"text\": \"How many people live in Berlin?\"}\n     * limit = 5\n     * examples = await client.similarExamples(inputs, dataset_id, limit)\n     */ async similarExamples(inputs, datasetId, limit, { filter } = {}) {\n        const data = {\n            limit: limit,\n            inputs: inputs\n        };\n        if (filter !== undefined) {\n            data[\"filter\"] = filter;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId);\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId}/search`, {\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                method: \"POST\",\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"fetch similar examples\");\n            return res;\n        });\n        const result = await response.json();\n        return result[\"examples\"];\n    }\n    async createExample(inputsOrUpdate, outputs, options) {\n        if (isExampleCreate(inputsOrUpdate)) {\n            if (outputs !== undefined || options !== undefined) {\n                throw new Error(\"Cannot provide outputs or options when using ExampleCreate object\");\n            }\n        }\n        let datasetId_ = outputs ? options?.datasetId : inputsOrUpdate.dataset_id;\n        const datasetName_ = outputs ? options?.datasetName : inputsOrUpdate.dataset_name;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const createdAt_ = (outputs ? options?.createdAt : inputsOrUpdate.created_at) || new Date();\n        let data;\n        if (!isExampleCreate(inputsOrUpdate)) {\n            data = {\n                inputs: inputsOrUpdate,\n                outputs,\n                created_at: createdAt_?.toISOString(),\n                id: options?.exampleId,\n                metadata: options?.metadata,\n                split: options?.split,\n                source_run_id: options?.sourceRunId,\n                use_source_run_io: options?.useSourceRunIO,\n                use_source_run_attachments: options?.useSourceRunAttachments,\n                attachments: options?.attachments\n            };\n        } else {\n            data = inputsOrUpdate;\n        }\n        const response = await this._uploadExamplesMultipart(datasetId_, [\n            data\n        ]);\n        const example = await this.readExample(response.example_ids?.[0] ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]());\n        return example;\n    }\n    async createExamples(propsOrUploads) {\n        if (Array.isArray(propsOrUploads)) {\n            if (propsOrUploads.length === 0) {\n                return [];\n            }\n            const uploads = propsOrUploads;\n            let datasetId_ = uploads[0].dataset_id;\n            const datasetName_ = uploads[0].dataset_name;\n            if (datasetId_ === undefined && datasetName_ === undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId\");\n            } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n                throw new Error(\"Must provide either datasetName or datasetId, not both\");\n            } else if (datasetId_ === undefined) {\n                const dataset = await this.readDataset({\n                    datasetName: datasetName_\n                });\n                datasetId_ = dataset.id;\n            }\n            const response = await this._uploadExamplesMultipart(datasetId_, uploads);\n            const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n            return examples;\n        }\n        const { inputs, outputs, metadata, splits, sourceRunIds, useSourceRunIOs, useSourceRunAttachments, attachments, exampleIds, datasetId, datasetName } = propsOrUploads;\n        if (inputs === undefined) {\n            throw new Error(\"Must provide inputs when using legacy parameters\");\n        }\n        let datasetId_ = datasetId;\n        const datasetName_ = datasetName;\n        if (datasetId_ === undefined && datasetName_ === undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId\");\n        } else if (datasetId_ !== undefined && datasetName_ !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId_ === undefined) {\n            const dataset = await this.readDataset({\n                datasetName: datasetName_\n            });\n            datasetId_ = dataset.id;\n        }\n        const formattedExamples = inputs.map((input, idx)=>{\n            return {\n                dataset_id: datasetId_,\n                inputs: input,\n                outputs: outputs?.[idx],\n                metadata: metadata?.[idx],\n                split: splits?.[idx],\n                id: exampleIds?.[idx],\n                attachments: attachments?.[idx],\n                source_run_id: sourceRunIds?.[idx],\n                use_source_run_io: useSourceRunIOs?.[idx],\n                use_source_run_attachments: useSourceRunAttachments?.[idx]\n            };\n        });\n        const response = await this._uploadExamplesMultipart(datasetId_, formattedExamples);\n        const examples = await Promise.all(response.example_ids.map((id)=>this.readExample(id)));\n        return examples;\n    }\n    async createLLMExample(input, generation, options) {\n        return this.createExample({\n            input\n        }, {\n            output: generation\n        }, options);\n    }\n    async createChatExample(input, generations, options) {\n        const finalInput = input.map((message)=>{\n            if ((0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(message)) {\n                return (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(message);\n            }\n            return message;\n        });\n        const finalOutput = (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.isLangChainMessage)(generations) ? (0,_utils_messages_js__WEBPACK_IMPORTED_MODULE_3__.convertLangChainMessageToExample)(generations) : generations;\n        return this.createExample({\n            input: finalInput\n        }, {\n            output: finalOutput\n        }, options);\n    }\n    async readExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        const rawExample = await this._get(path);\n        const { attachment_urls, ...rest } = rawExample;\n        const example = rest;\n        if (attachment_urls) {\n            example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                acc[key.slice(\"attachment.\".length)] = {\n                    presigned_url: value.presigned_url,\n                    mime_type: value.mime_type\n                };\n                return acc;\n            }, {});\n        }\n        return example;\n    }\n    async *listExamples({ datasetId, datasetName, exampleIds, asOf, splits, inlineS3Urls, metadata, limit, offset, filter, includeAttachments } = {}) {\n        let datasetId_;\n        if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId !== undefined) {\n            datasetId_ = datasetId;\n        } else if (datasetName !== undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            throw new Error(\"Must provide a datasetName or datasetId\");\n        }\n        const params = new URLSearchParams({\n            dataset: datasetId_\n        });\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const inlineS3Urls_ = inlineS3Urls ?? true;\n        params.append(\"inline_s3_urls\", inlineS3Urls_.toString());\n        if (exampleIds !== undefined) {\n            for (const id_ of exampleIds){\n                params.append(\"id\", id_);\n            }\n        }\n        if (splits !== undefined) {\n            for (const split of splits){\n                params.append(\"splits\", split);\n            }\n        }\n        if (metadata !== undefined) {\n            const serializedMetadata = JSON.stringify(metadata);\n            params.append(\"metadata\", serializedMetadata);\n        }\n        if (limit !== undefined) {\n            params.append(\"limit\", limit.toString());\n        }\n        if (offset !== undefined) {\n            params.append(\"offset\", offset.toString());\n        }\n        if (filter !== undefined) {\n            params.append(\"filter\", filter);\n        }\n        if (includeAttachments === true) {\n            [\n                \"attachment_urls\",\n                \"outputs\",\n                \"metadata\"\n            ].forEach((field)=>params.append(\"select\", field));\n        }\n        let i = 0;\n        for await (const rawExamples of this._getPaginated(\"/examples\", params)){\n            for (const rawExample of rawExamples){\n                const { attachment_urls, ...rest } = rawExample;\n                const example = rest;\n                if (attachment_urls) {\n                    example.attachments = Object.entries(attachment_urls).reduce((acc, [key, value])=>{\n                        acc[key.slice(\"attachment.\".length)] = {\n                            presigned_url: value.presigned_url,\n                            mime_type: value.mime_type || undefined\n                        };\n                        return acc;\n                    }, {});\n                }\n                yield example;\n                i++;\n            }\n            if (limit !== undefined && i >= limit) {\n                break;\n            }\n        }\n    }\n    async deleteExample(exampleId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        const path = `/examples/${exampleId}`;\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    /**\n     * Delete multiple examples by ID.\n     * @param exampleIds - The IDs of the examples to delete\n     * @param options - Optional settings for deletion\n     * @param options.hardDelete - If true, permanently delete examples. If false (default), soft delete them.\n     */ async deleteExamples(exampleIds, options) {\n        // Validate all UUIDs\n        exampleIds.forEach((id)=>(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id));\n        if (options?.hardDelete) {\n            // Hard delete uses POST to a different platform endpoint\n            const path = this._getPlatformEndpointPath(\"datasets/examples/delete\");\n            await this.caller.call(async ()=>{\n                const res = await this._fetch(`${this.apiUrl}${path}`, {\n                    method: \"POST\",\n                    headers: {\n                        ...this.headers,\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        example_ids: exampleIds,\n                        hard_delete: true\n                    }),\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"hard delete examples\", true);\n                return res;\n            });\n        } else {\n            // Soft delete uses DELETE with query params\n            const params = new URLSearchParams();\n            exampleIds.forEach((id)=>params.append(\"example_ids\", id));\n            await this.caller.call(async ()=>{\n                const res = await this._fetch(`${this.apiUrl}/examples?${params.toString()}`, {\n                    method: \"DELETE\",\n                    headers: this.headers,\n                    signal: AbortSignal.timeout(this.timeout_ms),\n                    ...this.fetchOptions\n                });\n                await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete examples\", true);\n                return res;\n            });\n        }\n    }\n    async updateExample(exampleIdOrUpdate, update) {\n        let exampleId;\n        if (update) {\n            exampleId = exampleIdOrUpdate;\n        } else {\n            exampleId = exampleIdOrUpdate.id;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(exampleId);\n        let updateToUse;\n        if (update) {\n            updateToUse = {\n                id: exampleId,\n                ...update\n            };\n        } else {\n            updateToUse = exampleIdOrUpdate;\n        }\n        let datasetId;\n        if (updateToUse.dataset_id !== undefined) {\n            datasetId = updateToUse.dataset_id;\n        } else {\n            const example = await this.readExample(exampleId);\n            datasetId = example.dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, [\n            updateToUse\n        ]);\n    }\n    async updateExamples(update) {\n        // We will naively get dataset id from first example and assume it works for all\n        let datasetId;\n        if (update[0].dataset_id === undefined) {\n            const example = await this.readExample(update[0].id);\n            datasetId = example.dataset_id;\n        } else {\n            datasetId = update[0].dataset_id;\n        }\n        return this._updateExamplesMultipart(datasetId, update);\n    }\n    /**\n     * Get dataset version by closest date or exact tag.\n     *\n     * Use this to resolve the nearest version to a given timestamp or for a given tag.\n     *\n     * @param options The options for getting the dataset version\n     * @param options.datasetId The ID of the dataset\n     * @param options.datasetName The name of the dataset\n     * @param options.asOf The timestamp of the dataset to retrieve\n     * @param options.tag The tag of the dataset to retrieve\n     * @returns The dataset version\n     */ async readDatasetVersion({ datasetId, datasetName, asOf, tag }) {\n        let resolvedDatasetId;\n        if (!datasetId) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            resolvedDatasetId = dataset.id;\n        } else {\n            resolvedDatasetId = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(resolvedDatasetId);\n        if (asOf && tag || !asOf && !tag) {\n            throw new Error(\"Exactly one of asOf and tag must be specified.\");\n        }\n        const params = new URLSearchParams();\n        if (asOf !== undefined) {\n            params.append(\"as_of\", typeof asOf === \"string\" ? asOf : asOf.toISOString());\n        }\n        if (tag !== undefined) {\n            params.append(\"tag\", tag);\n        }\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${resolvedDatasetId}/version?${params.toString()}`, {\n                method: \"GET\",\n                headers: {\n                    ...this.headers\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read dataset version\");\n            return res;\n        });\n        return await response.json();\n    }\n    async listDatasetSplits({ datasetId, datasetName, asOf }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const params = new URLSearchParams();\n        const dataset_version = asOf ? typeof asOf === \"string\" ? asOf : asOf?.toISOString() : undefined;\n        if (dataset_version) {\n            params.append(\"as_of\", dataset_version);\n        }\n        const response = await this._get(`/datasets/${datasetId_}/splits`, params);\n        return response;\n    }\n    async updateDatasetSplits({ datasetId, datasetName, splitName, exampleIds, remove = false }) {\n        let datasetId_;\n        if (datasetId === undefined && datasetName === undefined) {\n            throw new Error(\"Must provide dataset name or ID\");\n        } else if (datasetId !== undefined && datasetName !== undefined) {\n            throw new Error(\"Must provide either datasetName or datasetId, not both\");\n        } else if (datasetId === undefined) {\n            const dataset = await this.readDataset({\n                datasetName\n            });\n            datasetId_ = dataset.id;\n        } else {\n            datasetId_ = datasetId;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(datasetId_);\n        const data = {\n            split_name: splitName,\n            examples: exampleIds.map((id)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id);\n                return id;\n            }),\n            remove\n        };\n        const body = JSON.stringify(data);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/${datasetId_}/splits`, {\n                method: \"PUT\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update dataset splits\", true);\n            return res;\n        });\n    }\n    async createFeedback(runId, key, { score, value, correction, comment, sourceInfo, feedbackSourceType = \"api\", sourceRunId, feedbackId, feedbackConfig, projectId, comparativeExperimentId }) {\n        if (!runId && !projectId) {\n            throw new Error(\"One of runId or projectId must be provided\");\n        }\n        if (runId && projectId) {\n            throw new Error(\"Only one of runId or projectId can be provided\");\n        }\n        const feedback_source = {\n            type: feedbackSourceType ?? \"api\",\n            metadata: sourceInfo ?? {}\n        };\n        if (sourceRunId !== undefined && feedback_source?.metadata !== undefined && !feedback_source.metadata[\"__run\"]) {\n            feedback_source.metadata[\"__run\"] = {\n                run_id: sourceRunId\n            };\n        }\n        if (feedback_source?.metadata !== undefined && feedback_source.metadata[\"__run\"]?.run_id !== undefined) {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedback_source.metadata[\"__run\"].run_id);\n        }\n        const feedback = {\n            id: feedbackId ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"](),\n            run_id: runId,\n            key,\n            score: _formatFeedbackScore(score),\n            value,\n            correction,\n            comment,\n            feedback_source: feedback_source,\n            comparative_experiment_id: comparativeExperimentId,\n            feedbackConfig,\n            session_id: projectId\n        };\n        const body = JSON.stringify(feedback);\n        const url = `${this.apiUrl}/feedback`;\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(url, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create feedback\", true);\n            return res;\n        });\n        return feedback;\n    }\n    async updateFeedback(feedbackId, { score, value, correction, comment }) {\n        const feedbackUpdate = {};\n        if (score !== undefined && score !== null) {\n            feedbackUpdate[\"score\"] = _formatFeedbackScore(score);\n        }\n        if (value !== undefined && value !== null) {\n            feedbackUpdate[\"value\"] = value;\n        }\n        if (correction !== undefined && correction !== null) {\n            feedbackUpdate[\"correction\"] = correction;\n        }\n        if (comment !== undefined && comment !== null) {\n            feedbackUpdate[\"comment\"] = comment;\n        }\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const body = JSON.stringify(feedbackUpdate);\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/feedback/${feedbackId}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update feedback\", true);\n            return res;\n        });\n    }\n    async readFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        const response = await this._get(path);\n        return response;\n    }\n    async deleteFeedback(feedbackId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(feedbackId);\n        const path = `/feedback/${feedbackId}`;\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(this.apiUrl + path, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `delete ${path}`, true);\n            return res;\n        });\n    }\n    async *listFeedback({ runIds, feedbackKeys, feedbackSourceTypes } = {}) {\n        const queryParams = new URLSearchParams();\n        if (runIds) {\n            for (const runId of runIds){\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n                queryParams.append(\"run\", runId);\n            }\n        }\n        if (feedbackKeys) {\n            for (const key of feedbackKeys){\n                queryParams.append(\"key\", key);\n            }\n        }\n        if (feedbackSourceTypes) {\n            for (const type of feedbackSourceTypes){\n                queryParams.append(\"source\", type);\n            }\n        }\n        for await (const feedbacks of this._getPaginated(\"/feedback\", queryParams)){\n            yield* feedbacks;\n        }\n    }\n    /**\n     * Creates a presigned feedback token and URL.\n     *\n     * The token can be used to authorize feedback metrics without\n     * needing an API key. This is useful for giving browser-based\n     * applications the ability to submit feedback without needing\n     * to expose an API key.\n     *\n     * @param runId The ID of the run.\n     * @param feedbackKey The feedback key.\n     * @param options Additional options for the token.\n     * @param options.expiration The expiration time for the token.\n     *\n     * @returns A promise that resolves to a FeedbackIngestToken.\n     */ async createPresignedFeedbackToken(runId, feedbackKey, { expiration, feedbackConfig } = {}) {\n        const body = {\n            run_id: runId,\n            feedback_key: feedbackKey,\n            feedback_config: feedbackConfig\n        };\n        if (expiration) {\n            if (typeof expiration === \"string\") {\n                body[\"expires_at\"] = expiration;\n            } else if (expiration?.hours || expiration?.minutes || expiration?.days) {\n                body[\"expires_in\"] = expiration;\n            }\n        } else {\n            body[\"expires_in\"] = {\n                hours: 3\n            };\n        }\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/feedback/tokens`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create presigned feedback token\");\n            return res;\n        });\n        return await response.json();\n    }\n    async createComparativeExperiment({ name, experimentIds, referenceDatasetId, createdAt, description, metadata, id }) {\n        if (experimentIds.length === 0) {\n            throw new Error(\"At least one experiment is required\");\n        }\n        if (!referenceDatasetId) {\n            referenceDatasetId = (await this.readProject({\n                projectId: experimentIds[0]\n            })).reference_dataset_id;\n        }\n        if (!referenceDatasetId == null) {\n            throw new Error(\"A reference dataset is required\");\n        }\n        const body = {\n            id,\n            name,\n            experiment_ids: experimentIds,\n            reference_dataset_id: referenceDatasetId,\n            description,\n            created_at: (createdAt ?? new Date())?.toISOString(),\n            extra: {}\n        };\n        if (metadata) body.extra[\"metadata\"] = metadata;\n        const serializedBody = JSON.stringify(body);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/datasets/comparative`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create comparative experiment\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Retrieves a list of presigned feedback tokens for a given run ID.\n     * @param runId The ID of the run.\n     * @returns An async iterable of FeedbackIngestToken objects.\n     */ async *listPresignedFeedbackTokens(runId) {\n        (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(runId);\n        const params = new URLSearchParams({\n            run_id: runId\n        });\n        for await (const tokens of this._getPaginated(\"/feedback/tokens\", params)){\n            yield* tokens;\n        }\n    }\n    _selectEvalResults(results) {\n        let results_;\n        if (\"results\" in results) {\n            results_ = results.results;\n        } else if (Array.isArray(results)) {\n            results_ = results;\n        } else {\n            results_ = [\n                results\n            ];\n        }\n        return results_;\n    }\n    async _logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const evalResults = this._selectEvalResults(evaluatorResponse);\n        const feedbacks = [];\n        for (const res of evalResults){\n            let sourceInfo_ = sourceInfo || {};\n            if (res.evaluatorInfo) {\n                sourceInfo_ = {\n                    ...res.evaluatorInfo,\n                    ...sourceInfo_\n                };\n            }\n            let runId_ = null;\n            if (res.targetRunId) {\n                runId_ = res.targetRunId;\n            } else if (run) {\n                runId_ = run.id;\n            }\n            feedbacks.push(await this.createFeedback(runId_, res.key, {\n                score: res.score,\n                value: res.value,\n                comment: res.comment,\n                correction: res.correction,\n                sourceInfo: sourceInfo_,\n                sourceRunId: res.sourceRunId,\n                feedbackConfig: res.feedbackConfig,\n                feedbackSourceType: \"model\"\n            }));\n        }\n        return [\n            evalResults,\n            feedbacks\n        ];\n    }\n    async logEvaluationFeedback(evaluatorResponse, run, sourceInfo) {\n        const [results] = await this._logEvaluationFeedback(evaluatorResponse, run, sourceInfo);\n        return results;\n    }\n    /**\n     * API for managing annotation queues\n     */ /**\n     * List the annotation queues on the LangSmith API.\n     * @param options - The options for listing annotation queues\n     * @param options.queueIds - The IDs of the queues to filter by\n     * @param options.name - The name of the queue to filter by\n     * @param options.nameContains - The substring that the queue name should contain\n     * @param options.limit - The maximum number of queues to return\n     * @returns An iterator of AnnotationQueue objects\n     */ async *listAnnotationQueues(options = {}) {\n        const { queueIds, name, nameContains, limit } = options;\n        const params = new URLSearchParams();\n        if (queueIds) {\n            queueIds.forEach((id, i)=>{\n                (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `queueIds[${i}]`);\n                params.append(\"ids\", id);\n            });\n        }\n        if (name) params.append(\"name\", name);\n        if (nameContains) params.append(\"name_contains\", nameContains);\n        params.append(\"limit\", (limit !== undefined ? Math.min(limit, 100) : 100).toString());\n        let count = 0;\n        for await (const queues of this._getPaginated(\"/annotation-queues\", params)){\n            yield* queues;\n            count++;\n            if (limit !== undefined && count >= limit) break;\n        }\n    }\n    /**\n     * Create an annotation queue on the LangSmith API.\n     * @param options - The options for creating an annotation queue\n     * @param options.name - The name of the annotation queue\n     * @param options.description - The description of the annotation queue\n     * @param options.queueId - The ID of the annotation queue\n     * @returns The created AnnotationQueue object\n     */ async createAnnotationQueue(options) {\n        const { name, description, queueId, rubricInstructions } = options;\n        const body = {\n            name,\n            description,\n            id: queueId || uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"](),\n            rubric_instructions: rubricInstructions\n        };\n        const serializedBody = JSON.stringify(Object.fromEntries(Object.entries(body).filter(([_, v])=>v !== undefined)));\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: serializedBody\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Read an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to read\n     * @returns The AnnotationQueueWithDetails object\n     */ async readAnnotationQueue(queueId) {\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"read annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Update an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to update\n     * @param options - The options for updating the annotation queue\n     * @param options.name - The new name for the annotation queue\n     * @param options.description - The new description for the annotation queue\n     */ async updateAnnotationQueue(queueId, options) {\n        const { name, description, rubricInstructions } = options;\n        const body = JSON.stringify({\n            name,\n            description,\n            rubric_instructions: rubricInstructions\n        });\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Delete an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue to delete\n     */ async deleteAnnotationQueue(queueId) {\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}`, {\n                method: \"DELETE\",\n                headers: {\n                    ...this.headers,\n                    Accept: \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Add runs to an annotation queue with the specified queue ID.\n     * @param queueId - The ID of the annotation queue\n     * @param runIds - The IDs of the runs to be added to the annotation queue\n     */ async addRunsToAnnotationQueue(queueId, runIds) {\n        const body = JSON.stringify(runIds.map((id, i)=>(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(id, `runIds[${i}]`).toString()));\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"add runs to annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get a run from an annotation queue at the specified index.\n     * @param queueId - The ID of the annotation queue\n     * @param index - The index of the run to retrieve\n     * @returns A Promise that resolves to a RunWithAnnotationQueueInfo object\n     * @throws {Error} If the run is not found at the given index or for other API-related errors\n     */ async getRunFromAnnotationQueue(queueId, index) {\n        const baseUrl = `/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/run`;\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}${baseUrl}/${index}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get run from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Delete a run from an an annotation queue.\n     * @param queueId - The ID of the annotation queue to delete the run from\n     * @param queueRunId - The ID of the run to delete from the annotation queue\n     */ async deleteRunFromAnnotationQueue(queueId, queueRunId) {\n        await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/runs/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueRunId, \"queueRunId\")}`, {\n                method: \"DELETE\",\n                headers: {\n                    ...this.headers,\n                    Accept: \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete run from annotation queue\", true);\n            return res;\n        });\n    }\n    /**\n     * Get the size of an annotation queue.\n     * @param queueId - The ID of the annotation queue\n     */ async getSizeFromAnnotationQueue(queueId) {\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/annotation-queues/${(0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(queueId, \"queueId\")}/size`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get size from annotation queue\");\n            return res;\n        });\n        return response.json();\n    }\n    async _currentTenantIsOwner(owner) {\n        const settings = await this._getSettings();\n        return owner == \"-\" || settings.tenant_handle === owner;\n    }\n    async _ownerConflictError(action, owner) {\n        const settings = await this._getSettings();\n        return new Error(`Cannot ${action} for another tenant.\\n\n      Current tenant: ${settings.tenant_handle}\\n\n      Requested tenant: ${owner}`);\n    }\n    async _getLatestCommitHash(promptOwnerAndName) {\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/commits/${promptOwnerAndName}/?limit=${1}&offset=${0}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get latest commit hash\");\n            return res;\n        });\n        const json = await response.json();\n        if (json.commits.length === 0) {\n            return undefined;\n        }\n        return json.commits[0].commit_hash;\n    }\n    async _likeOrUnlikePrompt(promptIdentifier, like) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const body = JSON.stringify({\n            like: like\n        });\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/likes/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, `${like ? \"like\" : \"unlike\"} prompt`);\n            return res;\n        });\n        return response.json();\n    }\n    async _getPromptUrl(promptIdentifier) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}/${commitHash.substring(0, 8)}`;\n            } else {\n                return `${this.getHostUrl()}/hub/${owner}/${promptName}`;\n            }\n        } else {\n            const settings = await this._getSettings();\n            if (commitHash !== \"latest\") {\n                return `${this.getHostUrl()}/prompts/${promptName}/${commitHash.substring(0, 8)}?organizationId=${settings.id}`;\n            } else {\n                return `${this.getHostUrl()}/prompts/${promptName}?organizationId=${settings.id}`;\n            }\n        }\n    }\n    async promptExists(promptIdentifier) {\n        const prompt = await this.getPrompt(promptIdentifier);\n        return !!prompt;\n    }\n    async likePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, true);\n    }\n    async unlikePrompt(promptIdentifier) {\n        return this._likeOrUnlikePrompt(promptIdentifier, false);\n    }\n    async *listCommits(promptOwnerAndName) {\n        for await (const commits of this._getPaginated(`/commits/${promptOwnerAndName}/`, new URLSearchParams(), (res)=>res.commits)){\n            yield* commits;\n        }\n    }\n    async *listPrompts(options) {\n        const params = new URLSearchParams();\n        params.append(\"sort_field\", options?.sortField ?? \"updated_at\");\n        params.append(\"sort_direction\", \"desc\");\n        params.append(\"is_archived\", (!!options?.isArchived).toString());\n        if (options?.isPublic !== undefined) {\n            params.append(\"is_public\", options.isPublic.toString());\n        }\n        if (options?.query) {\n            params.append(\"query\", options.query);\n        }\n        for await (const prompts of this._getPaginated(\"/repos\", params, (res)=>res.repos)){\n            yield* prompts;\n        }\n    }\n    async getPrompt(promptIdentifier) {\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            if (res?.status === 404) {\n                return null;\n            }\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"get prompt\");\n            return res;\n        });\n        const result = await response?.json();\n        if (result?.repo) {\n            return result.repo;\n        } else {\n            return null;\n        }\n    }\n    async createPrompt(promptIdentifier, options) {\n        const settings = await this._getSettings();\n        if (options?.isPublic && !settings.tenant_handle) {\n            throw new Error(`Cannot create a public prompt without first\\n\n        creating a LangChain Hub handle.\n        You can add a handle by creating a public prompt at:\\n\n        https://smith.langchain.com/prompts`);\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"create a prompt\", owner);\n        }\n        const data = {\n            repo_handle: promptName,\n            ...options?.description && {\n                description: options.description\n            },\n            ...options?.readme && {\n                readme: options.readme\n            },\n            ...options?.tags && {\n                tags: options.tags\n            },\n            is_public: !!options?.isPublic\n        };\n        const body = JSON.stringify(data);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/repos/`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create prompt\");\n            return res;\n        });\n        const { repo } = await response.json();\n        return repo;\n    }\n    async createCommit(promptIdentifier, object, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const resolvedParentCommitHash = options?.parentCommitHash === \"latest\" || !options?.parentCommitHash ? await this._getLatestCommitHash(`${owner}/${promptName}`) : options?.parentCommitHash;\n        const payload = {\n            manifest: JSON.parse(JSON.stringify(object)),\n            parent_commit: resolvedParentCommitHash\n        };\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}`, {\n                method: \"POST\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"create commit\");\n            return res;\n        });\n        const result = await response.json();\n        return this._getPromptUrl(`${owner}/${promptName}${result.commit_hash ? `:${result.commit_hash}` : \"\"}`);\n    }\n    /**\n     * Update examples with attachments using multipart form data.\n     * @param updates List of ExampleUpdateWithAttachments objects to upsert\n     * @returns Promise with the update response\n     */ async updateExamplesMultipart(datasetId, updates = []) {\n        return this._updateExamplesMultipart(datasetId, updates);\n    }\n    async _updateExamplesMultipart(datasetId, updates = []) {\n        if (!await this._getDatasetExamplesMultiPartSupport()) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of updates){\n            const exampleId = example.id;\n            // Prepare the main example body\n            const exampleBody = {\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(exampleBody, `Serializing body for example with id: ${exampleId}`);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.inputs, `Serializing inputs for example with id: ${exampleId}`);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.outputs, `Serializing outputs whle updating example with id: ${exampleId}`);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n            if (example.attachments_operations) {\n                const stringifiedAttachmentsOperations = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.attachments_operations, `Serializing attachments while updating example with id: ${exampleId}`);\n                const attachmentsOperationsBlob = new Blob([\n                    stringifiedAttachmentsOperations\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.attachments_operations`, attachmentsOperationsBlob);\n            }\n        }\n        const datasetIdToUse = datasetId ?? updates[0]?.dataset_id;\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetIdToUse}/examples`)}`, {\n                method: \"PATCH\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update examples\");\n            return res;\n        });\n        return response.json();\n    }\n    /**\n     * Upload examples with attachments using multipart form data.\n     * @param uploads List of ExampleUploadWithAttachments objects to upload\n     * @returns Promise with the upload response\n     * @deprecated This method is deprecated and will be removed in future LangSmith versions, please use `createExamples` instead\n     */ async uploadExamplesMultipart(datasetId, uploads = []) {\n        return this._uploadExamplesMultipart(datasetId, uploads);\n    }\n    async _uploadExamplesMultipart(datasetId, uploads = []) {\n        if (!await this._getDatasetExamplesMultiPartSupport()) {\n            throw new Error(\"Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.\");\n        }\n        const formData = new FormData();\n        for (const example of uploads){\n            const exampleId = (example.id ?? uuid__WEBPACK_IMPORTED_MODULE_12__[\"default\"]()).toString();\n            // Prepare the main example body\n            const exampleBody = {\n                created_at: example.created_at,\n                ...example.metadata && {\n                    metadata: example.metadata\n                },\n                ...example.split && {\n                    split: example.split\n                },\n                ...example.source_run_id && {\n                    source_run_id: example.source_run_id\n                },\n                ...example.use_source_run_io && {\n                    use_source_run_io: example.use_source_run_io\n                },\n                ...example.use_source_run_attachments && {\n                    use_source_run_attachments: example.use_source_run_attachments\n                }\n            };\n            // Add main example data\n            const stringifiedExample = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(exampleBody, `Serializing body for uploaded example with id: ${exampleId}`);\n            const exampleBlob = new Blob([\n                stringifiedExample\n            ], {\n                type: \"application/json\"\n            });\n            formData.append(exampleId, exampleBlob);\n            // Add inputs if present\n            if (example.inputs) {\n                const stringifiedInputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.inputs, `Serializing inputs for uploaded example with id: ${exampleId}`);\n                const inputsBlob = new Blob([\n                    stringifiedInputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.inputs`, inputsBlob);\n            }\n            // Add outputs if present\n            if (example.outputs) {\n                const stringifiedOutputs = (0,_utils_fast_safe_stringify_index_js__WEBPACK_IMPORTED_MODULE_11__.serialize)(example.outputs, `Serializing outputs for uploaded example with id: ${exampleId}`);\n                const outputsBlob = new Blob([\n                    stringifiedOutputs\n                ], {\n                    type: \"application/json\"\n                });\n                formData.append(`${exampleId}.outputs`, outputsBlob);\n            }\n            // Add attachments if present\n            if (example.attachments) {\n                for (const [name, attachment] of Object.entries(example.attachments)){\n                    let mimeType;\n                    let data;\n                    if (Array.isArray(attachment)) {\n                        [mimeType, data] = attachment;\n                    } else {\n                        mimeType = attachment.mimeType;\n                        data = attachment.data;\n                    }\n                    const attachmentBlob = new Blob([\n                        data\n                    ], {\n                        type: `${mimeType}; length=${data.byteLength}`\n                    });\n                    formData.append(`${exampleId}.attachment.${name}`, attachmentBlob);\n                }\n            }\n        }\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${datasetId}/examples`)}`, {\n                method: \"POST\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body: formData\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"upload examples\");\n            return res;\n        });\n        return response.json();\n    }\n    async updatePrompt(promptIdentifier, options) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"update a prompt\", owner);\n        }\n        const payload = {};\n        if (options?.description !== undefined) payload.description = options.description;\n        if (options?.readme !== undefined) payload.readme = options.readme;\n        if (options?.tags !== undefined) payload.tags = options.tags;\n        if (options?.isPublic !== undefined) payload.is_public = options.isPublic;\n        if (options?.isArchived !== undefined) payload.is_archived = options.isArchived;\n        // Check if payload is empty\n        if (Object.keys(payload).length === 0) {\n            throw new Error(\"No valid update options provided\");\n        }\n        const body = JSON.stringify(payload);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"PATCH\",\n                headers: {\n                    ...this.headers,\n                    \"Content-Type\": \"application/json\"\n                },\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions,\n                body\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"update prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async deletePrompt(promptIdentifier) {\n        if (!await this.promptExists(promptIdentifier)) {\n            throw new Error(\"Prompt does not exist, you must create it first.\");\n        }\n        const [owner, promptName, _] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        if (!await this._currentTenantIsOwner(owner)) {\n            throw await this._ownerConflictError(\"delete a prompt\", owner);\n        }\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/repos/${owner}/${promptName}`, {\n                method: \"DELETE\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"delete prompt\");\n            return res;\n        });\n        return response.json();\n    }\n    async pullPromptCommit(promptIdentifier, options) {\n        const [owner, promptName, commitHash] = (0,_utils_prompts_js__WEBPACK_IMPORTED_MODULE_8__.parsePromptIdentifier)(promptIdentifier);\n        const response = await this.caller.call(async ()=>{\n            const res = await this._fetch(`${this.apiUrl}/commits/${owner}/${promptName}/${commitHash}${options?.includeModel ? \"?include_model=true\" : \"\"}`, {\n                method: \"GET\",\n                headers: this.headers,\n                signal: AbortSignal.timeout(this.timeout_ms),\n                ...this.fetchOptions\n            });\n            await (0,_utils_error_js__WEBPACK_IMPORTED_MODULE_9__.raiseForStatus)(res, \"pull prompt commit\");\n            return res;\n        });\n        const result = await response.json();\n        return {\n            owner,\n            repo: promptName,\n            commit_hash: result.commit_hash,\n            manifest: result.manifest,\n            examples: result.examples\n        };\n    }\n    /**\n     * This method should not be used directly, use `import { pull } from \"langchain/hub\"` instead.\n     * Using this method directly returns the JSON string of the prompt rather than a LangChain object.\n     * @private\n     */ async _pullPrompt(promptIdentifier, options) {\n        const promptObject = await this.pullPromptCommit(promptIdentifier, {\n            includeModel: options?.includeModel\n        });\n        const prompt = JSON.stringify(promptObject.manifest);\n        return prompt;\n    }\n    async pushPrompt(promptIdentifier, options) {\n        // Create or update prompt metadata\n        if (await this.promptExists(promptIdentifier)) {\n            if (options && Object.keys(options).some((key)=>key !== \"object\")) {\n                await this.updatePrompt(promptIdentifier, {\n                    description: options?.description,\n                    readme: options?.readme,\n                    tags: options?.tags,\n                    isPublic: options?.isPublic\n                });\n            }\n        } else {\n            await this.createPrompt(promptIdentifier, {\n                description: options?.description,\n                readme: options?.readme,\n                tags: options?.tags,\n                isPublic: options?.isPublic\n            });\n        }\n        if (!options?.object) {\n            return await this._getPromptUrl(promptIdentifier);\n        }\n        // Create a commit with the new manifest\n        const url = await this.createCommit(promptIdentifier, options?.object, {\n            parentCommitHash: options?.parentCommitHash\n        });\n        return url;\n    }\n    /**\n     * Clone a public dataset to your own langsmith tenant.\n     * This operation is idempotent. If you already have a dataset with the given name,\n     * this function will do nothing.\n  \n     * @param {string} tokenOrUrl The token of the public dataset to clone.\n     * @param {Object} [options] Additional options for cloning the dataset.\n     * @param {string} [options.sourceApiUrl] The URL of the langsmith server where the data is hosted. Defaults to the API URL of your current client.\n     * @param {string} [options.datasetName] The name of the dataset to create in your tenant. Defaults to the name of the public dataset.\n     * @returns {Promise<void>}\n     */ async clonePublicDataset(tokenOrUrl, options = {}) {\n        const { sourceApiUrl = this.apiUrl, datasetName } = options;\n        const [parsedApiUrl, tokenUuid] = this.parseTokenOrUrl(tokenOrUrl, sourceApiUrl);\n        const sourceClient = new Client({\n            apiUrl: parsedApiUrl,\n            // Placeholder API key not needed anymore in most cases, but\n            // some private deployments may have API key-based rate limiting\n            // that would cause this to fail if we provide no value.\n            apiKey: \"placeholder\"\n        });\n        const ds = await sourceClient.readSharedDataset(tokenUuid);\n        const finalDatasetName = datasetName || ds.name;\n        try {\n            if (await this.hasDataset({\n                datasetId: finalDatasetName\n            })) {\n                console.log(`Dataset ${finalDatasetName} already exists in your tenant. Skipping.`);\n                return;\n            }\n        } catch (_) {\n        // `.hasDataset` will throw an error if the dataset does not exist.\n        // no-op in that case\n        }\n        // Fetch examples first, then create the dataset\n        const examples = await sourceClient.listSharedExamples(tokenUuid);\n        const dataset = await this.createDataset(finalDatasetName, {\n            description: ds.description,\n            dataType: ds.data_type || \"kv\",\n            inputsSchema: ds.inputs_schema_definition ?? undefined,\n            outputsSchema: ds.outputs_schema_definition ?? undefined\n        });\n        try {\n            await this.createExamples({\n                inputs: examples.map((e)=>e.inputs),\n                outputs: examples.flatMap((e)=>e.outputs ? [\n                        e.outputs\n                    ] : []),\n                datasetId: dataset.id\n            });\n        } catch (e) {\n            console.error(`An error occurred while creating dataset ${finalDatasetName}. ` + \"You should delete it manually.\");\n            throw e;\n        }\n    }\n    parseTokenOrUrl(urlOrToken, apiUrl, numParts = 2, kind = \"dataset\") {\n        // Try parsing as UUID\n        try {\n            (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_6__.assertUuid)(urlOrToken); // Will throw if it's not a UUID.\n            return [\n                apiUrl,\n                urlOrToken\n            ];\n        } catch (_) {\n        // no-op if it's not a uuid\n        }\n        // Parse as URL\n        try {\n            const parsedUrl = new URL(urlOrToken);\n            const pathParts = parsedUrl.pathname.split(\"/\").filter((part)=>part !== \"\");\n            if (pathParts.length >= numParts) {\n                const tokenUuid = pathParts[pathParts.length - numParts];\n                return [\n                    apiUrl,\n                    tokenUuid\n                ];\n            } else {\n                throw new Error(`Invalid public ${kind} URL: ${urlOrToken}`);\n            }\n        } catch (error) {\n            throw new Error(`Invalid public ${kind} URL or token: ${urlOrToken}`);\n        }\n    }\n    /**\n     * Awaits all pending trace batches. Useful for environments where\n     * you need to be sure that all tracing requests finish before execution ends,\n     * such as serverless environments.\n     *\n     * @example\n     * ```\n     * import { Client } from \"langsmith\";\n     *\n     * const client = new Client();\n     *\n     * try {\n     *   // Tracing happens here\n     *   ...\n     * } finally {\n     *   await client.awaitPendingTraceBatches();\n     * }\n     * ```\n     *\n     * @returns A promise that resolves once all currently pending traces have sent.\n     */ async awaitPendingTraceBatches() {\n        if (this.manualFlushMode) {\n            console.warn(\"[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches.\");\n            return Promise.resolve();\n        }\n        /**\n         * traceables use a backgrounded promise before updating runs to avoid blocking\n         * and to allow waiting for child runs to end. Waiting a small amount of time\n         * here ensures that they are able to enqueue their run operation before we await\n         * queued run operations below:\n         *\n         * ```ts\n         * const run = await traceable(async () => {\n         *   return \"Hello, world!\";\n         * }, { client })();\n         *\n         * await client.awaitPendingTraceBatches();\n         * ```\n         */ await new Promise((resolve)=>setTimeout(resolve, 1));\n        await Promise.all([\n            ...this.autoBatchQueue.items.map(({ itemPromise })=>itemPromise),\n            this.batchIngestCaller.queue.onIdle()\n        ]);\n        if (this.langSmithToOTELTranslator !== undefined) {\n            await (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOTLPTracerComponents)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush();\n        }\n    }\n}\nfunction isExampleCreate(input) {\n    return \"dataset_id\" in input || \"dataset_name\" in input;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2QjtBQUNrRDtBQUNzQjtBQUMvQztBQUNzQztBQUMwRTtBQUM3SDtBQUNLO0FBQ0g7QUFDZ0I7QUFDaUI7QUFDNEI7QUFDVDtBQUN4RixTQUFTd0IsdUJBQXVCQyxHQUFHLEVBQUVDLGFBQWEsRUFBRUMscUJBQXFCO0lBQzVFLElBQUlBLHVCQUF1QjtRQUN2QixPQUFPRjtJQUNYO0lBQ0EsTUFBTUcsYUFBYWpCLG9FQUFxQkE7SUFDeEMsTUFBTWtCLFVBQVVILGlCQUFpQmpCLDBFQUEyQkE7SUFDNUQsTUFBTXFCLFFBQVFMLElBQUlLLEtBQUssSUFBSSxDQUFDO0lBQzVCLE1BQU1DLFdBQVdELE1BQU1DLFFBQVE7SUFDL0JOLElBQUlLLEtBQUssR0FBRztRQUNSLEdBQUdBLEtBQUs7UUFDUkUsU0FBUztZQUNMLEdBQUdKLFVBQVU7WUFDYixHQUFHRSxPQUFPRSxPQUFPO1FBQ3JCO1FBQ0FELFVBQVU7WUFDTixHQUFHRixPQUFPO1lBQ1YsR0FBSUEsUUFBUUksV0FBVyxJQUFLLGlCQUFpQlIsT0FBT0EsSUFBSVEsV0FBVyxHQUM3RDtnQkFDRUEsYUFBYSxDQUFDLGlCQUFpQlIsTUFBTUEsSUFBSVEsV0FBVyxHQUFHQyxTQUFRLEtBQzNETCxRQUFRSSxXQUFXO1lBQzNCLElBQ0UsQ0FBQyxDQUFDO1lBQ1IsR0FBR0YsUUFBUTtRQUNmO0lBQ0o7SUFDQSxPQUFPTjtBQUNYO0FBQ0EsTUFBTVUseUJBQXlCLENBQUNDO0lBQzVCLE1BQU1DLGtCQUFrQkQsWUFBWUUsY0FDaEM1Qiw4RUFBK0JBLENBQUM7SUFDcEMsSUFBSTJCLG9CQUFvQkgsV0FBVztRQUMvQixPQUFPQTtJQUNYO0lBQ0EsTUFBTUssZUFBZUMsV0FBV0g7SUFDaEMsSUFBSUUsZUFBZSxLQUFLQSxlQUFlLEdBQUc7UUFDdEMsTUFBTSxJQUFJRSxNQUFNLENB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RCxTQUFTO1FBQ25ELE1BQU1ELFFBQVFnSyxHQUFHLENBQUM7ZUFDWCxJQUFJLENBQUN0RixjQUFjLENBQUNwRCxLQUFLLENBQUNvQixHQUFHLENBQUMsQ0FBQyxFQUFFbEIsV0FBVyxFQUFFLEdBQUtBO1lBQ3RELElBQUksQ0FBQzBDLGlCQUFpQixDQUFDc21CLEtBQUssQ0FBQ0MsTUFBTTtTQUN0QztRQUNELElBQUksSUFBSSxDQUFDemxCLHlCQUF5QixLQUFLN0csV0FBVztZQUM5QyxNQUFNaEMsbUZBQThCQSxJQUFJdXVCLGtDQUFrQ0M7UUFDOUU7SUFDSjtBQUNKO0FBQ0EsU0FBU2xOLGdCQUFnQndCLEtBQUs7SUFDMUIsT0FBTyxnQkFBZ0JBLFNBQVMsa0JBQWtCQTtBQUN0RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9jbGllbnQuanM/ZWQxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dWlkIGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yLCB9IGZyb20gXCIuL2V4cGVyaW1lbnRhbC9vdGVsL3RyYW5zbGF0b3IuanNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cywgZ2V0T1RFTFRyYWNlLCBnZXRPVEVMQ29udGV4dCwgfSBmcm9tIFwiLi9zaW5nbGV0b25zL290ZWwuanNcIjtcbmltcG9ydCB7IEFzeW5jQ2FsbGVyIH0gZnJvbSBcIi4vdXRpbHMvYXN5bmNfY2FsbGVyLmpzXCI7XG5pbXBvcnQgeyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSwgaXNMYW5nQ2hhaW5NZXNzYWdlLCB9IGZyb20gXCIuL3V0aWxzL21lc3NhZ2VzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIGdldFJ1bnRpbWVFbnZpcm9ubWVudCwgZ2V0T3RlbEVuYWJsZWQsIGdldEVudiwgfSBmcm9tIFwiLi91dGlscy9lbnYuanNcIjtcbmltcG9ydCB7IF9fdmVyc2lvbl9fIH0gZnJvbSBcIi4vaW5kZXguanNcIjtcbmltcG9ydCB7IGFzc2VydFV1aWQgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi91dGlscy93YXJuLmpzXCI7XG5pbXBvcnQgeyBwYXJzZVByb21wdElkZW50aWZpZXIgfSBmcm9tIFwiLi91dGlscy9wcm9tcHRzLmpzXCI7XG5pbXBvcnQgeyByYWlzZUZvclN0YXR1cywgaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yIH0gZnJvbSBcIi4vdXRpbHMvZXJyb3IuanNcIjtcbmltcG9ydCB7IF9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2gsIF9nZXRGZXRjaEltcGxlbWVudGF0aW9uLCB9IGZyb20gXCIuL3NpbmdsZXRvbnMvZmV0Y2guanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZSBhcyBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyB9IGZyb20gXCIuL3V0aWxzL2Zhc3Qtc2FmZS1zdHJpbmdpZnkvaW5kZXguanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJ1bnRpbWVFbnZJbnRvUnVuKHJ1biwgY2FjaGVkRW52VmFycywgb21pdFRyYWNlZFJ1bnRpbWVJbmZvKSB7XG4gICAgaWYgKG9taXRUcmFjZWRSdW50aW1lSW5mbykge1xuICAgICAgICByZXR1cm4gcnVuO1xuICAgIH1cbiAgICBjb25zdCBydW50aW1lRW52ID0gZ2V0UnVudGltZUVudmlyb25tZW50KCk7XG4gICAgY29uc3QgZW52VmFycyA9IGNhY2hlZEVudlZhcnMgPz8gZ2V0TGFuZ1NtaXRoRW52VmFyc01ldGFkYXRhKCk7XG4gICAgY29uc3QgZXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYS5tZXRhZGF0YTtcbiAgICBydW4uZXh0cmEgPSB7XG4gICAgICAgIC4uLmV4dHJhLFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgICAuLi5ydW50aW1lRW52LFxuICAgICAgICAgICAgLi4uZXh0cmE/LnJ1bnRpbWUsXG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAuLi5lbnZWYXJzLFxuICAgICAgICAgICAgLi4uKGVudlZhcnMucmV2aXNpb25faWQgfHwgKFwicmV2aXNpb25faWRcIiBpbiBydW4gJiYgcnVuLnJldmlzaW9uX2lkKVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICByZXZpc2lvbl9pZDogKFwicmV2aXNpb25faWRcIiBpbiBydW4gPyBydW4ucmV2aXNpb25faWQgOiB1bmRlZmluZWQpID8/XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZWYXJzLnJldmlzaW9uX2lkLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHJ1bjtcbn1cbmNvbnN0IGdldFRyYWNpbmdTYW1wbGluZ1JhdGUgPSAoY29uZmlnUmF0ZSkgPT4ge1xuICAgIGNvbnN0IHNhbXBsaW5nUmF0ZVN0ciA9IGNvbmZpZ1JhdGU/LnRvU3RyaW5nKCkgPz9cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlRSQUNJTkdfU0FNUExJTkdfUkFURVwiKTtcbiAgICBpZiAoc2FtcGxpbmdSYXRlU3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgc2FtcGxpbmdSYXRlID0gcGFyc2VGbG9hdChzYW1wbGluZ1JhdGVTdHIpO1xuICAgIGlmIChzYW1wbGluZ1JhdGUgPCAwIHx8IHNhbXBsaW5nUmF0ZSA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMQU5HU01JVEhfVFJBQ0lOR19TQU1QTElOR19SQVRFIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxIGlmIHNldC4gR290OiAke3NhbXBsaW5nUmF0ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbXBsaW5nUmF0ZTtcbn07XG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuY29uc3QgaXNMb2NhbGhvc3QgPSAodXJsKSA9PiB7XG4gICAgY29uc3Qgc3RyaXBwZWRVcmwgPSB1cmwucmVwbGFjZShcImh0dHA6Ly9cIiwgXCJcIikucmVwbGFjZShcImh0dHBzOi8vXCIsIFwiXCIpO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gc3RyaXBwZWRVcmwuc3BsaXQoXCIvXCIpWzBdLnNwbGl0KFwiOlwiKVswXTtcbiAgICByZXR1cm4gKGhvc3RuYW1lID09PSBcImxvY2FsaG9zdFwiIHx8IGhvc3RuYW1lID09PSBcIjEyNy4wLjAuMVwiIHx8IGhvc3RuYW1lID09PSBcIjo6MVwiKTtcbn07XG5hc3luYyBmdW5jdGlvbiB0b0FycmF5KGl0ZXJhYmxlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdHJpbVF1b3RlcyhzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9eXCIoLiopXCIkLywgXCIkMVwiKVxuICAgICAgICAucmVwbGFjZSgvXicoLiopJyQvLCBcIiQxXCIpO1xufVxuY29uc3QgaGFuZGxlNDI5ID0gYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xuICAgICAgICBjb25zdCByZXRyeUFmdGVyID0gcGFyc2VJbnQocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJyZXRyeS1hZnRlclwiKSA/PyBcIjEwXCIsIDEwKSAqIDEwMDA7XG4gICAgICAgIGlmIChyZXRyeUFmdGVyID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlBZnRlcikpO1xuICAgICAgICAgICAgLy8gUmV0dXJuIGRpcmVjdGx5IGFmdGVyIGNhbGxpbmcgdGhpcyBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRmFsbCBiYWNrIHRvIGV4aXN0aW5nIHN0YXR1cyBjaGVja3NcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZnVuY3Rpb24gX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpIHtcbiAgICBpZiAodHlwZW9mIHNjb3JlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIFRydW5jYXRlIGF0IDQgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgcmV0dXJuIE51bWJlcihzY29yZS50b0ZpeGVkKDQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3JlO1xufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVU5DT01QUkVTU0VEX0JBVENIX1NJWkVfTElNSVRfQllURVMgPSAyNCAqIDEwMjQgKiAxMDI0O1xuLyoqIERlZmF1bHQgbWF4aW11bSBtZW1vcnkgKDFHQikgZm9yIHF1ZXVlIHNpemUgbGltaXRzLiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX1NJWkVfQllURVMgPSAxMDI0ICogMTAyNCAqIDEwMjQ7IC8vIDFHQlxuY29uc3QgU0VSVkVSX0lORk9fUkVRVUVTVF9USU1FT1VUX01TID0gMTAwMDA7XG4vKiogTWF4aW11bSBudW1iZXIgb2Ygb3BlcmF0aW9ucyB0byBiYXRjaCBpbiBhIHNpbmdsZSByZXF1ZXN0LiAqL1xuY29uc3QgREVGQVVMVF9CQVRDSF9TSVpFX0xJTUlUID0gMTAwO1xuY29uc3QgREVGQVVMVF9BUElfVVJMID0gXCJodHRwczovL2FwaS5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG5leHBvcnQgY2xhc3MgQXV0b0JhdGNoUXVldWUge1xuICAgIGNvbnN0cnVjdG9yKG1heFNpemVCeXRlcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpemVCeXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4U2l6ZUJ5dGVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4U2l6ZUJ5dGVzID0gbWF4U2l6ZUJ5dGVzID8/IERFRkFVTFRfTUFYX1NJWkVfQllURVM7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zWzBdO1xuICAgIH1cbiAgICBwdXNoKGl0ZW0pIHtcbiAgICAgICAgbGV0IGl0ZW1Qcm9taXNlUmVzb2x2ZTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2V0dGluZyBpdGVtUHJvbWlzZVJlc29sdmUgaXMgc3luY2hyb25vdXMgd2l0aCBwcm9taXNlIGNyZWF0aW9uOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZS9Qcm9taXNlXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGl0ZW0uaXRlbSwgYFNlcmlhbGl6aW5nIHJ1biB3aXRoIGlkOiAke2l0ZW0uaXRlbS5pZH1gKS5sZW5ndGg7XG4gICAgICAgIC8vIENoZWNrIGlmIGFkZGluZyB0aGlzIGl0ZW0gd291bGQgZXhjZWVkIHRoZSBzaXplIGxpbWl0XG4gICAgICAgIC8vIEFsbG93IHRoZSBydW4gaWYgdGhlIHF1ZXVlIGlzIGVtcHR5ICh0byBzdXBwb3J0IGxhcmdlIHNpbmdsZSB0cmFjZXMpXG4gICAgICAgIGlmICh0aGlzLnNpemVCeXRlcyArIHNpemUgPiB0aGlzLm1heFNpemVCeXRlcyAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQXV0b0JhdGNoUXVldWUgc2l6ZSBsaW1pdCAoJHt0aGlzLm1heFNpemVCeXRlc30gYnl0ZXMpIGV4Y2VlZGVkLiBEcm9wcGluZyBydW4gd2l0aCBpZDogJHtpdGVtLml0ZW0uaWR9LiBgICtcbiAgICAgICAgICAgICAgICBgQ3VycmVudCBxdWV1ZSBzaXplOiAke3RoaXMuc2l6ZUJ5dGVzfSBieXRlcywgYXR0ZW1wdGVkIGFkZGl0aW9uOiAke3NpemV9IGJ5dGVzLmApO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSB0byBhdm9pZCBibG9ja2luZyBjYWxsZXJcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlUmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICBhY3Rpb246IGl0ZW0uYWN0aW9uLFxuICAgICAgICAgICAgcGF5bG9hZDogaXRlbS5pdGVtLFxuICAgICAgICAgICAgb3RlbENvbnRleHQ6IGl0ZW0ub3RlbENvbnRleHQsXG4gICAgICAgICAgICBhcGlLZXk6IGl0ZW0uYXBpS2V5LFxuICAgICAgICAgICAgYXBpVXJsOiBpdGVtLmFwaVVybCxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBpdGVtUHJvbWlzZVJlc29sdmU6IGl0ZW1Qcm9taXNlUmVzb2x2ZSxcbiAgICAgICAgICAgIGl0ZW1Qcm9taXNlLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2l6ZUJ5dGVzICs9IHNpemU7XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgcG9wKHsgdXBUb1NpemVCeXRlcywgdXBUb1NpemUsIH0pIHtcbiAgICAgICAgaWYgKHVwVG9TaXplQnl0ZXMgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgb2YgYnl0ZXMgdG8gcG9wIG9mZiBtYXkgbm90IGJlIGxlc3MgdGhhbiAxLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IHBvcHBlZFNpemVCeXRlcyA9IDA7XG4gICAgICAgIC8vIFBvcCBpdGVtcyB1bnRpbCB3ZSByZWFjaCBvciBleGNlZWQgdGhlIHNpemUgbGltaXRcbiAgICAgICAgd2hpbGUgKHBvcHBlZFNpemVCeXRlcyArICh0aGlzLnBlZWsoKT8uc2l6ZSA/PyAwKSA8IHVwVG9TaXplQnl0ZXMgJiZcbiAgICAgICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcG9wcGVkLmxlbmd0aCA8IHVwVG9TaXplKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBwb3BwZWRTaXplQnl0ZXMgKz0gaXRlbS5zaXplO1xuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZUJ5dGVzIC09IGl0ZW0uc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBpdGVtIG9uIHRoZSBxdWV1ZSB3ZSB3ZXJlIHVuYWJsZSB0byBwb3AsXG4gICAgICAgIC8vIGp1c3QgcmV0dXJuIGl0IGFzIGEgc2luZ2xlIGJhdGNoLlxuICAgICAgICBpZiAocG9wcGVkLmxlbmd0aCA9PT0gMCAmJiB0aGlzLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb3BwZWQucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHBvcHBlZFNpemVCeXRlcyArPSBpdGVtLnNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVCeXRlcyAtPSBpdGVtLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHBvcHBlZC5tYXAoKGl0KSA9PiAoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogaXQuYWN0aW9uLFxuICAgICAgICAgICAgICAgIGl0ZW06IGl0LnBheWxvYWQsXG4gICAgICAgICAgICAgICAgb3RlbENvbnRleHQ6IGl0Lm90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgIGFwaUtleTogaXQuYXBpS2V5LFxuICAgICAgICAgICAgICAgIGFwaVVybDogaXQuYXBpVXJsLFxuICAgICAgICAgICAgICAgIHNpemU6IGl0LnNpemUsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAoKSA9PiBwb3BwZWQuZm9yRWFjaCgoaXQpID0+IGl0Lml0ZW1Qcm9taXNlUmVzb2x2ZSgpKSxcbiAgICAgICAgXTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2xpZW50IHtcbiAgICBnZXQgX2ZldGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uIHx8IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uKHRoaXMuZGVidWcpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcGlLZXlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXBpVXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndlYlVybFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3b3Jrc3BhY2VJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hJbmdlc3RDYWxsZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGltZW91dF9tc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGVuYW50SWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhpZGVJbnB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGlkZU91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwib21pdFRyYWNlZFJ1bnRpbWVJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYWNpbmdTYW1wbGVSYXRlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZpbHRlcmVkUG9zdFV1aWRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRyYWNpbmdcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFF1ZXVlXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF1dG9CYXRjaFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYXV0b0JhdGNoQWdncmVnYXRpb25EZWxheU1zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAyNTBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJhdGNoU2l6ZUJ5dGVzTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYmF0Y2hTaXplTGltaXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmV0Y2hPcHRpb25zXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldHRpbmdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBnZXRFbnZpcm9ubWVudFZhcmlhYmxlKFwiTEFOR1NNSVRIX1RSQUNJTkdfQkFDS0dST1VORFwiKSA9PT0gXCJmYWxzZVwiXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZUJhdGNoQ29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IDVcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9zZXJ2ZXJJbmZvXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYW51YWxGbHVzaE1vZGVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsYW5nU21pdGhUb09URUxUcmFuc2xhdG9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImZldGNoSW1wbGVtZW50YXRpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbXVsdGlwYXJ0RGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdTTUlUSF9ERUJVR1wiKSA9PT0gXCJ0cnVlXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRDb25maWcgPSBDbGllbnQuZ2V0RGVmYXVsdENsaWVudENvbmZpZygpO1xuICAgICAgICB0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID0gZ2V0VHJhY2luZ1NhbXBsaW5nUmF0ZShjb25maWcudHJhY2luZ1NhbXBsaW5nUmF0ZSk7XG4gICAgICAgIHRoaXMuYXBpVXJsID0gdHJpbVF1b3Rlcyhjb25maWcuYXBpVXJsID8/IGRlZmF1bHRDb25maWcuYXBpVXJsKSA/PyBcIlwiO1xuICAgICAgICBpZiAodGhpcy5hcGlVcmwuZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICB0aGlzLmFwaVVybCA9IHRoaXMuYXBpVXJsLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFwaUtleSA9IHRyaW1RdW90ZXMoY29uZmlnLmFwaUtleSA/PyBkZWZhdWx0Q29uZmlnLmFwaUtleSk7XG4gICAgICAgIHRoaXMud2ViVXJsID0gdHJpbVF1b3Rlcyhjb25maWcud2ViVXJsID8/IGRlZmF1bHRDb25maWcud2ViVXJsKTtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsPy5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gdGhpcy53ZWJVcmwuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud29ya3NwYWNlSWQgPSB0cmltUXVvdGVzKGNvbmZpZy53b3Jrc3BhY2VJZCA/PyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiV09SS1NQQUNFX0lEXCIpKTtcbiAgICAgICAgdGhpcy50aW1lb3V0X21zID0gY29uZmlnLnRpbWVvdXRfbXMgPz8gOTBfMDAwO1xuICAgICAgICB0aGlzLmNhbGxlciA9IG5ldyBBc3luY0NhbGxlcih7XG4gICAgICAgICAgICAuLi4oY29uZmlnLmNhbGxlck9wdGlvbnMgPz8ge30pLFxuICAgICAgICAgICAgbWF4UmV0cmllczogNCxcbiAgICAgICAgICAgIGRlYnVnOiBjb25maWcuZGVidWcgPz8gdGhpcy5kZWJ1ZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhY2VCYXRjaENvbmN1cnJlbmN5ID1cbiAgICAgICAgICAgIGNvbmZpZy50cmFjZUJhdGNoQ29uY3VycmVuY3kgPz8gdGhpcy50cmFjZUJhdGNoQ29uY3VycmVuY3k7XG4gICAgICAgIGlmICh0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSA8IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYWNlIGJhdGNoIGNvbmN1cnJlbmN5IG11c3QgYmUgcG9zaXRpdmUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcgPSBjb25maWcuZGVidWcgPz8gdGhpcy5kZWJ1ZztcbiAgICAgICAgdGhpcy5mZXRjaEltcGxlbWVudGF0aW9uID0gY29uZmlnLmZldGNoSW1wbGVtZW50YXRpb247XG4gICAgICAgIC8vIFVzZSBtYXhJbmdlc3RNZW1vcnlCeXRlcyBmb3IgYm90aCBxdWV1ZXNcbiAgICAgICAgY29uc3QgbWF4TWVtb3J5ID0gY29uZmlnLm1heEluZ2VzdE1lbW9yeUJ5dGVzID8/IERFRkFVTFRfTUFYX1NJWkVfQllURVM7XG4gICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIgPSBuZXcgQXN5bmNDYWxsZXIoe1xuICAgICAgICAgICAgbWF4UmV0cmllczogNCxcbiAgICAgICAgICAgIG1heENvbmN1cnJlbmN5OiB0aGlzLnRyYWNlQmF0Y2hDb25jdXJyZW5jeSxcbiAgICAgICAgICAgIG1heFF1ZXVlU2l6ZUJ5dGVzOiBtYXhNZW1vcnksXG4gICAgICAgICAgICAuLi4oY29uZmlnLmNhbGxlck9wdGlvbnMgPz8ge30pLFxuICAgICAgICAgICAgb25GYWlsZWRSZXNwb25zZUhvb2s6IGhhbmRsZTQyOSxcbiAgICAgICAgICAgIGRlYnVnOiBjb25maWcuZGVidWcgPz8gdGhpcy5kZWJ1ZyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlkZUlucHV0cyA9XG4gICAgICAgICAgICBjb25maWcuaGlkZUlucHV0cyA/PyBjb25maWcuYW5vbnltaXplciA/PyBkZWZhdWx0Q29uZmlnLmhpZGVJbnB1dHM7XG4gICAgICAgIHRoaXMuaGlkZU91dHB1dHMgPVxuICAgICAgICAgICAgY29uZmlnLmhpZGVPdXRwdXRzID8/IGNvbmZpZy5hbm9ueW1pemVyID8/IGRlZmF1bHRDb25maWcuaGlkZU91dHB1dHM7XG4gICAgICAgIHRoaXMub21pdFRyYWNlZFJ1bnRpbWVJbmZvID0gY29uZmlnLm9taXRUcmFjZWRSdW50aW1lSW5mbyA/PyBmYWxzZTtcbiAgICAgICAgdGhpcy5hdXRvQmF0Y2hUcmFjaW5nID0gY29uZmlnLmF1dG9CYXRjaFRyYWNpbmcgPz8gdGhpcy5hdXRvQmF0Y2hUcmFjaW5nO1xuICAgICAgICB0aGlzLmF1dG9CYXRjaFF1ZXVlID0gbmV3IEF1dG9CYXRjaFF1ZXVlKG1heE1lbW9yeSk7XG4gICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gPVxuICAgICAgICAgICAgY29uZmlnLmJsb2NrT25Sb290UnVuRmluYWxpemF0aW9uID8/IHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb247XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA9IGNvbmZpZy5iYXRjaFNpemVCeXRlc0xpbWl0O1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUxpbWl0ID0gY29uZmlnLmJhdGNoU2l6ZUxpbWl0O1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IGNvbmZpZy5mZXRjaE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMubWFudWFsRmx1c2hNb2RlID0gY29uZmlnLm1hbnVhbEZsdXNoTW9kZSA/PyB0aGlzLm1hbnVhbEZsdXNoTW9kZTtcbiAgICAgICAgaWYgKGdldE90ZWxFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciA9IG5ldyBMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FjaGUgbWV0YWRhdGEgZW52IHZhcnMgb25jZSBkdXJpbmcgY29uc3RydWN0aW9uIHRvIGF2b2lkIHJlcGVhdGVkbHkgc2Nhbm5pbmcgcHJvY2Vzcy5lbnZcbiAgICAgICAgdGhpcy5jYWNoZWRMU0VudlZhcnNGb3JNZXRhZGF0YSA9IGdldExhbmdTbWl0aEVudlZhcnNNZXRhZGF0YSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENsaWVudENvbmZpZygpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIkFQSV9LRVlcIik7XG4gICAgICAgIGNvbnN0IGFwaVVybCA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJFTkRQT0lOVFwiKSA/PyBERUZBVUxUX0FQSV9VUkw7XG4gICAgICAgIGNvbnN0IGhpZGVJbnB1dHMgPSBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiSElERV9JTlBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICBjb25zdCBoaWRlT3V0cHV0cyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJISURFX09VVFBVVFNcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXBpVXJsOiBhcGlVcmwsXG4gICAgICAgICAgICBhcGlLZXk6IGFwaUtleSxcbiAgICAgICAgICAgIHdlYlVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGlkZUlucHV0czogaGlkZUlucHV0cyxcbiAgICAgICAgICAgIGhpZGVPdXRwdXRzOiBoaWRlT3V0cHV0cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0SG9zdFVybCgpIHtcbiAgICAgICAgaWYgKHRoaXMud2ViVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNMb2NhbGhvc3QodGhpcy5hcGlVcmwpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cDovL2xvY2FsaG9zdDozMDAwXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuZW5kc1dpdGgoXCIvYXBpL3YxXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IHRoaXMuYXBpVXJsLnJlcGxhY2UoXCIvYXBpL3YxXCIsIFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2ViVXJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXBpVXJsLmluY2x1ZGVzKFwiL2FwaVwiKSAmJlxuICAgICAgICAgICAgIXRoaXMuYXBpVXJsLnNwbGl0KFwiLlwiLCAxKVswXS5lbmRzV2l0aChcImFwaVwiKSkge1xuICAgICAgICAgICAgdGhpcy53ZWJVcmwgPSB0aGlzLmFwaVVybC5yZXBsYWNlKFwiL2FwaVwiLCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJkZXZcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2Rldi5zbWl0aC5sYW5nY2hhaW4uY29tXCI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53ZWJVcmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hcGlVcmwuc3BsaXQoXCIuXCIsIDEpWzBdLmluY2x1ZGVzKFwiZXVcIikpIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL2V1LnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwaVVybC5zcGxpdChcIi5cIiwgMSlbMF0uaW5jbHVkZXMoXCJiZXRhXCIpKSB7XG4gICAgICAgICAgICB0aGlzLndlYlVybCA9IFwiaHR0cHM6Ly9iZXRhLnNtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2ViVXJsID0gXCJodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb21cIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndlYlVybDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIFwiVXNlci1BZ2VudFwiOiBgbGFuZ3NtaXRoLWpzLyR7X192ZXJzaW9uX199YCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gYCR7dGhpcy5hcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy53b3Jrc3BhY2VJZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtdGVuYW50LWlkXCJdID0gdGhpcy53b3Jrc3BhY2VJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgX2dldFBsYXRmb3JtRW5kcG9pbnRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgYXBpVXJsIGFscmVhZHkgZW5kcyB3aXRoIC92MSBvciAvdjEvIHRvIGF2b2lkIGRvdWJsZSAvdjEvdjEvIHBhdGhzXG4gICAgICAgIGNvbnN0IG5lZWRzVjFQcmVmaXggPSB0aGlzLmFwaVVybC5zbGljZSgtMykgIT09IFwiL3YxXCIgJiYgdGhpcy5hcGlVcmwuc2xpY2UoLTQpICE9PSBcIi92MS9cIjtcbiAgICAgICAgcmV0dXJuIG5lZWRzVjFQcmVmaXggPyBgL3YxL3BsYXRmb3JtLyR7cGF0aH1gIDogYC9wbGF0Zm9ybS8ke3BhdGh9YDtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0lucHV0cyhpbnB1dHMpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZUlucHV0cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5oaWRlSW5wdXRzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVJbnB1dHMoaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzT3V0cHV0cyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPdXRwdXRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlkZU91dHB1dHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaGlkZU91dHB1dHMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU91dHB1dHMob3V0cHV0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyhydW4pIHtcbiAgICAgICAgY29uc3QgcnVuUGFyYW1zID0geyAuLi5ydW4gfTtcbiAgICAgICAgaWYgKHJ1blBhcmFtcy5pbnB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLmlucHV0cyA9IGF3YWl0IHRoaXMucHJvY2Vzc0lucHV0cyhydW5QYXJhbXMuaW5wdXRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuUGFyYW1zLm91dHB1dHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcnVuUGFyYW1zLm91dHB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1blBhcmFtcy5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVuUGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0UmVzcG9uc2UocGF0aCwgcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcXVlcnlQYXJhbXM/LnRvU3RyaW5nKCkgPz8gXCJcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc1N0cmluZ31gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldChwYXRoLCBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldFJlc3BvbnNlKHBhdGgsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgKl9nZXRQYWdpbmF0ZWQocGF0aCwgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIHRyYW5zZm9ybSkge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gTnVtYmVyKHF1ZXJ5UGFyYW1zLmdldChcIm9mZnNldFwiKSkgfHwgMDtcbiAgICAgICAgY29uc3QgbGltaXQgPSBOdW1iZXIocXVlcnlQYXJhbXMuZ2V0KFwibGltaXRcIikpIHx8IDEwMDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldChcIm9mZnNldFwiLCBTdHJpbmcob2Zmc2V0KSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoXCJsaW1pdFwiLCBTdHJpbmcobGltaXQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfSR7cGF0aH0/JHtxdWVyeVBhcmFtc31gO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBmZXRjaCAke3BhdGh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybShhd2FpdCByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBpdGVtcztcbiAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyAqX2dldEN1cnNvclBhZ2luYXRlZExpc3QocGF0aCwgYm9keSA9IG51bGwsIHJlcXVlc3RNZXRob2QgPSBcIlBPU1RcIiwgZGF0YUtleSA9IFwicnVuc1wiKSB7XG4gICAgICAgIGNvbnN0IGJvZHlQYXJhbXMgPSBib2R5ID8geyAuLi5ib2R5IH0gOiB7fTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5UGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHtwYXRofWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0TWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGZldGNoICR7cGF0aH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlQm9keSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUJvZHlbZGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHJlc3BvbnNlQm9keVtkYXRhS2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvcnMgPSByZXNwb25zZUJvZHkuY3Vyc29ycztcbiAgICAgICAgICAgIGlmICghY3Vyc29ycykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJzb3JzLm5leHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHlQYXJhbXMuY3Vyc29yID0gY3Vyc29ycy5uZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFsbG93cyBtb2NraW5nIGZvciB0ZXN0c1xuICAgIF9zaG91bGRTYW1wbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYWNpbmdTYW1wbGVSYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpIDwgdGhpcy50cmFjaW5nU2FtcGxlUmF0ZTtcbiAgICB9XG4gICAgX2ZpbHRlckZvclNhbXBsaW5nKHJ1bnMsIHBhdGNoID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2luZ1NhbXBsZVJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJ1bnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1biBvZiBydW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmhhcyhydW4udHJhY2VfaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChydW4uaWQgPT09IHJ1bi50cmFjZV9pZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkUG9zdFV1aWRzLmRlbGV0ZShydW4udHJhY2VfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9yIG5ldyBydW5zLCBzYW1wbGUgYXQgdHJhY2UgbGV2ZWwgdG8gbWFpbnRhaW4gY29uc2lzdGVuY3lcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZWQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuIG9mIHJ1bnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZUlkID0gcnVuLnRyYWNlX2lkID8/IHJ1bi5pZDtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IG1hZGUgYSBkZWNpc2lvbiBhYm91dCB0aGlzIHRyYWNlLCBmb2xsb3cgaXRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXJlZFBvc3RVdWlkcy5oYXModHJhY2VJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBuZXcgdHJhY2VzLCBhcHBseSBzYW1wbGluZ1xuICAgICAgICAgICAgICAgIGlmIChydW4uaWQgPT09IHRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNhbXBsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVkLnB1c2gocnVuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRQb3N0VXVpZHMuYWRkKHRyYWNlSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGlsZCBydW5zIGZvbGxvdyB0aGVpciB0cmFjZSdzIHNhbXBsaW5nIGRlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZWQucHVzaChydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzYW1wbGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCkge1xuICAgICAgICBjb25zdCBzZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZW5zdXJlU2VydmVySW5mbygpO1xuICAgICAgICByZXR1cm4gKHRoaXMuYmF0Y2hTaXplQnl0ZXNMaW1pdCA/P1xuICAgICAgICAgICAgc2VydmVySW5mbz8uYmF0Y2hfaW5nZXN0X2NvbmZpZz8uc2l6ZV9saW1pdF9ieXRlcyA/P1xuICAgICAgICAgICAgREVGQVVMVF9VTkNPTVBSRVNTRURfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygb3BlcmF0aW9ucyB0byBiYXRjaCBpbiBhIHNpbmdsZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRCYXRjaFNpemVMaW1pdCgpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJhdGNoU2l6ZUxpbWl0ID8/XG4gICAgICAgICAgICBzZXJ2ZXJJbmZvPy5iYXRjaF9pbmdlc3RfY29uZmlnPy5zaXplX2xpbWl0ID8/XG4gICAgICAgICAgICBERUZBVUxUX0JBVENIX1NJWkVfTElNSVQpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0RGF0YXNldEV4YW1wbGVzTXVsdGlQYXJ0U3VwcG9ydCgpIHtcbiAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgcmV0dXJuIChzZXJ2ZXJJbmZvLmluc3RhbmNlX2ZsYWdzPy5kYXRhc2V0X2V4YW1wbGVzX211bHRpcGFydF9lbmFibGVkID8/IGZhbHNlKTtcbiAgICB9XG4gICAgZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7IGJhdGNoU2l6ZUxpbWl0Qnl0ZXMsIGJhdGNoU2l6ZUxpbWl0LCB9KSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IFtiYXRjaCwgZG9uZV0gPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnBvcCh7XG4gICAgICAgICAgICAgICAgdXBUb1NpemVCeXRlczogYmF0Y2hTaXplTGltaXRCeXRlcyxcbiAgICAgICAgICAgICAgICB1cFRvU2l6ZTogYmF0Y2hTaXplTGltaXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYmF0Y2gubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmF0Y2hlc0J5RGVzdGluYXRpb24gPSBiYXRjaC5yZWR1Y2UoKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaVVybCA9IGl0ZW0uYXBpVXJsID8/IHRoaXMuYXBpVXJsO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwaUtleSA9IGl0ZW0uYXBpS2V5ID8/IHRoaXMuYXBpS2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9IGl0ZW0uYXBpS2V5ID09PSB0aGlzLmFwaUtleSAmJiBpdGVtLmFwaVVybCA9PT0gdGhpcy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hLZXkgPSBpc0RlZmF1bHQgPyBcImRlZmF1bHRcIiA6IGAke2FwaVVybH18JHthcGlLZXl9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY1tiYXRjaEtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjW2JhdGNoS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NbYmF0Y2hLZXldLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGJhdGNoUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoS2V5LCBiYXRjaF0gb2YgT2JqZWN0LmVudHJpZXMoYmF0Y2hlc0J5RGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmF0Y2hQcm9taXNlID0gdGhpcy5fcHJvY2Vzc0JhdGNoKGJhdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVVybDogYmF0Y2hLZXkgPT09IFwiZGVmYXVsdFwiID8gdW5kZWZpbmVkIDogYmF0Y2hLZXkuc3BsaXQoXCJ8XCIpWzBdLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IGJhdGNoS2V5ID09PSBcImRlZmF1bHRcIiA/IHVuZGVmaW5lZCA6IGJhdGNoS2V5LnNwbGl0KFwifFwiKVsxXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBiYXRjaFByb21pc2VzLnB1c2goYmF0Y2hQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFsbCBiYXRjaGVzIHRvIGNvbXBsZXRlLCB0aGVuIGNhbGwgdGhlIG92ZXJhbGwgZG9uZSBjYWxsYmFja1xuICAgICAgICAgICAgY29uc3QgYWxsQmF0Y2hlc1Byb21pc2UgPSBQcm9taXNlLmFsbChiYXRjaFByb21pc2VzKS5maW5hbGx5KGRvbmUpO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChhbGxCYXRjaGVzUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgYXN5bmMgX3Byb2Nlc3NCYXRjaChiYXRjaCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWJhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0b3RhbCBiYXRjaCBzaXplIGZvciBxdWV1ZSB0cmFja2luZ1xuICAgICAgICBjb25zdCBiYXRjaFNpemVCeXRlcyA9IGJhdGNoLnJlZHVjZSgoc3VtLCBpdGVtKSA9PiBzdW0gKyAoaXRlbS5zaXplID8/IDApLCAwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRCYXRjaFRvT1RFTFRyYW5zbGF0b3IoYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5nZXN0UGFyYW1zID0ge1xuICAgICAgICAgICAgICAgICAgICBydW5DcmVhdGVzOiBiYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwiY3JlYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pLFxuICAgICAgICAgICAgICAgICAgICBydW5VcGRhdGVzOiBiYXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5hY3Rpb24gPT09IFwidXBkYXRlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VydmVySW5mbyA9IGF3YWl0IHRoaXMuX2Vuc3VyZVNlcnZlckluZm8oKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1c2VNdWx0aXBhcnQgPSAhdGhpcy5fbXVsdGlwYXJ0RGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNlcnZlckluZm8/LmJhdGNoX2luZ2VzdF9jb25maWc/LnVzZV9tdWx0aXBhcnRfZW5kcG9pbnQgPz8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHVzZU11bHRpcGFydCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VHemlwID0gc2VydmVySW5mbz8uaW5zdGFuY2VfZmxhZ3M/Lmd6aXBfYm9keV9lbmFibGVkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5tdWx0aXBhcnRJbmdlc3RSdW5zKGluZ2VzdFBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlR3ppcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplQnl0ZXM6IGJhdGNoU2l6ZUJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYmF0Y2ggaW5nZXN0IGlmIG11bHRpcGFydCBlbmRwb2ludCByZXR1cm5zIDQwNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgbXVsdGlwYXJ0IGZvciBmdXR1cmUgcmVxdWVzdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBhcnREaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdFJ1bnMoaW5nZXN0UGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemVCeXRlczogYmF0Y2hTaXplQnl0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmJhdGNoSW5nZXN0UnVucyhpbmdlc3RQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplQnl0ZXM6IGJhdGNoU2l6ZUJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBleHBvcnRpbmcgYmF0Y2g6XCIsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZW5kQmF0Y2hUb09URUxUcmFuc2xhdG9yKGJhdGNoKSB7XG4gICAgICAgIGlmICh0aGlzLmxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgb3RlbENvbnRleHRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYmF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtLmlkICYmIGl0ZW0ub3RlbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RlbENvbnRleHRNYXAuc2V0KGl0ZW0uaXRlbS5pZCwgaXRlbS5vdGVsQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gXCJjcmVhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9zdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpdGVtLml0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VfaWQ6IGl0ZW0uaXRlbS50cmFjZV9pZCA/PyBpdGVtLml0ZW0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuOiBpdGVtLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInBhdGNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogaXRlbS5pdGVtLnRyYWNlX2lkID8/IGl0ZW0uaXRlbS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW46IGl0ZW0uaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yLmV4cG9ydEJhdGNoKG9wZXJhdGlvbnMsIG90ZWxDb250ZXh0TWFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwcm9jZXNzUnVuT3BlcmF0aW9uKGl0ZW0pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0JhdGNoVGltZW91dCk7XG4gICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaXRlbS5pdGVtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bihpdGVtLml0ZW0sIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEsIHRoaXMub21pdFRyYWNlZFJ1bnRpbWVJbmZvKTtcbiAgICAgICAgY29uc3QgaXRlbVByb21pc2UgPSB0aGlzLmF1dG9CYXRjaFF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgLy8gUmVseSBvbiBtYW51YWwgZmx1c2hpbmcgaW4gc2VydmVybGVzcyBlbnZpcm9ubWVudHNcbiAgICAgICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplTGltaXRCeXRlcyA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0Qnl0ZXMoKTtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0ID0gYXdhaXQgdGhpcy5fZ2V0QmF0Y2hTaXplTGltaXQoKTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoUXVldWUuc2l6ZUJ5dGVzID4gc2l6ZUxpbWl0Qnl0ZXMgfHxcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubGVuZ3RoID4gc2l6ZUxpbWl0KSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplTGltaXRCeXRlczogc2l6ZUxpbWl0Qnl0ZXMsXG4gICAgICAgICAgICAgICAgYmF0Y2hTaXplTGltaXQ6IHNpemVMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dG9CYXRjaFF1ZXVlLml0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYXV0b0JhdGNoVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2b2lkIHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0Qnl0ZXM6IHNpemVMaW1pdEJ5dGVzLFxuICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemVMaW1pdDogc2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcy5hdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtUHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFNlcnZlckluZm8oKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vaW5mb2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KFNFUlZFUl9JTkZPX1JFUVVFU1RfVElNRU9VVF9NUyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgc2VydmVyIGluZm9cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFxuPT09IExhbmdTbWl0aCBTZXJ2ZXIgQ29uZmlndXJhdGlvbiA9PT1cXG5cIiArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoanNvbiwgbnVsbCwgMikgK1xuICAgICAgICAgICAgICAgIFwiXFxuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBhc3luYyBfZW5zdXJlU2VydmVySW5mbygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dldFNlcnZlckluZm9Qcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXJ2ZXJJbmZvID0gYXdhaXQgdGhpcy5fZ2V0U2VydmVySW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtMQU5HU01JVEhdOiBGYWlsZWQgdG8gZmV0Y2ggaW5mbyBvbiBzdXBwb3J0ZWQgb3BlcmF0aW9ucy4gRmFsbGluZyBiYWNrIHRvIGJhdGNoIG9wZXJhdGlvbnMgYW5kIGRlZmF1bHQgbGltaXRzLiBJbmZvOiAke2Uuc3RhdHVzID8/IFwiVW5zcGVjaWZpZWQgc3RhdHVzIGNvZGVcIn0gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlckluZm8gPz8ge307XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZS50aGVuKChzZXJ2ZXJJbmZvKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2VydmVySW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0U2VydmVySW5mb1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VydmVySW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gdGhpcy5fZ2V0KFwiL3NldHRpbmdzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNldHRpbmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGN1cnJlbnQgcXVldWVkIHRyYWNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZUxpbWl0Qnl0ZXMgPSBhd2FpdCB0aGlzLl9nZXRCYXRjaFNpemVMaW1pdEJ5dGVzKCk7XG4gICAgICAgIGNvbnN0IHNpemVMaW1pdCA9IGF3YWl0IHRoaXMuX2dldEJhdGNoU2l6ZUxpbWl0KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuZHJhaW5BdXRvQmF0Y2hRdWV1ZSh7XG4gICAgICAgICAgICBiYXRjaFNpemVMaW1pdEJ5dGVzOiBzaXplTGltaXRCeXRlcyxcbiAgICAgICAgICAgIGJhdGNoU2l6ZUxpbWl0OiBzaXplTGltaXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2xvbmVDdXJyZW50T1RFTENvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IG90ZWxfdHJhY2UgPSBnZXRPVEVMVHJhY2UoKTtcbiAgICAgICAgY29uc3Qgb3RlbF9jb250ZXh0ID0gZ2V0T1RFTENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubGFuZ1NtaXRoVG9PVEVMVHJhbnNsYXRvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3BhbiA9IG90ZWxfdHJhY2UuZ2V0QWN0aXZlU3BhbigpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTcGFuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG90ZWxfdHJhY2Uuc2V0U3BhbihvdGVsX2NvbnRleHQuYWN0aXZlKCksIGN1cnJlbnRTcGFuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSdW4ocnVuLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlsdGVyRm9yU2FtcGxpbmcoW3J1bl0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbl9uYW1lID0gcnVuLnByb2plY3RfbmFtZTtcbiAgICAgICAgZGVsZXRlIHJ1bi5wcm9qZWN0X25hbWU7XG4gICAgICAgIGNvbnN0IHJ1bkNyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHtcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgIC4uLnJ1bixcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHJ1bi5zdGFydF90aW1lID8/IERhdGUubm93KCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvQmF0Y2hUcmFjaW5nICYmXG4gICAgICAgICAgICBydW5DcmVhdGUudHJhY2VfaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcnVuQ3JlYXRlLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICB2b2lkIHRoaXMucHJvY2Vzc1J1bk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcImNyZWF0ZVwiLFxuICAgICAgICAgICAgICAgIGl0ZW06IHJ1bkNyZWF0ZSxcbiAgICAgICAgICAgICAgICBvdGVsQ29udGV4dCxcbiAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICBhcGlVcmw6IG9wdGlvbnM/LmFwaVVybCxcbiAgICAgICAgICAgIH0pLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lcmdlZFJ1bkNyZWF0ZVBhcmFtID0gbWVyZ2VSdW50aW1lRW52SW50b1J1bihydW5DcmVhdGUsIHRoaXMuY2FjaGVkTFNFbnZWYXJzRm9yTWV0YWRhdGEsIHRoaXMub21pdFRyYWNlZFJ1bnRpbWVJbmZvKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnM/LndvcmtzcGFjZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LXRlbmFudC1pZFwiXSA9IG9wdGlvbnMud29ya3NwYWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKG1lcmdlZFJ1bkNyZWF0ZVBhcmFtLCBgQ3JlYXRpbmcgcnVuIHdpdGggaWQ6ICR7bWVyZ2VkUnVuQ3JlYXRlUGFyYW0uaWR9YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiY3JlYXRlIHJ1blwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXRjaCBpbmdlc3QvdXBzZXJ0IG11bHRpcGxlIHJ1bnMgaW4gdGhlIExhbmdzbWl0aCBzeXN0ZW0uXG4gICAgICogQHBhcmFtIHJ1bnNcbiAgICAgKi9cbiAgICBhc3luYyBiYXRjaEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByZXBhcmVkQ3JlYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuQ3JlYXRlcz8ubWFwKChjcmVhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSkpID8/IFtdKTtcbiAgICAgICAgbGV0IHByZXBhcmVkVXBkYXRlUGFyYW1zID0gYXdhaXQgUHJvbWlzZS5hbGwocnVuVXBkYXRlcz8ubWFwKCh1cGRhdGUpID0+IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpID8/IFtdKTtcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhd0JhdGNoID0ge1xuICAgICAgICAgICAgcG9zdDogcHJlcGFyZWRDcmVhdGVQYXJhbXMsXG4gICAgICAgICAgICBwYXRjaDogcHJlcGFyZWRVcGRhdGVQYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmF3QmF0Y2gucG9zdC5sZW5ndGggJiYgIXJhd0JhdGNoLnBhdGNoLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhdGNoQ2h1bmtzID0ge1xuICAgICAgICAgICAgcG9zdDogW10sXG4gICAgICAgICAgICBwYXRjaDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBbXCJwb3N0XCIsIFwicGF0Y2hcIl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgICAgICBjb25zdCBiYXRjaEl0ZW1zID0gcmF3QmF0Y2hba2V5XS5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsZXQgYmF0Y2hJdGVtID0gYmF0Y2hJdGVtcy5wb3AoKTtcbiAgICAgICAgICAgIHdoaWxlIChiYXRjaEl0ZW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFR5cGUgaXMgd3JvbmcgYnV0IHRoaXMgaXMgYSBkZXByZWNhdGVkIGNvZGUgcGF0aCBhbnl3YXlcbiAgICAgICAgICAgICAgICBiYXRjaENodW5rc1trZXldLnB1c2goYmF0Y2hJdGVtKTtcbiAgICAgICAgICAgICAgICBiYXRjaEl0ZW0gPSBiYXRjaEl0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaENodW5rcy5wb3N0Lmxlbmd0aCA+IDAgfHwgYmF0Y2hDaHVua3MucGF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcnVuSWRzID0gYmF0Y2hDaHVua3MucG9zdFxuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpXG4gICAgICAgICAgICAgICAgLmNvbmNhdChiYXRjaENodW5rcy5wYXRjaC5tYXAoKGl0ZW0pID0+IGl0ZW0uaWQpKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3Bvc3RCYXRjaEluZ2VzdFJ1bnMoc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcoYmF0Y2hDaHVua3MsIGBJbmdlc3RpbmcgcnVucyB3aXRoIGlkczogJHtydW5JZHN9YCksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9wb3N0QmF0Y2hJbmdlc3RSdW5zKGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wieC1hcGkta2V5XCJdID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5iYXRjaEluZ2VzdENhbGxlci5jYWxsV2l0aE9wdGlvbnMoeyBzaXplQnl0ZXM6IG9wdGlvbnM/LnNpemVCeXRlcyB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHtvcHRpb25zPy5hcGlVcmwgPz8gdGhpcy5hcGlVcmx9L3J1bnMvYmF0Y2hgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJiYXRjaCBjcmVhdGUgcnVuXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIGluZ2VzdC91cHNlcnQgbXVsdGlwbGUgcnVucyBpbiB0aGUgTGFuZ3NtaXRoIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gcnVuc1xuICAgICAqL1xuICAgIGFzeW5jIG11bHRpcGFydEluZ2VzdFJ1bnMoeyBydW5DcmVhdGVzLCBydW5VcGRhdGVzLCB9LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChydW5DcmVhdGVzID09PSB1bmRlZmluZWQgJiYgcnVuVXBkYXRlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJhbnNmb3JtIGFuZCBjb252ZXJ0IHRvIGRpY3RzXG4gICAgICAgIGNvbnN0IGFsbEF0dGFjaG1lbnRzID0ge307XG4gICAgICAgIGxldCBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGNyZWF0ZSBvZiBydW5DcmVhdGVzID8/IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZENyZWF0ZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKGNyZWF0ZSk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRDcmVhdGUuaWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlLmF0dGFjaG1lbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhbGxBdHRhY2htZW50c1twcmVwYXJlZENyZWF0ZS5pZF0gPSBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBwcmVwYXJlZENyZWF0ZS5hdHRhY2htZW50cztcbiAgICAgICAgICAgIHByZXBhcmVkQ3JlYXRlUGFyYW1zLnB1c2gocHJlcGFyZWRDcmVhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiBydW5VcGRhdGVzID8/IFtdKSB7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcy5wdXNoKGF3YWl0IHRoaXMucHJlcGFyZVJ1bkNyZWF0ZU9yVXBkYXRlSW5wdXRzKHVwZGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcXVpcmUgdHJhY2VfaWQgYW5kIGRvdHRlZF9vcmRlclxuICAgICAgICBjb25zdCBpbnZhbGlkUnVuQ3JlYXRlID0gcHJlcGFyZWRDcmVhdGVQYXJhbXMuZmluZCgocnVuQ3JlYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHJ1bkNyZWF0ZS50cmFjZV9pZCA9PT0gdW5kZWZpbmVkIHx8IHJ1bkNyZWF0ZS5kb3R0ZWRfb3JkZXIgPT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpZFJ1bkNyZWF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE11bHRpcGFydCBpbmdlc3QgcmVxdWlyZXMgXCJ0cmFjZV9pZFwiIGFuZCBcImRvdHRlZF9vcmRlclwiIHRvIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgcnVuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW52YWxpZFJ1blVwZGF0ZSA9IHByZXBhcmVkVXBkYXRlUGFyYW1zLmZpbmQoKHJ1blVwZGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChydW5VcGRhdGUudHJhY2VfaWQgPT09IHVuZGVmaW5lZCB8fCBydW5VcGRhdGUuZG90dGVkX29yZGVyID09PSB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGludmFsaWRSdW5VcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBhcnQgaW5nZXN0IHJlcXVpcmVzIFwidHJhY2VfaWRcIiBhbmQgXCJkb3R0ZWRfb3JkZXJcIiB0byBiZSBzZXQgd2hlbiB1cGRhdGluZyBhIHJ1bmApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbWJpbmUgcG9zdCBhbmQgcGF0Y2ggZGljdHMgd2hlcmUgcG9zc2libGVcbiAgICAgICAgaWYgKHByZXBhcmVkQ3JlYXRlUGFyYW1zLmxlbmd0aCA+IDAgJiYgcHJlcGFyZWRVcGRhdGVQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlQnlJZCA9IHByZXBhcmVkQ3JlYXRlUGFyYW1zLnJlZHVjZSgocGFyYW1zLCBydW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJ1bi5pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXNbcnVuLmlkXSA9IHJ1bjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhbG9uZVVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlUGFyYW0gb2YgcHJlcGFyZWRVcGRhdGVQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlUGFyYW0uaWQgIT09IHVuZGVmaW5lZCAmJiBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVCeUlkW3VwZGF0ZVBhcmFtLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNyZWF0ZUJ5SWRbdXBkYXRlUGFyYW0uaWRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4udXBkYXRlUGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGFuZGFsb25lVXBkYXRlcy5wdXNoKHVwZGF0ZVBhcmFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVwYXJlZENyZWF0ZVBhcmFtcyA9IE9iamVjdC52YWx1ZXMoY3JlYXRlQnlJZCk7XG4gICAgICAgICAgICBwcmVwYXJlZFVwZGF0ZVBhcmFtcyA9IHN0YW5kYWxvbmVVcGRhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVwYXJlZENyZWF0ZVBhcmFtcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHByZXBhcmVkVXBkYXRlUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbmQgdGhlIHJ1bnMgaW4gbXVsdGlwYXJ0IHJlcXVlc3RzXG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkQ29udGV4dCA9IFtdO1xuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW21ldGhvZCwgcGF5bG9hZHNdIG9mIFtcbiAgICAgICAgICAgIFtcInBvc3RcIiwgcHJlcGFyZWRDcmVhdGVQYXJhbXNdLFxuICAgICAgICAgICAgW1wicGF0Y2hcIiwgcHJlcGFyZWRVcGRhdGVQYXJhbXNdLFxuICAgICAgICBdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9yaWdpbmFsUGF5bG9hZCBvZiBwYXlsb2Fkcykge1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgZmllbGRzIHRvIGJlIHNlbnQgYXMgc2VwYXJhdGUgcGFydHNcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlucHV0cywgb3V0cHV0cywgZXZlbnRzLCBleHRyYSwgZXJyb3IsIHNlcmlhbGl6ZWQsIGF0dGFjaG1lbnRzLCAuLi5wYXlsb2FkIH0gPSBvcmlnaW5hbFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzID0geyBpbnB1dHMsIG91dHB1dHMsIGV2ZW50cywgZXh0cmEsIGVycm9yLCBzZXJpYWxpemVkIH07XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBtYWluIHJ1biBwYXlsb2FkXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRQYXlsb2FkID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcocGF5bG9hZCwgYFNlcmlhbGl6aW5nIGZvciBtdWx0aXBhcnQgaW5nZXN0aW9uIG9mIHJ1biB3aXRoIGlkOiAke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogYCR7bWV0aG9kfS4ke3BheWxvYWQuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogbmV3IEJsb2IoW3N0cmluZ2lmaWVkUGF5bG9hZF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFBheWxvYWQubGVuZ3RofWAsIC8vIGVuY29kaW5nPWd6aXBcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIHRoZSBmaWVsZHMgd2UgY29sbGVjdGVkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRzKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRWYWx1ZSA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKHZhbHVlLCBgU2VyaWFsaXppbmcgJHtrZXl9IGZvciBtdWx0aXBhcnQgaW5nZXN0aW9uIG9mIHJ1biB3aXRoIGlkOiAke3BheWxvYWQuaWR9YCk7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgJHttZXRob2R9LiR7cGF5bG9hZC5pZH0uJHtrZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IG5ldyBCbG9iKFtzdHJpbmdpZmllZFZhbHVlXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGBhcHBsaWNhdGlvbi9qc29uOyBsZW5ndGg9JHtzdHJpbmdpZmllZFZhbHVlLmxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgdGhlIGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRhY2htZW50cyA9IGFsbEF0dGFjaG1lbnRzW3BheWxvYWQuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhbGxBdHRhY2htZW50c1twYXlsb2FkLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGF0dGFjaG1lbnRdIG9mIE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29udGVudFR5cGUsIGNvbnRlbnRdID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gYXR0YWNobWVudC5taW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGF0dGFjaG1lbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgYXR0YWNobWVudCBuYW1lIGRvZXNuJ3QgY29udGFpbiBhICcuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFNraXBwaW5nIGF0dGFjaG1lbnQgJyR7bmFtZX0nIGZvciBydW4gJHtwYXlsb2FkLmlkfTogSW52YWxpZCBhdHRhY2htZW50IG5hbWUuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEF0dGFjaG1lbnQgbmFtZXMgbXVzdCBub3QgY29udGFpbiBwZXJpb2RzICgnLicpLiBQbGVhc2UgcmVuYW1lIHRoZSBhdHRhY2htZW50IGFuZCB0cnkgYWdhaW4uYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBgYXR0YWNobWVudC4ke3BheWxvYWQuaWR9LiR7bmFtZX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBuZXcgQmxvYihbY29udGVudF0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke2NvbnRlbnRUeXBlfTsgbGVuZ3RoPSR7Y29udGVudC5ieXRlTGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgY29udGV4dFxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkQ29udGV4dC5wdXNoKGB0cmFjZT0ke3BheWxvYWQudHJhY2VfaWR9LGlkPSR7cGF5bG9hZC5pZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9zZW5kTXVsdGlwYXJ0UmVxdWVzdChhY2N1bXVsYXRlZFBhcnRzLCBhY2N1bXVsYXRlZENvbnRleHQuam9pbihcIjsgXCIpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZU5vZGVGZXRjaEJvZHkocGFydHMsIGJvdW5kYXJ5KSB7XG4gICAgICAgIC8vIENyZWF0ZSBtdWx0aXBhcnQgZm9ybSBkYXRhIG1hbnVhbGx5IHVzaW5nIEJsb2JzXG4gICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIC8vIEFkZCBmaWVsZCBib3VuZGFyeVxuICAgICAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2AtLSR7Ym91bmRhcnl9XFxyXFxuYF0pKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKG5ldyBCbG9iKFtcbiAgICAgICAgICAgICAgICBgQ29udGVudC1EaXNwb3NpdGlvbjogZm9ybS1kYXRhOyBuYW1lPVwiJHtwYXJ0Lm5hbWV9XCJcXHJcXG5gLFxuICAgICAgICAgICAgICAgIGBDb250ZW50LVR5cGU6ICR7cGFydC5wYXlsb2FkLnR5cGV9XFxyXFxuXFxyXFxuYCxcbiAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHBhcnQucGF5bG9hZCk7XG4gICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQmxvYihbXCJcXHJcXG5cIl0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgZmluYWwgYm91bmRhcnlcbiAgICAgICAgY2h1bmtzLnB1c2gobmV3IEJsb2IoW2AtLSR7Ym91bmRhcnl9LS1cXHJcXG5gXSkpO1xuICAgICAgICAvLyBDb21iaW5lIGFsbCBjaHVua3MgaW50byBhIHNpbmdsZSBCbG9iXG4gICAgICAgIGNvbnN0IGJvZHkgPSBuZXcgQmxvYihjaHVua3MpO1xuICAgICAgICAvLyBDb252ZXJ0IEJsb2IgdG8gQXJyYXlCdWZmZXIgZm9yIGNvbXBhdGliaWxpdHlcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBib2R5LmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBhcnJheUJ1ZmZlcjtcbiAgICB9XG4gICAgYXN5bmMgX2NyZWF0ZU11bHRpcGFydFN0cmVhbShwYXJ0cywgYm91bmRhcnkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAvLyBDcmVhdGUgYSBSZWFkYWJsZVN0cmVhbSBmb3Igc3RyZWFtaW5nIHRoZSBtdWx0aXBhcnQgZGF0YVxuICAgICAgICAvLyBPbmx5IGRvIHNwZWNpYWwgaGFuZGxpbmcgaWYgd2UncmUgdXNpbmcgbm9kZS1mZXRjaFxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byB3cml0ZSBhIGNodW5rIHRvIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBjb25zdCB3cml0ZUNodW5rID0gYXN5bmMgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShjaHVuaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgZWFjaCBwYXJ0IHRvIHRoZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JpdGUgYm91bmRhcnkgYW5kIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhgLS0ke2JvdW5kYXJ5fVxcclxcbmApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGBDb250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGE7IG5hbWU9XCIke3BhcnQubmFtZX1cIlxcclxcbmApO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGBDb250ZW50LVR5cGU6ICR7cGFydC5wYXlsb2FkLnR5cGV9XFxyXFxuXFxyXFxuYCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBwYXlsb2FkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWRTdHJlYW0gPSBwYXJ0LnBheWxvYWQuc3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHBheWxvYWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKCEocmVzdWx0ID0gYXdhaXQgcmVhZGVyLnJlYWQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVDaHVuayhcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgZmluYWwgYm91bmRhcnlcbiAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZUNodW5rKGAtLSR7Ym91bmRhcnl9LS1cXHJcXG5gKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgYXN5bmMgX3NlbmRNdWx0aXBhcnRSZXF1ZXN0KHBhcnRzLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBtdWx0aXBhcnQgZm9ybSBkYXRhIGJvdW5kYXJ5XG4gICAgICAgIGNvbnN0IGJvdW5kYXJ5ID0gXCItLS0tTGFuZ1NtaXRoRm9ybUJvdW5kYXJ5XCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgICAgICAgY29uc3QgaXNOb2RlRmV0Y2ggPSBfZ2xvYmFsRmV0Y2hJbXBsZW1lbnRhdGlvbklzTm9kZUZldGNoKCk7XG4gICAgICAgIGNvbnN0IGJ1aWxkQnVmZmVyZWQgPSAoKSA9PiB0aGlzLl9jcmVhdGVOb2RlRmV0Y2hCb2R5KHBhcnRzLCBib3VuZGFyeSk7XG4gICAgICAgIGNvbnN0IGJ1aWxkU3RyZWFtID0gKCkgPT4gdGhpcy5fY3JlYXRlTXVsdGlwYXJ0U3RyZWFtKHBhcnRzLCBib3VuZGFyeSk7XG4gICAgICAgIGNvbnN0IHNlbmRXaXRoUmV0cnkgPSBhc3luYyAoYm9keUZhY3RvcnkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhdGNoSW5nZXN0Q2FsbGVyLmNhbGxXaXRoT3B0aW9ucyh7IHNpemVCeXRlczogb3B0aW9ucz8uc2l6ZUJ5dGVzIH0sIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgYm9keUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tcIngtYXBpLWtleVwiXSA9IG9wdGlvbnMuYXBpS2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWRCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucz8udXNlR3ppcCAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICBcInBpcGVUaHJvdWdoXCIgaW4gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEJvZHkgPSBib2R5LnBpcGVUaHJvdWdoKG5ldyBDb21wcmVzc2lvblN0cmVhbShcImd6aXBcIikpO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IFwiZ3ppcFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHRyYW5zZm9ybWVkQm9keSxcbiAgICAgICAgICAgICAgICAgICAgZHVwbGV4OiBcImhhbGZcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlc3BvbnNlLCBgRmFpbGVkIHRvIHNlbmQgbXVsdGlwYXJ0IHJlcXVlc3RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBsZXQgc3RyZWFtZWRBdHRlbXB0ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBhdHRlbXB0IHN0cmVhbSBvbmx5IGlmIG5vdCBkaXNhYmxlZCBhbmQgbm90IHVzaW5nIG5vZGUtZmV0Y2ggb3IgQnVuXG4gICAgICAgICAgICBpZiAoIWlzTm9kZUZldGNoICYmXG4gICAgICAgICAgICAgICAgIXRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICBnZXRFbnYoKSAhPT0gXCJidW5cIikge1xuICAgICAgICAgICAgICAgIHN0cmVhbWVkQXR0ZW1wdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgc2VuZFdpdGhSZXRyeShidWlsZFN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBzZW5kV2l0aFJldHJ5KGJ1aWxkQnVmZmVyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgc3RyZWFtIGZhaWxzLCBmYWxsYmFjayB0byBidWZmZXJlZCBib2R5XG4gICAgICAgICAgICBpZiAoKCF0aGlzLm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkIHx8IHN0cmVhbWVkQXR0ZW1wdCkgJiZcbiAgICAgICAgICAgICAgICByZXMuc3RhdHVzID09PSA0MjIgJiZcbiAgICAgICAgICAgICAgICAob3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsKSAhPT0gREVGQVVMVF9BUElfVVJMKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBTdHJlYW1pbmcgbXVsdGlwYXJ0IHVwbG9hZCB0byAke29wdGlvbnM/LmFwaVVybCA/PyB0aGlzLmFwaVVybH0vcnVucy9tdWx0aXBhcnQgZmFpbGVkLiBgICtcbiAgICAgICAgICAgICAgICAgICAgYFRoaXMgdXN1YWxseSBtZWFucyB0aGUgaG9zdCBkb2VzIG5vdCBzdXBwb3J0IGNodW5rZWQgdXBsb2Fkcy4gYCArXG4gICAgICAgICAgICAgICAgICAgIGBSZXRyeWluZyB3aXRoIGEgYnVmZmVyZWQgdXBsb2FkIGZvciBvcGVyYXRpb24gXCIke2NvbnRleHR9XCIuYCk7XG4gICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBzdHJlYW1pbmcgZm9yIGZ1dHVyZSByZXF1ZXN0c1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwYXJ0U3RyZWFtaW5nRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIHJldHJ5IHdpdGggZnVsbHktYnVmZmVyZWQgYm9keVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IHNlbmRXaXRoUmV0cnkoYnVpbGRCdWZmZXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBSZS10aHJvdyA0MDQgZXJyb3JzIHNvIGNhbGxlciBjYW4gZmFsbCBiYWNrIHRvIGJhdGNoIGluZ2VzdFxuICAgICAgICAgICAgaWYgKGlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvcihlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7ZS5tZXNzYWdlLnRyaW0oKX1cXG5cXG5Db250ZXh0OiAke2NvbnRleHR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUnVuKHJ1bklkLCBydW4sIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGlmIChydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICBydW4uaW5wdXRzID0gYXdhaXQgdGhpcy5wcm9jZXNzSW5wdXRzKHJ1bi5pbnB1dHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW4ub3V0cHV0cykge1xuICAgICAgICAgICAgcnVuLm91dHB1dHMgPSBhd2FpdCB0aGlzLnByb2Nlc3NPdXRwdXRzKHJ1bi5vdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBVbnRhbmdsZSB0eXBlc1xuICAgICAgICBjb25zdCBkYXRhID0geyAuLi5ydW4sIGlkOiBydW5JZCB9O1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbHRlckZvclNhbXBsaW5nKFtkYXRhXSwgdHJ1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b0JhdGNoVHJhY2luZyAmJlxuICAgICAgICAgICAgZGF0YS50cmFjZV9pZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBkYXRhLmRvdHRlZF9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvdGVsQ29udGV4dCA9IHRoaXMuX2Nsb25lQ3VycmVudE9URUxDb250ZXh0KCk7XG4gICAgICAgICAgICBpZiAocnVuLmVuZF90aW1lICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmVudF9ydW5faWQgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tPblJvb3RSdW5GaW5hbGl6YXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5tYW51YWxGbHVzaE1vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJhdGNoZXMgYXMgc29vbiBhcyBhIHJvb3QgdHJhY2UgZW5kcyBhbmQgd2FpdCB0byBlbnN1cmUgdHJhY2UgZmluaXNoZXNcbiAgICAgICAgICAgICAgICAvLyBpbiBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9pZCB0aGlzLnByb2Nlc3NSdW5PcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwidXBkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG90ZWxDb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXk6IG9wdGlvbnM/LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsOiBvcHRpb25zPy5hcGlVcmwsXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucz8uYXBpS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJ4LWFwaS1rZXlcIl0gPSBvcHRpb25zLmFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucz8ud29ya3NwYWNlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIngtdGVuYW50LWlkXCJdID0gb3B0aW9ucy53b3Jrc3BhY2VJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gc2VyaWFsaXplUGF5bG9hZEZvclRyYWNpbmcocnVuLCBgU2VyaWFsaXppbmcgcGF5bG9hZCB0byB1cGRhdGUgcnVuIHdpdGggaWQ6ICR7cnVuSWR9YCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7b3B0aW9ucz8uYXBpVXJsID8/IHRoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwZGF0ZSBydW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1bihydW5JZCwgeyBsb2FkQ2hpbGRSdW5zIH0gPSB7IGxvYWRDaGlsZFJ1bnM6IGZhbHNlIH0pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGxldCBydW4gPSBhd2FpdCB0aGlzLl9nZXQoYC9ydW5zLyR7cnVuSWR9YCk7XG4gICAgICAgIGlmIChsb2FkQ2hpbGRSdW5zKSB7XG4gICAgICAgICAgICBydW4gPSBhd2FpdCB0aGlzLl9sb2FkQ2hpbGRSdW5zKHJ1bik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuVXJsKHsgcnVuSWQsIHJ1biwgcHJvamVjdE9wdHMsIH0pIHtcbiAgICAgICAgaWYgKHJ1biAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbklkO1xuICAgICAgICAgICAgaWYgKHJ1bi5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkID0gcnVuLnNlc3Npb25faWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSAoYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7IHByb2plY3ROYW1lOiBwcm9qZWN0T3B0cz8ucHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvamVjdE9wdHM/LnByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IHByb2plY3RPcHRzPy5wcm9qZWN0SWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9qZWN0ID0gYXdhaXQgdGhpcy5yZWFkUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiUFJPSkVDVFwiKSB8fCBcImRlZmF1bHRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBwcm9qZWN0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGVuYW50SWQgPSBhd2FpdCB0aGlzLl9nZXRUZW5hbnRJZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9vLyR7dGVuYW50SWR9L3Byb2plY3RzL3AvJHtzZXNzaW9uSWR9L3IvJHtydW4uaWR9P3BvbGw9dHJ1ZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVuSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcnVuXyA9IGF3YWl0IHRoaXMucmVhZFJ1bihydW5JZCk7XG4gICAgICAgICAgICBpZiAoIXJ1bl8uYXBwX3BhdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1biAke3J1bklkfSBoYXMgbm8gYXBwX3BhdGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEhvc3RVcmwoKTtcbiAgICAgICAgICAgIHJldHVybiBgJHtiYXNlVXJsfSR7cnVuXy5hcHBfcGF0aH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBydW5JZCBvciBydW5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2xvYWRDaGlsZFJ1bnMocnVuKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkUnVucyA9IGF3YWl0IHRvQXJyYXkodGhpcy5saXN0UnVucyh7XG4gICAgICAgICAgICBpc1Jvb3Q6IGZhbHNlLFxuICAgICAgICAgICAgcHJvamVjdElkOiBydW4uc2Vzc2lvbl9pZCxcbiAgICAgICAgICAgIHRyYWNlSWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCB0cmVlbWFwID0ge307XG4gICAgICAgIGNvbnN0IHJ1bnMgPSB7fTtcbiAgICAgICAgLy8gVE9ETzogbWFrZSBkb3R0ZWQgb3JkZXIgcmVxdWlyZWQgd2hlbiB0aGUgbWlncmF0aW9uIGZpbmlzaGVzXG4gICAgICAgIGNoaWxkUnVucy5zb3J0KChhLCBiKSA9PiAoYT8uZG90dGVkX29yZGVyID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUoYj8uZG90dGVkX29yZGVyID8/IFwiXCIpKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZFJ1biBvZiBjaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgY2hpbGRSdW4ucGFyZW50X3J1bl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZCBydW4gJHtjaGlsZFJ1bi5pZH0gaGFzIG5vIHBhcmVudGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkUnVuLmRvdHRlZF9vcmRlcj8uc3RhcnRzV2l0aChydW4uZG90dGVkX29yZGVyID8/IFwiXCIpICYmXG4gICAgICAgICAgICAgICAgY2hpbGRSdW4uaWQgIT09IHJ1bi5pZCkge1xuICAgICAgICAgICAgICAgIGlmICghKGNoaWxkUnVuLnBhcmVudF9ydW5faWQgaW4gdHJlZW1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJlZW1hcFtjaGlsZFJ1bi5wYXJlbnRfcnVuX2lkXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmVlbWFwW2NoaWxkUnVuLnBhcmVudF9ydW5faWRdLnB1c2goY2hpbGRSdW4pO1xuICAgICAgICAgICAgICAgIHJ1bnNbY2hpbGRSdW4uaWRdID0gY2hpbGRSdW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVuLmNoaWxkX3J1bnMgPSB0cmVlbWFwW3J1bi5pZF0gfHwgW107XG4gICAgICAgIGZvciAoY29uc3QgcnVuSWQgaW4gdHJlZW1hcCkge1xuICAgICAgICAgICAgaWYgKHJ1bklkICE9PSBydW4uaWQpIHtcbiAgICAgICAgICAgICAgICBydW5zW3J1bklkXS5jaGlsZF9ydW5zID0gdHJlZW1hcFtydW5JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBydW5zIGZyb20gdGhlIExhbmdTbWl0aCBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHByb2plY3RJZCAtIFRoZSBJRCBvZiB0aGUgcHJvamVjdCB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb2plY3QgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEBwYXJhbSBwYXJlbnRSdW5JZCAtIFRoZSBJRCBvZiB0aGUgcGFyZW50IHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHRyYWNlSWQgLSBUaGUgSUQgb2YgdGhlIHRyYWNlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlRXhhbXBsZUlkIC0gVGhlIElEIG9mIHRoZSByZWZlcmVuY2UgZXhhbXBsZSB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gaXNSb290IC0gSW5kaWNhdGVzIHdoZXRoZXIgdG8gb25seSByZXR1cm4gcm9vdCBydW5zLlxuICAgICAqIEBwYXJhbSBydW5UeXBlIC0gVGhlIHJ1biB0eXBlIHRvIGZpbHRlciBieS5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBJbmRpY2F0ZXMgd2hldGhlciB0byBmaWx0ZXIgYnkgZXJyb3IgcnVucy5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHN0cmluZyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHBhcmFtIGZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IHRvIHRoZSBydW4gc3BhbnMuXG4gICAgICogQHBhcmFtIHRyYWNlRmlsdGVyIC0gVGhlIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgb24gdGhlIHJvb3QgcnVuIG9mIHRoZSB0cmFjZS5cbiAgICAgKiBAcGFyYW0gdHJlZUZpbHRlciAtIFRoZSBmaWx0ZXIgc3RyaW5nIHRvIGFwcGx5IG9uIG90aGVyIHJ1bnMgaW4gdGhlIHRyYWNlLlxuICAgICAqIEBwYXJhbSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBydW5zIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIHtBc3luY0l0ZXJhYmxlPFJ1bj59IC0gVGhlIHJ1bnMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgaW4gYSBwcm9qZWN0XG4gICAgICogY29uc3QgcHJvamVjdFJ1bnMgPSBjbGllbnQubGlzdFJ1bnMoeyBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IExMTSBhbmQgQ2hhdCBydW5zIGluIHRoZSBsYXN0IDI0IGhvdXJzXG4gICAgICogY29uc3QgdG9kYXlzTExNUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgc3RhcnRfdGltZTogbmV3IERhdGUoRGF0ZS5ub3coKSAtIDI0ICogNjAgKiA2MCAqIDEwMDApLFxuICAgICAqICAgcnVuX3R5cGU6IFwibGxtXCIsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgdHJhY2VzIGluIGEgcHJvamVjdFxuICAgICAqIGNvbnN0IHJvb3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBleGVjdXRpb25fb3JkZXI6IDEsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyB3aXRob3V0IGVycm9yc1xuICAgICAqIGNvbnN0IGNvcnJlY3RSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBlcnJvcjogZmFsc2UsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgcnVucyBieSBydW4gSURcbiAgICAgKiBjb25zdCBydW5JZHMgPSBbXG4gICAgICogICBcImEzNjA5MmQyLTRhZDUtNGZiNC05YzBkLTBkYmE5YTJlZDgzNlwiLFxuICAgICAqICAgXCI5Mzk4ZTZiZS05NjRmLTRhYTQtOGFlOS1hZDc4Y2Q0YjcwNzRcIixcbiAgICAgKiBdO1xuICAgICAqIGNvbnN0IHNlbGVjdGVkUnVucyA9IGNsaWVudC5saXN0UnVucyh7IHJ1bl9pZHM6IHJ1bklkcyB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgXCJjaGFpblwiIHR5cGUgcnVucyB0aGF0IHRvb2sgbW9yZSB0aGFuIDEwIHNlY29uZHMgYW5kIGhhZCBgdG90YWxfdG9rZW5zYCBncmVhdGVyIHRoYW4gNTAwMFxuICAgICAqIGNvbnN0IGNoYWluUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKGVxKHJ1bl90eXBlLCBcImNoYWluXCIpLCBndChsYXRlbmN5LCAxMCksIGd0KHRvdGFsX3Rva2VucywgNTAwMCkpJyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gTGlzdCBhbGwgcnVucyBjYWxsZWQgXCJleHRyYWN0b3JcIiB3aG9zZSByb290IG9mIHRoZSB0cmFjZSB3YXMgYXNzaWduZWQgZmVlZGJhY2sgXCJ1c2VyX3Njb3JlXCIgc2NvcmUgb2YgMVxuICAgICAqIGNvbnN0IGdvb2RFeHRyYWN0b3JSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdlcShuYW1lLCBcImV4dHJhY3RvclwiKScsXG4gICAgICogICB0cmFjZUZpbHRlcjogJ2FuZChlcShmZWVkYmFja19rZXksIFwidXNlcl9zY29yZVwiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDEpKScsXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIExpc3QgYWxsIHJ1bnMgdGhhdCBzdGFydGVkIGFmdGVyIGEgc3BlY2lmaWMgdGltZXN0YW1wIGFuZCBlaXRoZXIgaGF2ZSBcImVycm9yXCIgbm90IGVxdWFsIHRvIG51bGwgb3IgYSBcIkNvcnJlY3RuZXNzXCIgZmVlZGJhY2sgc2NvcmUgZXF1YWwgdG8gMFxuICAgICAqIGNvbnN0IGNvbXBsZXhSdW5zID0gY2xpZW50Lmxpc3RSdW5zKHtcbiAgICAgKiAgIHByb2plY3ROYW1lOiBcIjx5b3VyX3Byb2plY3Q+XCIsXG4gICAgICogICBmaWx0ZXI6ICdhbmQoZ3Qoc3RhcnRfdGltZSwgXCIyMDIzLTA3LTE1VDEyOjM0OjU2WlwiKSwgb3IobmVxKGVycm9yLCBudWxsKSwgYW5kKGVxKGZlZWRiYWNrX2tleSwgXCJDb3JyZWN0bmVzc1wiKSwgZXEoZmVlZGJhY2tfc2NvcmUsIDAuMCkpKSknLFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBMaXN0IGFsbCBydW5zIHdoZXJlIGB0YWdzYCBpbmNsdWRlIFwiZXhwZXJpbWVudGFsXCIgb3IgXCJiZXRhXCIgYW5kIGBsYXRlbmN5YCBpcyBncmVhdGVyIHRoYW4gMiBzZWNvbmRzXG4gICAgICogY29uc3QgdGFnZ2VkUnVucyA9IGNsaWVudC5saXN0UnVucyh7XG4gICAgICogICBwcm9qZWN0TmFtZTogXCI8eW91cl9wcm9qZWN0PlwiLFxuICAgICAqICAgZmlsdGVyOiAnYW5kKG9yKGhhcyh0YWdzLCBcImV4cGVyaW1lbnRhbFwiKSwgaGFzKHRhZ3MsIFwiYmV0YVwiKSksIGd0KGxhdGVuY3ksIDIpKScsXG4gICAgICogfSk7XG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RSdW5zKHByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgcGFyZW50UnVuSWQsIHRyYWNlSWQsIHJlZmVyZW5jZUV4YW1wbGVJZCwgc3RhcnRUaW1lLCBleGVjdXRpb25PcmRlciwgaXNSb290LCBydW5UeXBlLCBlcnJvciwgaWQsIHF1ZXJ5LCBmaWx0ZXIsIHRyYWNlRmlsdGVyLCB0cmVlRmlsdGVyLCBsaW1pdCwgc2VsZWN0LCBvcmRlciwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgcHJvamVjdElkcyA9IFtdO1xuICAgICAgICBpZiAocHJvamVjdElkKSB7XG4gICAgICAgICAgICBwcm9qZWN0SWRzID0gQXJyYXkuaXNBcnJheShwcm9qZWN0SWQpID8gcHJvamVjdElkIDogW3Byb2plY3RJZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2plY3ROYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0TmFtZXMgPSBBcnJheS5pc0FycmF5KHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgID8gcHJvamVjdE5hbWVcbiAgICAgICAgICAgICAgICA6IFtwcm9qZWN0TmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcm9qZWN0SWRzXyA9IGF3YWl0IFByb21pc2UuYWxsKHByb2plY3ROYW1lcy5tYXAoKG5hbWUpID0+IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZTogbmFtZSB9KS50aGVuKChwcm9qZWN0KSA9PiBwcm9qZWN0LmlkKSkpO1xuICAgICAgICAgICAgcHJvamVjdElkcy5wdXNoKC4uLnByb2plY3RJZHNfKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0X3NlbGVjdCA9IFtcbiAgICAgICAgICAgIFwiYXBwX3BhdGhcIixcbiAgICAgICAgICAgIFwiY29tcGxldGlvbl9jb3N0XCIsXG4gICAgICAgICAgICBcImNvbXBsZXRpb25fdG9rZW5zXCIsXG4gICAgICAgICAgICBcImRvdHRlZF9vcmRlclwiLFxuICAgICAgICAgICAgXCJlbmRfdGltZVwiLFxuICAgICAgICAgICAgXCJlcnJvclwiLFxuICAgICAgICAgICAgXCJldmVudHNcIixcbiAgICAgICAgICAgIFwiZXh0cmFcIixcbiAgICAgICAgICAgIFwiZmVlZGJhY2tfc3RhdHNcIixcbiAgICAgICAgICAgIFwiZmlyc3RfdG9rZW5fdGltZVwiLFxuICAgICAgICAgICAgXCJpZFwiLFxuICAgICAgICAgICAgXCJpbnB1dHNcIixcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgXCJvdXRwdXRzXCIsXG4gICAgICAgICAgICBcInBhcmVudF9ydW5faWRcIixcbiAgICAgICAgICAgIFwicGFyZW50X3J1bl9pZHNcIixcbiAgICAgICAgICAgIFwicHJvbXB0X2Nvc3RcIixcbiAgICAgICAgICAgIFwicHJvbXB0X3Rva2Vuc1wiLFxuICAgICAgICAgICAgXCJyZWZlcmVuY2VfZXhhbXBsZV9pZFwiLFxuICAgICAgICAgICAgXCJydW5fdHlwZVwiLFxuICAgICAgICAgICAgXCJzZXNzaW9uX2lkXCIsXG4gICAgICAgICAgICBcInN0YXJ0X3RpbWVcIixcbiAgICAgICAgICAgIFwic3RhdHVzXCIsXG4gICAgICAgICAgICBcInRhZ3NcIixcbiAgICAgICAgICAgIFwidG90YWxfY29zdFwiLFxuICAgICAgICAgICAgXCJ0b3RhbF90b2tlbnNcIixcbiAgICAgICAgICAgIFwidHJhY2VfaWRcIixcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHNlc3Npb246IHByb2plY3RJZHMubGVuZ3RoID8gcHJvamVjdElkcyA6IG51bGwsXG4gICAgICAgICAgICBydW5fdHlwZTogcnVuVHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWQsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGZpbHRlcixcbiAgICAgICAgICAgIHRyYWNlX2ZpbHRlcjogdHJhY2VGaWx0ZXIsXG4gICAgICAgICAgICB0cmVlX2ZpbHRlcjogdHJlZUZpbHRlcixcbiAgICAgICAgICAgIGV4ZWN1dGlvbl9vcmRlcjogZXhlY3V0aW9uT3JkZXIsXG4gICAgICAgICAgICBwYXJlbnRfcnVuOiBwYXJlbnRSdW5JZCxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSA/IHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBsaW1pdCxcbiAgICAgICAgICAgIHRyYWNlOiB0cmFjZUlkLFxuICAgICAgICAgICAgc2VsZWN0OiBzZWxlY3QgPyBzZWxlY3QgOiBkZWZhdWx0X3NlbGVjdCxcbiAgICAgICAgICAgIGlzX3Jvb3Q6IGlzUm9vdCxcbiAgICAgICAgICAgIG9yZGVyLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYm9keS5zZWxlY3QuaW5jbHVkZXMoXCJjaGlsZF9ydW5faWRzXCIpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcIkRlcHJlY2F0ZWQ6ICdjaGlsZF9ydW5faWRzJyBpbiB0aGUgbGlzdFJ1bnMgc2VsZWN0IHBhcmFtZXRlciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJ1bnNZaWVsZGVkID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBydW5zIG9mIHRoaXMuX2dldEN1cnNvclBhZ2luYXRlZExpc3QoXCIvcnVucy9xdWVyeVwiLCBib2R5KSkge1xuICAgICAgICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bnNZaWVsZGVkID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVucy5sZW5ndGggKyBydW5zWWllbGRlZCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1J1bnMgPSBydW5zLnNsaWNlKDAsIGxpbWl0IC0gcnVuc1lpZWxkZWQpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogbmV3UnVucztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bnNZaWVsZGVkICs9IHJ1bnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHlpZWxkKiBydW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHJ1bnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgKmxpc3RHcm91cFJ1bnMocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCBncm91cEJ5LCBmaWx0ZXIsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIG9mZnNldCwgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwcm9qZWN0SWQgfHwgKGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0TmFtZSB9KSkuaWQ7XG4gICAgICAgIGNvbnN0IGJhc2VCb2R5ID0ge1xuICAgICAgICAgICAgc2Vzc2lvbl9pZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgZ3JvdXBfYnk6IGdyb3VwQnksXG4gICAgICAgICAgICBmaWx0ZXIsXG4gICAgICAgICAgICBzdGFydF90aW1lOiBzdGFydFRpbWUgPyBzdGFydFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSA/IGVuZFRpbWUudG9JU09TdHJpbmcoKSA6IG51bGwsXG4gICAgICAgICAgICBsaW1pdDogTnVtYmVyKGxpbWl0KSB8fCAxMDAsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgICAgICAgY29uc3QgcGF0aCA9IFwiL3J1bnMvZ3JvdXBcIjtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9JHtwYXRofWA7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlQm9keSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGN1cnJlbnRPZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXMgZnJvbSB0aGUgcGF5bG9hZFxuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGN1cnJlbnRCb2R5KS5maWx0ZXIoKFtfLCB2YWx1ZV0pID0+IHZhbHVlICE9PSB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShmaWx0ZXJlZFBheWxvYWQpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBGYWlsZWQgdG8gZmV0Y2ggJHtwYXRofWApO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgeyBncm91cHMsIHRvdGFsIH0gPSBpdGVtcztcbiAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRocmVhZCBvZiBncm91cHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aHJlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T2Zmc2V0ICs9IGdyb3Vwcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoY3VycmVudE9mZnNldCA+PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0YXRzKHsgaWQsIHRyYWNlLCBwYXJlbnRSdW4sIHJ1blR5cGUsIHByb2plY3ROYW1lcywgcHJvamVjdElkcywgcmVmZXJlbmNlRXhhbXBsZUlkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBlcnJvciwgcXVlcnksIGZpbHRlciwgdHJhY2VGaWx0ZXIsIHRyZWVGaWx0ZXIsIGlzUm9vdCwgZGF0YVNvdXJjZVR5cGUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZHNfID0gcHJvamVjdElkcyB8fCBbXTtcbiAgICAgICAgaWYgKHByb2plY3ROYW1lcykge1xuICAgICAgICAgICAgcHJvamVjdElkc18gPSBbXG4gICAgICAgICAgICAgICAgLi4uKHByb2plY3RJZHMgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLihhd2FpdCBQcm9taXNlLmFsbChwcm9qZWN0TmFtZXMubWFwKChuYW1lKSA9PiB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWU6IG5hbWUgfSkudGhlbigocHJvamVjdCkgPT4gcHJvamVjdC5pZCkpKSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHRyYWNlLFxuICAgICAgICAgICAgcGFyZW50X3J1bjogcGFyZW50UnVuLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1blR5cGUsXG4gICAgICAgICAgICBzZXNzaW9uOiBwcm9qZWN0SWRzXyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlOiByZWZlcmVuY2VFeGFtcGxlSWRzLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogc3RhcnRUaW1lLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUsXG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgZmlsdGVyLFxuICAgICAgICAgICAgdHJhY2VfZmlsdGVyOiB0cmFjZUZpbHRlcixcbiAgICAgICAgICAgIHRyZWVfZmlsdGVyOiB0cmVlRmlsdGVyLFxuICAgICAgICAgICAgaXNfcm9vdDogaXNSb290LFxuICAgICAgICAgICAgZGF0YV9zb3VyY2VfdHlwZTogZGF0YVNvdXJjZVR5cGUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlbW92ZSB1bmRlZmluZWQgdmFsdWVzIGZyb20gdGhlIHBheWxvYWRcbiAgICAgICAgY29uc3QgZmlsdGVyZWRQYXlsb2FkID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHBheWxvYWQpLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZCkpO1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZmlsdGVyZWRQYXlsb2FkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zL3N0YXRzYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBydW4gc3RhdHNcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBzaGFyZVJ1bihydW5JZCwgeyBzaGFyZUlkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgcnVuX2lkOiBydW5JZCxcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZUlkIHx8IHV1aWQudjQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9ydW5zLyR7cnVuSWR9L3NoYXJlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQVVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInNoYXJlIHJ1blwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgIShcInNoYXJlX3Rva2VuXCIgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L3B1YmxpYy8ke3Jlc3VsdFtcInNoYXJlX3Rva2VuXCJdfS9yYDtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGFyZVJ1bihydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidW5zaGFyZSBydW5cIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZFJ1blNoYXJlZExpbmsocnVuSWQpIHtcbiAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcnVucy8ke3J1bklkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBydW4gc2hhcmVkIGxpbmtcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8ICEoXCJzaGFyZV90b2tlblwiIGluIHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtyZXN1bHRbXCJzaGFyZV90b2tlblwiXX0vcmA7XG4gICAgfVxuICAgIGFzeW5jIGxpc3RTaGFyZWRSdW5zKHNoYXJlVG9rZW4sIHsgcnVuSWRzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHNoYXJlX3Rva2VuOiBzaGFyZVRva2VuLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJ1bklkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bklkIG9mIHJ1bklkcykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmFwcGVuZChcImlkXCIsIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHNoYXJlVG9rZW4pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L3J1bnMke3F1ZXJ5UGFyYW1zfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwibGlzdCBzaGFyZWQgcnVuc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBydW5zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcnVucztcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXRTaGFyZWRTY2hlbWEoZGF0YXNldElkLCBkYXRhc2V0TmFtZSkge1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBkYXRhc2V0SWQgb3IgZGF0YXNldE5hbWUgbXVzdCBiZSBnaXZlblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBkYXRhc2V0IHNoYXJlZCBzY2hlbWFcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc2hhcmVTY2hlbWEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNoYXJlU2NoZW1hLnVybCA9IGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wdWJsaWMvJHtzaGFyZVNjaGVtYS5zaGFyZV90b2tlbn0vZGA7XG4gICAgICAgIHJldHVybiBzaGFyZVNjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCwgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgaWYgKCFkYXRhc2V0SWQgJiYgIWRhdGFzZXROYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgZGF0YXNldElkIG9yIGRhdGFzZXROYW1lIG11c3QgYmUgZ2l2ZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWQsXG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUFVUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJzaGFyZSBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNoYXJlU2NoZW1hID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBzaGFyZVNjaGVtYS51cmwgPSBgJHt0aGlzLmdldEhvc3RVcmwoKX0vcHVibGljLyR7c2hhcmVTY2hlbWEuc2hhcmVfdG9rZW59L2RgO1xuICAgICAgICByZXR1cm4gc2hhcmVTY2hlbWE7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hhcmVEYXRhc2V0KGRhdGFzZXRJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkfS9zaGFyZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidW5zaGFyZSBkYXRhc2V0XCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRTaGFyZWREYXRhc2V0KHNoYXJlVG9rZW4pIHtcbiAgICAgICAgYXNzZXJ0VXVpZChzaGFyZVRva2VuKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9wdWJsaWMvJHtzaGFyZVRva2VufS9kYXRhc2V0c2AsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBzaGFyZWQgZGF0YXNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNoYXJlZCBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFyZVRva2VuIFRoZSBzaGFyZSB0b2tlbiB0byBnZXQgZXhhbXBsZXMgZm9yLiBBIHNoYXJlIHRva2VuIGlzIHRoZSBVVUlEIChvciBMYW5nU21pdGggVVJMLCBpbmNsdWRpbmcgVVVJRCkgZ2VuZXJhdGVkIHdoZW4gZXhwbGljaXRseSBtYXJraW5nIGFuIGV4YW1wbGUgYXMgcHVibGljLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBsaXN0aW5nIHRoZSBleGFtcGxlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdIHwgdW5kZWZpbmVkfSBbb3B0aW9ucy5leGFtcGxlSWRzXSBBIGxpc3Qgb2YgZXhhbXBsZSBJRHMgdG8gZmlsdGVyIGJ5LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEV4YW1wbGVbXT59IFRoZSBzaGFyZWQgZXhhbXBsZXMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFNoYXJlZEV4YW1wbGVzKHNoYXJlVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5leGFtcGxlSWRzKSB7XG4gICAgICAgICAgICBwYXJhbXMuaWQgPSBvcHRpb25zLmV4YW1wbGVJZHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhwYXJhbXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodikgPT4gdXJsUGFyYW1zLmFwcGVuZChrZXksIHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVybFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3B1YmxpYy8ke3NoYXJlVG9rZW59L2V4YW1wbGVzPyR7dXJsUGFyYW1zLnRvU3RyaW5nKCl9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJsaXN0IHNoYXJlZCBleGFtcGxlc1wiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChcImRldGFpbFwiIGluIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpc3Qgc2hhcmVkIGV4YW1wbGVzLlxcblN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9XFxuTWVzc2FnZTogJHtBcnJheS5pc0FycmF5KHJlc3VsdC5kZXRhaWwpXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LmRldGFpbC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCJVbnNwZWNpZmllZCBlcnJvclwifWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGlzdCBzaGFyZWQgZXhhbXBsZXM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tYXAoKGV4YW1wbGUpID0+ICh7XG4gICAgICAgICAgICAuLi5leGFtcGxlLFxuICAgICAgICAgICAgX2hvc3RVcmw6IHRoaXMuZ2V0SG9zdFVybCgpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb2plY3QoeyBwcm9qZWN0TmFtZSwgZGVzY3JpcHRpb24gPSBudWxsLCBtZXRhZGF0YSA9IG51bGwsIHVwc2VydCA9IGZhbHNlLCBwcm9qZWN0RXh0cmEgPSBudWxsLCByZWZlcmVuY2VEYXRhc2V0SWQgPSBudWxsLCB9KSB7XG4gICAgICAgIGNvbnN0IHVwc2VydF8gPSB1cHNlcnQgPyBgP3Vwc2VydD10cnVlYCA6IFwiXCI7XG4gICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy5hcGlVcmx9L3Nlc3Npb25zJHt1cHNlcnRffWA7XG4gICAgICAgIGNvbnN0IGV4dHJhID0gcHJvamVjdEV4dHJhIHx8IHt9O1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGV4dHJhW1wibWV0YWRhdGFcIl0gPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVmZXJlbmNlRGF0YXNldElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBib2R5W1wicmVmZXJlbmNlX2RhdGFzZXRfaWRcIl0gPSByZWZlcmVuY2VEYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvamVjdChwcm9qZWN0SWQsIHsgbmFtZSA9IG51bGwsIGRlc2NyaXB0aW9uID0gbnVsbCwgbWV0YWRhdGEgPSBudWxsLCBwcm9qZWN0RXh0cmEgPSBudWxsLCBlbmRUaW1lID0gbnVsbCwgfSkge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZH1gO1xuICAgICAgICBsZXQgZXh0cmEgPSBwcm9qZWN0RXh0cmE7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZXh0cmEgPSB7IC4uLihleHRyYSB8fCB7fSksIG1ldGFkYXRhIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZW5kX3RpbWU6IGVuZFRpbWUgPyBuZXcgRGF0ZShlbmRUaW1lKS50b0lTT1N0cmluZygpIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgcHJvamVjdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc1Byb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lLCB9KSB7XG4gICAgICAgIC8vIFRPRE86IEFkZCBhIGhlYWQgcmVxdWVzdFxuICAgICAgICBsZXQgcGF0aCA9IFwiL3Nlc3Npb25zXCI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChwcm9qZWN0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7cHJvamVjdElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm5hbWVcIiwgcHJvamVjdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIHByb2plY3ROYW1lIG9yIHByb2plY3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHtwYXRofT8ke3BhcmFtc31gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImhhcyBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbnN1bWUgdGhlIHJlc3BvbnNlIGJvZHkgdG8gcmVsZWFzZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAvLyBodHRwczovL3VuZGljaS5ub2RlanMub3JnLyMvP2lkPWdhcmJhZ2UtY29sbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGl0J3MgT0sgYW5kIHdlJ3JlIHF1ZXJ5aW5nIGJ5IG5hbWUsIG5lZWQgdG8gY2hlY2sgdGhlIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJvamVjdElkIHF1ZXJ5aW5nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlYWRQcm9qZWN0KHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgaW5jbHVkZVN0YXRzLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvc2Vzc2lvbnNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAocHJvamVjdElkICE9PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZCk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtwcm9qZWN0SWR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlU3RhdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImluY2x1ZGVfc3RhdHNcIiwgaW5jbHVkZVN0YXRzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvamVjdFtpZD0ke3Byb2plY3RJZH0sIG5hbWU9JHtwcm9qZWN0TmFtZX1dIG5vdCBmb3VuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzcG9uc2VbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBnZXRQcm9qZWN0VXJsKHsgcHJvamVjdElkLCBwcm9qZWN0TmFtZSwgfSkge1xuICAgICAgICBpZiAocHJvamVjdElkID09PSB1bmRlZmluZWQgJiYgcHJvamVjdE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBwcm9qZWN0TmFtZSBvciBwcm9qZWN0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvamVjdCA9IGF3YWl0IHRoaXMucmVhZFByb2plY3QoeyBwcm9qZWN0SWQsIHByb2plY3ROYW1lIH0pO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9wcm9qZWN0cy9wLyR7cHJvamVjdC5pZH1gO1xuICAgIH1cbiAgICBhc3luYyBnZXREYXRhc2V0VXJsKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgfSkge1xuICAgICAgICBpZiAoZGF0YXNldElkID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lIH0pO1xuICAgICAgICBjb25zdCB0ZW5hbnRJZCA9IGF3YWl0IHRoaXMuX2dldFRlbmFudElkKCk7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmdldEhvc3RVcmwoKX0vby8ke3RlbmFudElkfS9kYXRhc2V0cy8ke2RhdGFzZXQuaWR9YDtcbiAgICB9XG4gICAgYXN5bmMgX2dldFRlbmFudElkKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVuYW50SWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW5hbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBsaW1pdDogXCIxXCIgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcHJvamVjdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL3Nlc3Npb25zXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgdGhpcy5fdGVuYW50SWQgPSBwcm9qZWN0c1swXS50ZW5hbnRfaWQ7XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdHNbMF0udGVuYW50X2lkO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHByb2plY3RzIGZvdW5kIHRvIHJlc29sdmUgdGVuYW50LlwiKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RQcm9qZWN0cyh7IHByb2plY3RJZHMsIG5hbWUsIG5hbWVDb250YWlucywgcmVmZXJlbmNlRGF0YXNldElkLCByZWZlcmVuY2VEYXRhc2V0TmFtZSwgaW5jbHVkZVN0YXRzLCBkYXRhc2V0VmVyc2lvbiwgcmVmZXJlbmNlRnJlZSwgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChwcm9qZWN0SWRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvamVjdElkIG9mIHByb2plY3RJZHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaWRcIiwgcHJvamVjdElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZUNvbnRhaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZmVyZW5jZURhdGFzZXRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgcmVmZXJlbmNlRGF0YXNldElkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWZlcmVuY2VEYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7XG4gICAgICAgICAgICAgICAgZGF0YXNldE5hbWU6IHJlZmVyZW5jZURhdGFzZXROYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwicmVmZXJlbmNlX2RhdGFzZXRcIiwgZGF0YXNldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVTdGF0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5jbHVkZV9zdGF0c1wiLCBpbmNsdWRlU3RhdHMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXRWZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJkYXRhc2V0X3ZlcnNpb25cIiwgZGF0YXNldFZlcnNpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VGcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJyZWZlcmVuY2VfZnJlZVwiLCByZWZlcmVuY2VGcmVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibWV0YWRhdGFcIiwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHByb2plY3RzIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9zZXNzaW9uc1wiLCBwYXJhbXMpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvamVjdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUHJvamVjdCh7IHByb2plY3RJZCwgcHJvamVjdE5hbWUsIH0pIHtcbiAgICAgICAgbGV0IHByb2plY3RJZF87XG4gICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCAmJiBwcm9qZWN0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2plY3RJZCAhPT0gdW5kZWZpbmVkICYmIHByb2plY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgcHJvamVjdE5hbWUgb3IgcHJvamVjdElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9qZWN0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IChhd2FpdCB0aGlzLnJlYWRQcm9qZWN0KHsgcHJvamVjdE5hbWUgfSkpLmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvamVjdElkXyA9IHByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKHByb2plY3RJZF8pO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9zZXNzaW9ucy8ke3Byb2plY3RJZF99YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGRlbGV0ZSBzZXNzaW9uICR7cHJvamVjdElkX30gKCR7cHJvamVjdE5hbWV9KWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZENzdih7IGNzdkZpbGUsIGZpbGVOYW1lLCBpbnB1dEtleXMsIG91dHB1dEtleXMsIGRlc2NyaXB0aW9uLCBkYXRhVHlwZSwgbmFtZSwgfSkge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvdXBsb2FkYDtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwiZmlsZVwiLCBjc3ZGaWxlLCBmaWxlTmFtZSk7XG4gICAgICAgIGlucHV0S2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImlucHV0X2tleXNcIiwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dHB1dEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJvdXRwdXRfa2V5c1wiLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkZXNjcmlwdGlvblwiLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJkYXRhX3R5cGVcIiwgZGF0YVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcInVwbG9hZCBDU1ZcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVEYXRhc2V0KG5hbWUsIHsgZGVzY3JpcHRpb24sIGRhdGFUeXBlLCBpbnB1dHNTY2hlbWEsIG91dHB1dHNTY2hlbWEsIG1ldGFkYXRhLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGV4dHJhOiBtZXRhZGF0YSA/IHsgbWV0YWRhdGEgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRhdGFUeXBlKSB7XG4gICAgICAgICAgICBib2R5LmRhdGFfdHlwZSA9IGRhdGFUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dHNTY2hlbWEpIHtcbiAgICAgICAgICAgIGJvZHkuaW5wdXRzX3NjaGVtYV9kZWZpbml0aW9uID0gaW5wdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXRwdXRzU2NoZW1hKSB7XG4gICAgICAgICAgICBib2R5Lm91dHB1dHNfc2NoZW1hX2RlZmluaXRpb24gPSBvdXRwdXRzU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgLy8gbGltaXQgdG8gMSByZXN1bHRcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IGxpbWl0OiBcIjFcIiB9KTtcbiAgICAgICAgaWYgKGRhdGFzZXRJZCAmJiBkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCkge1xuICAgICAgICAgICAgYXNzZXJ0VXVpZChkYXRhc2V0SWQpO1xuICAgICAgICAgICAgcGF0aCArPSBgLyR7ZGF0YXNldElkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCwgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhc2V0W2lkPSR7ZGF0YXNldElkfSwgbmFtZT0ke2RhdGFzZXROYW1lfV0gbm90IGZvdW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXNwb25zZVswXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIGhhc0RhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW5zdGFuY2VvZi9uby1pbnN0YW5jZW9mXG4gICAgICAgICAgICBlIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgICAgICAgICBlLm1lc3NhZ2UudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5vdCBmb3VuZFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZGlmZkRhdGFzZXRWZXJzaW9ucyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGZyb21WZXJzaW9uLCB0b1ZlcnNpb24sIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkXyAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWUgfSk7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIGZyb21fdmVyc2lvbjogdHlwZW9mIGZyb21WZXJzaW9uID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBmcm9tVmVyc2lvblxuICAgICAgICAgICAgICAgIDogZnJvbVZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIHRvX3ZlcnNpb246IHR5cGVvZiB0b1ZlcnNpb24gPT09IFwic3RyaW5nXCIgPyB0b1ZlcnNpb24gOiB0b1ZlcnNpb24udG9JU09TdHJpbmcoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0KGAvZGF0YXNldHMvJHtkYXRhc2V0SWRffS92ZXJzaW9ucy9kaWZmYCwgdXJsUGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmcoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBcIi9kYXRhc2V0c1wiO1xuICAgICAgICBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZ2V0UmVzcG9uc2UoYCR7cGF0aH0vJHtkYXRhc2V0SWR9L29wZW5haV9mdGApO1xuICAgICAgICBjb25zdCBkYXRhc2V0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRUZXh0XG4gICAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgIC5tYXAoKGxpbmUpID0+IEpTT04ucGFyc2UobGluZSkpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3REYXRhc2V0cyh7IGxpbWl0ID0gMTAwLCBvZmZzZXQgPSAwLCBkYXRhc2V0SWRzLCBkYXRhc2V0TmFtZSwgZGF0YXNldE5hbWVDb250YWlucywgbWV0YWRhdGEsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBsaW1pdDogbGltaXQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LnRvU3RyaW5nKCksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGF0YXNldElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlkXyBvZiBkYXRhc2V0SWRzKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlkXCIsIGlkXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lXCIsIGRhdGFzZXROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldE5hbWVDb250YWlucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZV9jb250YWluc1wiLCBkYXRhc2V0TmFtZUNvbnRhaW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBkYXRhc2V0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQocGF0aCwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGRhdGFzZXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gcHJvcHMgVGhlIGRhdGFzZXQgZGV0YWlscyB0byB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBkYXRhc2V0XG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldChwcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIC4uLnVwZGF0ZSB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2RhdGFzZXRJZCA9IGRhdGFzZXRJZCA/PyAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgYXNzZXJ0VXVpZChfZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHVwZGF0ZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtfZGF0YXNldElkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGRhdGFzZXRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChhd2FpdCByZXNwb25zZS5qc29uKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgdGFnIG9uIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0YWcgaXMgYWxyZWFkeSBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCB2ZXJzaW9uIG9mIHRoaXMgZGF0YXNldCxcbiAgICAgKiB0aGUgdGFnIHdpbGwgYmUgbW92ZWQgdG8gdGhlIG5ldyB2ZXJzaW9uLiBUaGUgYXNfb2YgcGFyYW1ldGVyIGlzIHVzZWQgdG9cbiAgICAgKiBkZXRlcm1pbmUgd2hpY2ggdmVyc2lvbiBvZiB0aGUgZGF0YXNldCB0byBhcHBseSB0aGUgbmV3IHRhZ3MgdG8uXG4gICAgICpcbiAgICAgKiBJdCBtdXN0IGJlIGFuIGV4YWN0IHZlcnNpb24gb2YgdGhlIGRhdGFzZXQgdG8gc3VjY2VlZC4gWW91IGNhblxuICAgICAqIHVzZSB0aGUgXCJyZWFkRGF0YXNldFZlcnNpb25cIiBtZXRob2QgdG8gZmluZCB0aGUgZXhhY3QgdmVyc2lvblxuICAgICAqIHRvIGFwcGx5IHRoZSB0YWdzIHRvLlxuICAgICAqIEBwYXJhbSBwYXJhbXMuZGF0YXNldElkIFRoZSBJRCBvZiB0aGUgZGF0YXNldCB0byB1cGRhdGUuIE11c3QgYmUgcHJvdmlkZWQgaWYgXCJkYXRhc2V0TmFtZVwiIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLmRhdGFzZXROYW1lIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHRvIHVwZGF0ZS4gTXVzdCBiZSBwcm92aWRlZCBpZiBcImRhdGFzZXRJZFwiIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gcGFyYW1zLmFzT2YgVGhlIHRpbWVzdGFtcCBvZiB0aGUgZGF0YXNldCB0byBhcHBseSB0aGUgbmV3IHRhZ3MgdG8uXG4gICAgICogQHBhcmFtIHBhcmFtcy50YWcgVGhlIG5ldyB0YWcgdG8gYXBwbHkgdG8gdGhlIGRhdGFzZXQuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlRGF0YXNldFRhZyhwcm9wcykge1xuICAgICAgICBjb25zdCB7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGFzT2YsIHRhZyB9ID0gcHJvcHM7XG4gICAgICAgIGlmICghZGF0YXNldElkICYmICFkYXRhc2V0TmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2RhdGFzZXRJZCA9IGRhdGFzZXRJZCA/PyAoYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pKS5pZDtcbiAgICAgICAgYXNzZXJ0VXVpZChfZGF0YXNldElkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGFzX29mOiB0eXBlb2YgYXNPZiA9PT0gXCJzdHJpbmdcIiA/IGFzT2YgOiBhc09mLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICB0YWcsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke19kYXRhc2V0SWR9L3RhZ3NgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgZGF0YXNldCB0YWdzXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB9KSB7XG4gICAgICAgIGxldCBwYXRoID0gXCIvZGF0YXNldHNcIjtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgICAgICBwYXRoICs9IGAvJHtkYXRhc2V0SWRffWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2godGhpcy5hcGlVcmwgKyBwYXRoLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBgZGVsZXRlICR7cGF0aH1gLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBpbmRleERhdGFzZXQoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCB0YWcsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGlmICghZGF0YXNldElkXyAmJiAhZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gJiYgZGF0YXNldE5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghZGF0YXNldElkXykge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7ZGF0YXNldElkX30vaW5kZXhgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiaW5kZXggZGF0YXNldFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExldHMgeW91IHJ1biBhIHNpbWlsYXJpdHkgc2VhcmNoIHF1ZXJ5IG9uIGEgZGF0YXNldC5cbiAgICAgKlxuICAgICAqIFJlcXVpcmVzIHRoZSBkYXRhc2V0IHRvIGJlIGluZGV4ZWQuIFBsZWFzZSBzZWUgdGhlIGBpbmRleERhdGFzZXRgIG1ldGhvZCB0byBzZXQgdXAgaW5kZXhpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5wdXRzICAgICAgVGhlIGlucHV0IG9uIHdoaWNoIHRvIHJ1biB0aGUgc2ltaWxhcml0eSBzZWFyY2guIE11c3QgaGF2ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgc2FtZSBzY2hlbWEgYXMgdGhlIGRhdGFzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGF0YXNldElkICAgVGhlIGRhdGFzZXQgdG8gc2VhcmNoIGZvciBzaW1pbGFyIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpbWl0ICAgICAgIFRoZSBtYXhpbXVtIG51bWJlciBvZiBleGFtcGxlcyB0byByZXR1cm4uIFdpbGwgcmV0dXJuIHRoZSB0b3AgYGxpbWl0YCBtb3N0XG4gICAgICogICAgICAgICAgICAgICAgICAgIHNpbWlsYXIgZXhhbXBsZXMgaW4gb3JkZXIgb2YgbW9zdCBzaW1pbGFyIHRvIGxlYXN0IHNpbWlsYXIuIElmIG5vIHNpbWlsYXJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgZXhhbXBsZXMgYXJlIGZvdW5kLCByYW5kb20gZXhhbXBsZXMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgICAgICBBIGZpbHRlciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhlIHNlYXJjaC4gT25seSBleGFtcGxlcyB3aWxsIGJlIHJldHVybmVkIHRoYXRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggdGhlIGZpbHRlciBzdHJpbmcuIFNvbWUgZXhhbXBsZXMgb2YgZmlsdGVyc1xuICAgICAqXG4gICAgICogICAgICAgICAgICAgICAgICAgIC0gZXEobWV0YWRhdGEubXlrZXksIFwidmFsdWVcIilcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBhbmQobmVxKG1ldGFkYXRhLm15Lm5lc3RlZC5rZXksIFwidmFsdWVcIiksIG5lcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSlcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgLSBvcihlcShtZXRhZGF0YS5teWtleSwgXCJ2YWx1ZVwiKSwgZXEobWV0YWRhdGEubXlrZXksIFwib3RoZXJ2YWx1ZVwiKSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zICAgICAgICAgICBBIGxpc3Qgb2Ygc2ltaWxhciBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBkYXRhc2V0X2lkID0gXCIxMjNlNDU2Ny1lODliLTEyZDMtYTQ1Ni00MjY2MTQxNzQwMDBcIlxuICAgICAqIGlucHV0cyA9IHtcInRleHRcIjogXCJIb3cgbWFueSBwZW9wbGUgbGl2ZSBpbiBCZXJsaW4/XCJ9XG4gICAgICogbGltaXQgPSA1XG4gICAgICogZXhhbXBsZXMgPSBhd2FpdCBjbGllbnQuc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldF9pZCwgbGltaXQpXG4gICAgICovXG4gICAgYXN5bmMgc2ltaWxhckV4YW1wbGVzKGlucHV0cywgZGF0YXNldElkLCBsaW1pdCwgeyBmaWx0ZXIsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgaW5wdXRzOiBpbnB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YVtcImZpbHRlclwiXSA9IGZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9kYXRhc2V0cy8ke2RhdGFzZXRJZH0vc2VhcmNoYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImZldGNoIHNpbWlsYXIgZXhhbXBsZXNcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0W1wiZXhhbXBsZXNcIl07XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUV4YW1wbGUoaW5wdXRzT3JVcGRhdGUsIG91dHB1dHMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGlzRXhhbXBsZUNyZWF0ZShpbnB1dHNPclVwZGF0ZSkpIHtcbiAgICAgICAgICAgIGlmIChvdXRwdXRzICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHByb3ZpZGUgb3V0cHV0cyBvciBvcHRpb25zIHdoZW4gdXNpbmcgRXhhbXBsZUNyZWF0ZSBvYmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBvdXRwdXRzID8gb3B0aW9ucz8uZGF0YXNldElkIDogaW5wdXRzT3JVcGRhdGUuZGF0YXNldF9pZDtcbiAgICAgICAgY29uc3QgZGF0YXNldE5hbWVfID0gb3V0cHV0c1xuICAgICAgICAgICAgPyBvcHRpb25zPy5kYXRhc2V0TmFtZVxuICAgICAgICAgICAgOiBpbnB1dHNPclVwZGF0ZS5kYXRhc2V0X25hbWU7XG4gICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZTogZGF0YXNldE5hbWVfIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlZEF0XyA9IChvdXRwdXRzID8gb3B0aW9ucz8uY3JlYXRlZEF0IDogaW5wdXRzT3JVcGRhdGUuY3JlYXRlZF9hdCkgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmICghaXNFeGFtcGxlQ3JlYXRlKGlucHV0c09yVXBkYXRlKSkge1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICBpbnB1dHM6IGlucHV0c09yVXBkYXRlLFxuICAgICAgICAgICAgICAgIG91dHB1dHMsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9hdDogY3JlYXRlZEF0Xz8udG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBpZDogb3B0aW9ucz8uZXhhbXBsZUlkLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zPy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzcGxpdDogb3B0aW9ucz8uc3BsaXQsXG4gICAgICAgICAgICAgICAgc291cmNlX3J1bl9pZDogb3B0aW9ucz8uc291cmNlUnVuSWQsXG4gICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5faW86IG9wdGlvbnM/LnVzZVNvdXJjZVJ1bklPLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiBvcHRpb25zPy51c2VTb3VyY2VSdW5BdHRhY2htZW50cyxcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50czogb3B0aW9ucz8uYXR0YWNobWVudHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGlucHV0c09yVXBkYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgW2RhdGFdKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUocmVzcG9uc2UuZXhhbXBsZV9pZHM/LlswXSA/PyB1dWlkLnY0KCkpO1xuICAgICAgICByZXR1cm4gZXhhbXBsZTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRXhhbXBsZXMocHJvcHNPclVwbG9hZHMpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHNPclVwbG9hZHMpKSB7XG4gICAgICAgICAgICBpZiAocHJvcHNPclVwbG9hZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXBsb2FkcyA9IHByb3BzT3JVcGxvYWRzO1xuICAgICAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSB1cGxvYWRzWzBdLmRhdGFzZXRfaWQ7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0TmFtZV8gPSB1cGxvYWRzWzBdLmRhdGFzZXRfbmFtZTtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZV8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZF8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkXywgdXBsb2Fkcyk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlcyA9IGF3YWl0IFByb21pc2UuYWxsKHJlc3BvbnNlLmV4YW1wbGVfaWRzLm1hcCgoaWQpID0+IHRoaXMucmVhZEV4YW1wbGUoaWQpKSk7XG4gICAgICAgICAgICByZXR1cm4gZXhhbXBsZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpbnB1dHMsIG91dHB1dHMsIG1ldGFkYXRhLCBzcGxpdHMsIHNvdXJjZVJ1bklkcywgdXNlU291cmNlUnVuSU9zLCB1c2VTb3VyY2VSdW5BdHRhY2htZW50cywgYXR0YWNobWVudHMsIGV4YW1wbGVJZHMsIGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIH0gPSBwcm9wc09yVXBsb2FkcztcbiAgICAgICAgaWYgKGlucHV0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgaW5wdXRzIHdoZW4gdXNpbmcgbGVnYWN5IHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIGNvbnN0IGRhdGFzZXROYW1lXyA9IGRhdGFzZXROYW1lO1xuICAgICAgICBpZiAoZGF0YXNldElkXyA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWVfICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWRfID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCB0aGlzLnJlYWREYXRhc2V0KHsgZGF0YXNldE5hbWU6IGRhdGFzZXROYW1lXyB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZEV4YW1wbGVzID0gaW5wdXRzLm1hcCgoaW5wdXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0X2lkOiBkYXRhc2V0SWRfLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0czogb3V0cHV0cz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhPy5baWR4XSxcbiAgICAgICAgICAgICAgICBzcGxpdDogc3BsaXRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBpZDogZXhhbXBsZUlkcz8uW2lkeF0sXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzPy5baWR4XSxcbiAgICAgICAgICAgICAgICBzb3VyY2VfcnVuX2lkOiBzb3VyY2VSdW5JZHM/LltpZHhdLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiB1c2VTb3VyY2VSdW5JT3M/LltpZHhdLFxuICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzOiB1c2VTb3VyY2VSdW5BdHRhY2htZW50cz8uW2lkeF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWRfLCBmb3JtYXR0ZWRFeGFtcGxlcyk7XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2UuZXhhbXBsZV9pZHMubWFwKChpZCkgPT4gdGhpcy5yZWFkRXhhbXBsZShpZCkpKTtcbiAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVMTE1FeGFtcGxlKGlucHV0LCBnZW5lcmF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4YW1wbGUoeyBpbnB1dCB9LCB7IG91dHB1dDogZ2VuZXJhdGlvbiB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ2hhdEV4YW1wbGUoaW5wdXQsIGdlbmVyYXRpb25zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsSW5wdXQgPSBpbnB1dC5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0xhbmdDaGFpbk1lc3NhZ2UobWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGZpbmFsT3V0cHV0ID0gaXNMYW5nQ2hhaW5NZXNzYWdlKGdlbmVyYXRpb25zKVxuICAgICAgICAgICAgPyBjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZShnZW5lcmF0aW9ucylcbiAgICAgICAgICAgIDogZ2VuZXJhdGlvbnM7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUV4YW1wbGUoeyBpbnB1dDogZmluYWxJbnB1dCB9LCB7IG91dHB1dDogZmluYWxPdXRwdXQgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRFeGFtcGxlKGV4YW1wbGVJZCkge1xuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2V4YW1wbGVzLyR7ZXhhbXBsZUlkfWA7XG4gICAgICAgIGNvbnN0IHJhd0V4YW1wbGUgPSBhd2FpdCB0aGlzLl9nZXQocGF0aCk7XG4gICAgICAgIGNvbnN0IHsgYXR0YWNobWVudF91cmxzLCAuLi5yZXN0IH0gPSByYXdFeGFtcGxlO1xuICAgICAgICBjb25zdCBleGFtcGxlID0gcmVzdDtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnRfdXJscykge1xuICAgICAgICAgICAgZXhhbXBsZS5hdHRhY2htZW50cyA9IE9iamVjdC5lbnRyaWVzKGF0dGFjaG1lbnRfdXJscykucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1trZXkuc2xpY2UoXCJhdHRhY2htZW50LlwiLmxlbmd0aCldID0ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzaWduZWRfdXJsOiB2YWx1ZS5wcmVzaWduZWRfdXJsLFxuICAgICAgICAgICAgICAgICAgICBtaW1lX3R5cGU6IHZhbHVlLm1pbWVfdHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4YW1wbGU7XG4gICAgfVxuICAgIGFzeW5jICpsaXN0RXhhbXBsZXMoeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBleGFtcGxlSWRzLCBhc09mLCBzcGxpdHMsIGlubGluZVMzVXJscywgbWV0YWRhdGEsIGxpbWl0LCBvZmZzZXQsIGZpbHRlciwgaW5jbHVkZUF0dGFjaG1lbnRzLCB9ID0ge30pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgIT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZWl0aGVyIGRhdGFzZXROYW1lIG9yIGRhdGFzZXRJZCwgbm90IGJvdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGEgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoeyBkYXRhc2V0OiBkYXRhc2V0SWRfIH0pO1xuICAgICAgICBjb25zdCBkYXRhc2V0X3ZlcnNpb24gPSBhc09mXG4gICAgICAgICAgICA/IHR5cGVvZiBhc09mID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBhc09mXG4gICAgICAgICAgICAgICAgOiBhc09mPy50b0lTT1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGRhdGFzZXRfdmVyc2lvbikge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImFzX29mXCIsIGRhdGFzZXRfdmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5saW5lUzNVcmxzXyA9IGlubGluZVMzVXJscyA/PyB0cnVlO1xuICAgICAgICBwYXJhbXMuYXBwZW5kKFwiaW5saW5lX3MzX3VybHNcIiwgaW5saW5lUzNVcmxzXy50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKGV4YW1wbGVJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZF8gb2YgZXhhbXBsZUlkcykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZFwiLCBpZF8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzcGxpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzcGxpdCBvZiBzcGxpdHMpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwic3BsaXRzXCIsIHNwbGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE1ldGFkYXRhID0gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcIm1ldGFkYXRhXCIsIHNlcmlhbGl6ZWRNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCBsaW1pdC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJvZmZzZXRcIiwgb2Zmc2V0LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImZpbHRlclwiLCBmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlQXR0YWNobWVudHMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIFtcImF0dGFjaG1lbnRfdXJsc1wiLCBcIm91dHB1dHNcIiwgXCJtZXRhZGF0YVwiXS5mb3JFYWNoKChmaWVsZCkgPT4gcGFyYW1zLmFwcGVuZChcInNlbGVjdFwiLCBmaWVsZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCByYXdFeGFtcGxlcyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvZXhhbXBsZXNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByYXdFeGFtcGxlIG9mIHJhd0V4YW1wbGVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdHRhY2htZW50X3VybHMsIC4uLnJlc3QgfSA9IHJhd0V4YW1wbGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGF0dGFjaG1lbnRfdXJscykge1xuICAgICAgICAgICAgICAgICAgICBleGFtcGxlLmF0dGFjaG1lbnRzID0gT2JqZWN0LmVudHJpZXMoYXR0YWNobWVudF91cmxzKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nba2V5LnNsaWNlKFwiYXR0YWNobWVudC5cIi5sZW5ndGgpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzaWduZWRfdXJsOiB2YWx1ZS5wcmVzaWduZWRfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVfdHlwZTogdmFsdWUubWltZV90eXBlIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIGV4YW1wbGU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgaSA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUV4YW1wbGUoZXhhbXBsZUlkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZXhhbXBsZUlkKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvZXhhbXBsZXMvJHtleGFtcGxlSWR9YDtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh0aGlzLmFwaVVybCArIHBhdGgsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIGBkZWxldGUgJHtwYXRofWAsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBtdWx0aXBsZSBleGFtcGxlcyBieSBJRC5cbiAgICAgKiBAcGFyYW0gZXhhbXBsZUlkcyAtIFRoZSBJRHMgb2YgdGhlIGV4YW1wbGVzIHRvIGRlbGV0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgZm9yIGRlbGV0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGFyZERlbGV0ZSAtIElmIHRydWUsIHBlcm1hbmVudGx5IGRlbGV0ZSBleGFtcGxlcy4gSWYgZmFsc2UgKGRlZmF1bHQpLCBzb2Z0IGRlbGV0ZSB0aGVtLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZUV4YW1wbGVzKGV4YW1wbGVJZHMsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgYWxsIFVVSURzXG4gICAgICAgIGV4YW1wbGVJZHMuZm9yRWFjaCgoaWQpID0+IGFzc2VydFV1aWQoaWQpKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmhhcmREZWxldGUpIHtcbiAgICAgICAgICAgIC8vIEhhcmQgZGVsZXRlIHVzZXMgUE9TVCB0byBhIGRpZmZlcmVudCBwbGF0Zm9ybSBlbmRwb2ludFxuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuX2dldFBsYXRmb3JtRW5kcG9pbnRQYXRoKFwiZGF0YXNldHMvZXhhbXBsZXMvZGVsZXRlXCIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHtwYXRofWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YW1wbGVfaWRzOiBleGFtcGxlSWRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFyZF9kZWxldGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImhhcmQgZGVsZXRlIGV4YW1wbGVzXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNvZnQgZGVsZXRlIHVzZXMgREVMRVRFIHdpdGggcXVlcnkgcGFyYW1zXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICBleGFtcGxlSWRzLmZvckVhY2goKGlkKSA9PiBwYXJhbXMuYXBwZW5kKFwiZXhhbXBsZV9pZHNcIiwgaWQpKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9leGFtcGxlcz8ke3BhcmFtcy50b1N0cmluZygpfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZGVsZXRlIGV4YW1wbGVzXCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB1cGRhdGVFeGFtcGxlKGV4YW1wbGVJZE9yVXBkYXRlLCB1cGRhdGUpIHtcbiAgICAgICAgbGV0IGV4YW1wbGVJZDtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgZXhhbXBsZUlkID0gZXhhbXBsZUlkT3JVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGFtcGxlSWQgPSBleGFtcGxlSWRPclVwZGF0ZS5pZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGV4YW1wbGVJZCk7XG4gICAgICAgIGxldCB1cGRhdGVUb1VzZTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdXBkYXRlVG9Vc2UgPSB7IGlkOiBleGFtcGxlSWQsIC4uLnVwZGF0ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlVG9Vc2UgPSBleGFtcGxlSWRPclVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YXNldElkO1xuICAgICAgICBpZiAodXBkYXRlVG9Vc2UuZGF0YXNldF9pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0SWQgPSB1cGRhdGVUb1VzZS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZSA9IGF3YWl0IHRoaXMucmVhZEV4YW1wbGUoZXhhbXBsZUlkKTtcbiAgICAgICAgICAgIGRhdGFzZXRJZCA9IGV4YW1wbGUuZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCBbdXBkYXRlVG9Vc2VdKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRXhhbXBsZXModXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIHdpbGwgbmFpdmVseSBnZXQgZGF0YXNldCBpZCBmcm9tIGZpcnN0IGV4YW1wbGUgYW5kIGFzc3VtZSBpdCB3b3JrcyBmb3IgYWxsXG4gICAgICAgIGxldCBkYXRhc2V0SWQ7XG4gICAgICAgIGlmICh1cGRhdGVbMF0uZGF0YXNldF9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlID0gYXdhaXQgdGhpcy5yZWFkRXhhbXBsZSh1cGRhdGVbMF0uaWQpO1xuICAgICAgICAgICAgZGF0YXNldElkID0gZXhhbXBsZS5kYXRhc2V0X2lkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkID0gdXBkYXRlWzBdLmRhdGFzZXRfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGRhdGFzZXQgdmVyc2lvbiBieSBjbG9zZXN0IGRhdGUgb3IgZXhhY3QgdGFnLlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgdG8gcmVzb2x2ZSB0aGUgbmVhcmVzdCB2ZXJzaW9uIHRvIGEgZ2l2ZW4gdGltZXN0YW1wIG9yIGZvciBhIGdpdmVuIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBkYXRhc2V0IHZlcnNpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhc2V0SWQgVGhlIElEIG9mIHRoZSBkYXRhc2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGF0YXNldE5hbWUgVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc09mIFRoZSB0aW1lc3RhbXAgb2YgdGhlIGRhdGFzZXQgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50YWcgVGhlIHRhZyBvZiB0aGUgZGF0YXNldCB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRhc2V0IHZlcnNpb25cbiAgICAgKi9cbiAgICBhc3luYyByZWFkRGF0YXNldFZlcnNpb24oeyBkYXRhc2V0SWQsIGRhdGFzZXROYW1lLCBhc09mLCB0YWcsIH0pIHtcbiAgICAgICAgbGV0IHJlc29sdmVkRGF0YXNldElkO1xuICAgICAgICBpZiAoIWRhdGFzZXRJZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIHJlc29sdmVkRGF0YXNldElkID0gZGF0YXNldC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkRGF0YXNldElkID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQocmVzb2x2ZWREYXRhc2V0SWQpO1xuICAgICAgICBpZiAoKGFzT2YgJiYgdGFnKSB8fCAoIWFzT2YgJiYgIXRhZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4YWN0bHkgb25lIG9mIGFzT2YgYW5kIHRhZyBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICBpZiAoYXNPZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCIgPyBhc09mIDogYXNPZi50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzLyR7cmVzb2x2ZWREYXRhc2V0SWR9L3ZlcnNpb24/JHtwYXJhbXMudG9TdHJpbmcoKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJyZWFkIGRhdGFzZXQgdmVyc2lvblwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0RGF0YXNldFNwbGl0cyh7IGRhdGFzZXRJZCwgZGF0YXNldE5hbWUsIGFzT2YsIH0pIHtcbiAgICAgICAgbGV0IGRhdGFzZXRJZF87XG4gICAgICAgIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCAmJiBkYXRhc2V0TmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHByb3ZpZGUgZGF0YXNldCBuYW1lIG9yIElEXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCAhPT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBlaXRoZXIgZGF0YXNldE5hbWUgb3IgZGF0YXNldElkLCBub3QgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhc2V0SWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldCA9IGF3YWl0IHRoaXMucmVhZERhdGFzZXQoeyBkYXRhc2V0TmFtZSB9KTtcbiAgICAgICAgICAgIGRhdGFzZXRJZF8gPSBkYXRhc2V0LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRVdWlkKGRhdGFzZXRJZF8pO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRfdmVyc2lvbiA9IGFzT2ZcbiAgICAgICAgICAgID8gdHlwZW9mIGFzT2YgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IGFzT2ZcbiAgICAgICAgICAgICAgICA6IGFzT2Y/LnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGF0YXNldF92ZXJzaW9uKSB7XG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwiYXNfb2ZcIiwgZGF0YXNldF92ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChgL2RhdGFzZXRzLyR7ZGF0YXNldElkX30vc3BsaXRzYCwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVEYXRhc2V0U3BsaXRzKHsgZGF0YXNldElkLCBkYXRhc2V0TmFtZSwgc3BsaXROYW1lLCBleGFtcGxlSWRzLCByZW1vdmUgPSBmYWxzZSwgfSkge1xuICAgICAgICBsZXQgZGF0YXNldElkXztcbiAgICAgICAgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkICYmIGRhdGFzZXROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3QgcHJvdmlkZSBkYXRhc2V0IG5hbWUgb3IgSURcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YXNldElkICE9PSB1bmRlZmluZWQgJiYgZGF0YXNldE5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBwcm92aWRlIGVpdGhlciBkYXRhc2V0TmFtZSBvciBkYXRhc2V0SWQsIG5vdCBib3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGFzZXRJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5yZWFkRGF0YXNldCh7IGRhdGFzZXROYW1lIH0pO1xuICAgICAgICAgICAgZGF0YXNldElkXyA9IGRhdGFzZXQuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhc2V0SWRfID0gZGF0YXNldElkO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFV1aWQoZGF0YXNldElkXyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBzcGxpdF9uYW1lOiBzcGxpdE5hbWUsXG4gICAgICAgICAgICBleGFtcGxlczogZXhhbXBsZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VXVpZChpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZW1vdmUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZGF0YXNldHMvJHtkYXRhc2V0SWRffS9zcGxpdHNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBVVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgZGF0YXNldCBzcGxpdHNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRmVlZGJhY2socnVuSWQsIGtleSwgeyBzY29yZSwgdmFsdWUsIGNvcnJlY3Rpb24sIGNvbW1lbnQsIHNvdXJjZUluZm8sIGZlZWRiYWNrU291cmNlVHlwZSA9IFwiYXBpXCIsIHNvdXJjZVJ1bklkLCBmZWVkYmFja0lkLCBmZWVkYmFja0NvbmZpZywgcHJvamVjdElkLCBjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCwgfSkge1xuICAgICAgICBpZiAoIXJ1bklkICYmICFwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuSWQgJiYgcHJvamVjdElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPbmx5IG9uZSBvZiBydW5JZCBvciBwcm9qZWN0SWQgY2FuIGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZlZWRiYWNrX3NvdXJjZSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGZlZWRiYWNrU291cmNlVHlwZSA/PyBcImFwaVwiLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHNvdXJjZUluZm8gPz8ge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzb3VyY2VSdW5JZCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2U/Lm1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICFmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXSkge1xuICAgICAgICAgICAgZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0gPSB7IHJ1bl9pZDogc291cmNlUnVuSWQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tfc291cmNlPy5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICBmZWVkYmFja19zb3VyY2UubWV0YWRhdGFbXCJfX3J1blwiXT8ucnVuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tfc291cmNlLm1ldGFkYXRhW1wiX19ydW5cIl0ucnVuX2lkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgIGlkOiBmZWVkYmFja0lkID8/IHV1aWQudjQoKSxcbiAgICAgICAgICAgIHJ1bl9pZDogcnVuSWQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzY29yZTogX2Zvcm1hdEZlZWRiYWNrU2NvcmUoc2NvcmUpLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjb3JyZWN0aW9uLFxuICAgICAgICAgICAgY29tbWVudCxcbiAgICAgICAgICAgIGZlZWRiYWNrX3NvdXJjZTogZmVlZGJhY2tfc291cmNlLFxuICAgICAgICAgICAgY29tcGFyYXRpdmVfZXhwZXJpbWVudF9pZDogY29tcGFyYXRpdmVFeHBlcmltZW50SWQsXG4gICAgICAgICAgICBmZWVkYmFja0NvbmZpZyxcbiAgICAgICAgICAgIHNlc3Npb25faWQ6IHByb2plY3RJZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5hcGlVcmx9L2ZlZWRiYWNrYDtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgZmVlZGJhY2tcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlZWRiYWNrO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVGZWVkYmFjayhmZWVkYmFja0lkLCB7IHNjb3JlLCB2YWx1ZSwgY29ycmVjdGlvbiwgY29tbWVudCwgfSkge1xuICAgICAgICBjb25zdCBmZWVkYmFja1VwZGF0ZSA9IHt9O1xuICAgICAgICBpZiAoc2NvcmUgIT09IHVuZGVmaW5lZCAmJiBzY29yZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJzY29yZVwiXSA9IF9mb3JtYXRGZWVkYmFja1Njb3JlKHNjb3JlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJ2YWx1ZVwiXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3JyZWN0aW9uICE9PSB1bmRlZmluZWQgJiYgY29ycmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmVlZGJhY2tVcGRhdGVbXCJjb3JyZWN0aW9uXCJdID0gY29ycmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkICYmIGNvbW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZlZWRiYWNrVXBkYXRlW1wiY29tbWVudFwiXSA9IGNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VXVpZChmZWVkYmFja0lkKTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZlZWRiYWNrVXBkYXRlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vZmVlZGJhY2svJHtmZWVkYmFja0lkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIGZlZWRiYWNrXCIsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlYWRGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldChwYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGZWVkYmFjayhmZWVkYmFja0lkKSB7XG4gICAgICAgIGFzc2VydFV1aWQoZmVlZGJhY2tJZCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL2ZlZWRiYWNrLyR7ZmVlZGJhY2tJZH1gO1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKHRoaXMuYXBpVXJsICsgcGF0aCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYGRlbGV0ZSAke3BhdGh9YCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RGZWVkYmFjayh7IHJ1bklkcywgZmVlZGJhY2tLZXlzLCBmZWVkYmFja1NvdXJjZVR5cGVzLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIGlmIChydW5JZHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcnVuSWQgb2YgcnVuSWRzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VXVpZChydW5JZCk7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuYXBwZW5kKFwicnVuXCIsIHJ1bklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tLZXlzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkYmFja0tleXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJrZXlcIiwga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmVlZGJhY2tTb3VyY2VUeXBlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIGZlZWRiYWNrU291cmNlVHlwZXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoXCJzb3VyY2VcIiwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBmZWVkYmFja3Mgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2ZlZWRiYWNrXCIsIHF1ZXJ5UGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIGZlZWRiYWNrcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJlc2lnbmVkIGZlZWRiYWNrIHRva2VuIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBUaGUgdG9rZW4gY2FuIGJlIHVzZWQgdG8gYXV0aG9yaXplIGZlZWRiYWNrIG1ldHJpY3Mgd2l0aG91dFxuICAgICAqIG5lZWRpbmcgYW4gQVBJIGtleS4gVGhpcyBpcyB1c2VmdWwgZm9yIGdpdmluZyBicm93c2VyLWJhc2VkXG4gICAgICogYXBwbGljYXRpb25zIHRoZSBhYmlsaXR5IHRvIHN1Ym1pdCBmZWVkYmFjayB3aXRob3V0IG5lZWRpbmdcbiAgICAgKiB0byBleHBvc2UgYW4gQVBJIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcGFyYW0gZmVlZGJhY2tLZXkgVGhlIGZlZWRiYWNrIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5leHBpcmF0aW9uIFRoZSBleHBpcmF0aW9uIHRpbWUgZm9yIHRoZSB0b2tlbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgRmVlZGJhY2tJbmdlc3RUb2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQcmVzaWduZWRGZWVkYmFja1Rva2VuKHJ1bklkLCBmZWVkYmFja0tleSwgeyBleHBpcmF0aW9uLCBmZWVkYmFja0NvbmZpZywgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBydW5faWQ6IHJ1bklkLFxuICAgICAgICAgICAgZmVlZGJhY2tfa2V5OiBmZWVkYmFja0tleSxcbiAgICAgICAgICAgIGZlZWRiYWNrX2NvbmZpZzogZmVlZGJhY2tDb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChleHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4cGlyYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19hdFwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHBpcmF0aW9uPy5ob3VycyB8fCBleHBpcmF0aW9uPy5taW51dGVzIHx8IGV4cGlyYXRpb24/LmRheXMpIHtcbiAgICAgICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IGV4cGlyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5W1wiZXhwaXJlc19pblwiXSA9IHtcbiAgICAgICAgICAgICAgICBob3VyczogMyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZEJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9mZWVkYmFjay90b2tlbnNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBwcmVzaWduZWQgZmVlZGJhY2sgdG9rZW5cIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29tcGFyYXRpdmVFeHBlcmltZW50KHsgbmFtZSwgZXhwZXJpbWVudElkcywgcmVmZXJlbmNlRGF0YXNldElkLCBjcmVhdGVkQXQsIGRlc2NyaXB0aW9uLCBtZXRhZGF0YSwgaWQsIH0pIHtcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZXhwZXJpbWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZURhdGFzZXRJZCkge1xuICAgICAgICAgICAgcmVmZXJlbmNlRGF0YXNldElkID0gKGF3YWl0IHRoaXMucmVhZFByb2plY3Qoe1xuICAgICAgICAgICAgICAgIHByb2plY3RJZDogZXhwZXJpbWVudElkc1swXSxcbiAgICAgICAgICAgIH0pKS5yZWZlcmVuY2VfZGF0YXNldF9pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlZmVyZW5jZURhdGFzZXRJZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHJlZmVyZW5jZSBkYXRhc2V0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBleHBlcmltZW50X2lkczogZXhwZXJpbWVudElkcyxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9kYXRhc2V0X2lkOiByZWZlcmVuY2VEYXRhc2V0SWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IChjcmVhdGVkQXQgPz8gbmV3IERhdGUoKSk/LnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YSlcbiAgICAgICAgICAgIGJvZHkuZXh0cmFbXCJtZXRhZGF0YVwiXSA9IG1ldGFkYXRhO1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2RhdGFzZXRzL2NvbXBhcmF0aXZlYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogc2VyaWFsaXplZEJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgY29tcGFyYXRpdmUgZXhwZXJpbWVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIHByZXNpZ25lZCBmZWVkYmFjayB0b2tlbnMgZm9yIGEgZ2l2ZW4gcnVuIElELlxuICAgICAqIEBwYXJhbSBydW5JZCBUaGUgSUQgb2YgdGhlIHJ1bi5cbiAgICAgKiBAcmV0dXJucyBBbiBhc3luYyBpdGVyYWJsZSBvZiBGZWVkYmFja0luZ2VzdFRva2VuIG9iamVjdHMuXG4gICAgICovXG4gICAgYXN5bmMgKmxpc3RQcmVzaWduZWRGZWVkYmFja1Rva2VucyhydW5JZCkge1xuICAgICAgICBhc3NlcnRVdWlkKHJ1bklkKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7IHJ1bl9pZDogcnVuSWQgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdG9rZW5zIG9mIHRoaXMuX2dldFBhZ2luYXRlZChcIi9mZWVkYmFjay90b2tlbnNcIiwgcGFyYW1zKSkge1xuICAgICAgICAgICAgeWllbGQqIHRva2VucztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2VsZWN0RXZhbFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICBsZXQgcmVzdWx0c187XG4gICAgICAgIGlmIChcInJlc3VsdHNcIiBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHMucmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IHJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzXyA9IFtyZXN1bHRzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0c187XG4gICAgfVxuICAgIGFzeW5jIF9sb2dFdmFsdWF0aW9uRmVlZGJhY2soZXZhbHVhdG9yUmVzcG9uc2UsIHJ1biwgc291cmNlSW5mbykge1xuICAgICAgICBjb25zdCBldmFsUmVzdWx0cyA9IHRoaXMuX3NlbGVjdEV2YWxSZXN1bHRzKGV2YWx1YXRvclJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgZmVlZGJhY2tzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIGV2YWxSZXN1bHRzKSB7XG4gICAgICAgICAgICBsZXQgc291cmNlSW5mb18gPSBzb3VyY2VJbmZvIHx8IHt9O1xuICAgICAgICAgICAgaWYgKHJlcy5ldmFsdWF0b3JJbmZvKSB7XG4gICAgICAgICAgICAgICAgc291cmNlSW5mb18gPSB7IC4uLnJlcy5ldmFsdWF0b3JJbmZvLCAuLi5zb3VyY2VJbmZvXyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJ1bklkXyA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzLnRhcmdldFJ1bklkKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcmVzLnRhcmdldFJ1bklkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocnVuKSB7XG4gICAgICAgICAgICAgICAgcnVuSWRfID0gcnVuLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmVlZGJhY2tzLnB1c2goYXdhaXQgdGhpcy5jcmVhdGVGZWVkYmFjayhydW5JZF8sIHJlcy5rZXksIHtcbiAgICAgICAgICAgICAgICBzY29yZTogcmVzLnNjb3JlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXMudmFsdWUsXG4gICAgICAgICAgICAgICAgY29tbWVudDogcmVzLmNvbW1lbnQsXG4gICAgICAgICAgICAgICAgY29ycmVjdGlvbjogcmVzLmNvcnJlY3Rpb24sXG4gICAgICAgICAgICAgICAgc291cmNlSW5mbzogc291cmNlSW5mb18sXG4gICAgICAgICAgICAgICAgc291cmNlUnVuSWQ6IHJlcy5zb3VyY2VSdW5JZCxcbiAgICAgICAgICAgICAgICBmZWVkYmFja0NvbmZpZzogcmVzLmZlZWRiYWNrQ29uZmlnLFxuICAgICAgICAgICAgICAgIGZlZWRiYWNrU291cmNlVHlwZTogXCJtb2RlbFwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXZhbFJlc3VsdHMsIGZlZWRiYWNrc107XG4gICAgfVxuICAgIGFzeW5jIGxvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKSB7XG4gICAgICAgIGNvbnN0IFtyZXN1bHRzXSA9IGF3YWl0IHRoaXMuX2xvZ0V2YWx1YXRpb25GZWVkYmFjayhldmFsdWF0b3JSZXNwb25zZSwgcnVuLCBzb3VyY2VJbmZvKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFQSSBmb3IgbWFuYWdpbmcgYW5ub3RhdGlvbiBxdWV1ZXNcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBMaXN0IHRoZSBhbm5vdGF0aW9uIHF1ZXVlcyBvbiB0aGUgTGFuZ1NtaXRoIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBsaXN0aW5nIGFubm90YXRpb24gcXVldWVzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZHMgLSBUaGUgSURzIG9mIHRoZSBxdWV1ZXMgdG8gZmlsdGVyIGJ5XG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBxdWV1ZSB0byBmaWx0ZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lQ29udGFpbnMgLSBUaGUgc3Vic3RyaW5nIHRoYXQgdGhlIHF1ZXVlIG5hbWUgc2hvdWxkIGNvbnRhaW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBxdWV1ZXMgdG8gcmV0dXJuXG4gICAgICogQHJldHVybnMgQW4gaXRlcmF0b3Igb2YgQW5ub3RhdGlvblF1ZXVlIG9iamVjdHNcbiAgICAgKi9cbiAgICBhc3luYyAqbGlzdEFubm90YXRpb25RdWV1ZXMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVJZHMsIG5hbWUsIG5hbWVDb250YWlucywgbGltaXQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgaWYgKHF1ZXVlSWRzKSB7XG4gICAgICAgICAgICBxdWV1ZUlkcy5mb3JFYWNoKChpZCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydFV1aWQoaWQsIGBxdWV1ZUlkc1ske2l9XWApO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJpZHNcIiwgaWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICBwYXJhbXMuYXBwZW5kKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVDb250YWlucylcbiAgICAgICAgICAgIHBhcmFtcy5hcHBlbmQoXCJuYW1lX2NvbnRhaW5zXCIsIG5hbWVDb250YWlucyk7XG4gICAgICAgIHBhcmFtcy5hcHBlbmQoXCJsaW1pdFwiLCAobGltaXQgIT09IHVuZGVmaW5lZCA/IE1hdGgubWluKGxpbWl0LCAxMDApIDogMTAwKS50b1N0cmluZygpKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBxdWV1ZXMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKFwiL2Fubm90YXRpb24tcXVldWVzXCIsIHBhcmFtcykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBxdWV1ZXM7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQgJiYgY291bnQgPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFubm90YXRpb24gcXVldWUgb24gdGhlIExhbmdTbWl0aCBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgYW4gYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIEFubm90YXRpb25RdWV1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVBbm5vdGF0aW9uUXVldWUob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRlc2NyaXB0aW9uLCBxdWV1ZUlkLCBydWJyaWNJbnN0cnVjdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBpZDogcXVldWVJZCB8fCB1dWlkLnY0KCksXG4gICAgICAgICAgICBydWJyaWNfaW5zdHJ1Y3Rpb25zOiBydWJyaWNJbnN0cnVjdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGJvZHkpLmZpbHRlcigoW18sIHZdKSA9PiB2ICE9PSB1bmRlZmluZWQpKSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gcmVhZFxuICAgICAqIEByZXR1cm5zIFRoZSBBbm5vdGF0aW9uUXVldWVXaXRoRGV0YWlscyBvYmplY3RcbiAgICAgKi9cbiAgICBhc3luYyByZWFkQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicmVhZCBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byB1cGRhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB1cGRhdGluZyB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmV3IG5hbWUgZm9yIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzY3JpcHRpb24gLSBUaGUgbmV3IGRlc2NyaXB0aW9uIGZvciB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgZGVzY3JpcHRpb24sIHJ1YnJpY0luc3RydWN0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHJ1YnJpY19pbnN0cnVjdGlvbnM6IHJ1YnJpY0luc3RydWN0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQQVRDSFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgYW5ub3RhdGlvbiBxdWV1ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYW4gYW5ub3RhdGlvbiBxdWV1ZSB3aXRoIHRoZSBzcGVjaWZpZWQgcXVldWUgSUQuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWUgdG8gZGVsZXRlXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkRFTEVURVwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBBY2NlcHQ6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJkZWxldGUgYW5ub3RhdGlvbiBxdWV1ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgcnVucyB0byBhbiBhbm5vdGF0aW9uIHF1ZXVlIHdpdGggdGhlIHNwZWNpZmllZCBxdWV1ZSBJRC5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqIEBwYXJhbSBydW5JZHMgLSBUaGUgSURzIG9mIHRoZSBydW5zIHRvIGJlIGFkZGVkIHRvIHRoZSBhbm5vdGF0aW9uIHF1ZXVlXG4gICAgICovXG4gICAgYXN5bmMgYWRkUnVuc1RvQW5ub3RhdGlvblF1ZXVlKHF1ZXVlSWQsIHJ1bklkcykge1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkocnVuSWRzLm1hcCgoaWQsIGkpID0+IGFzc2VydFV1aWQoaWQsIGBydW5JZHNbJHtpfV1gKS50b1N0cmluZygpKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2Fubm90YXRpb24tcXVldWVzLyR7YXNzZXJ0VXVpZChxdWV1ZUlkLCBcInF1ZXVlSWRcIil9L3J1bnNgLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiYWRkIHJ1bnMgdG8gYW5ub3RhdGlvbiBxdWV1ZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBydW4gZnJvbSBhbiBhbm5vdGF0aW9uIHF1ZXVlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHJ1biB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgUnVuV2l0aEFubm90YXRpb25RdWV1ZUluZm8gb2JqZWN0XG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBydW4gaXMgbm90IGZvdW5kIGF0IHRoZSBnaXZlbiBpbmRleCBvciBmb3Igb3RoZXIgQVBJLXJlbGF0ZWQgZXJyb3JzXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UnVuRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkLCBpbmRleCkge1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gYC9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5gO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9JHtiYXNlVXJsfS8ke2luZGV4fWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZ2V0IHJ1biBmcm9tIGFubm90YXRpb24gcXVldWVcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgcnVuIGZyb20gYW4gYW4gYW5ub3RhdGlvbiBxdWV1ZS5cbiAgICAgKiBAcGFyYW0gcXVldWVJZCAtIFRoZSBJRCBvZiB0aGUgYW5ub3RhdGlvbiBxdWV1ZSB0byBkZWxldGUgdGhlIHJ1biBmcm9tXG4gICAgICogQHBhcmFtIHF1ZXVlUnVuSWQgLSBUaGUgSUQgb2YgdGhlIHJ1biB0byBkZWxldGUgZnJvbSB0aGUgYW5ub3RhdGlvbiBxdWV1ZVxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVJ1bkZyb21Bbm5vdGF0aW9uUXVldWUocXVldWVJZCwgcXVldWVSdW5JZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9hbm5vdGF0aW9uLXF1ZXVlcy8ke2Fzc2VydFV1aWQocXVldWVJZCwgXCJxdWV1ZUlkXCIpfS9ydW5zLyR7YXNzZXJ0VXVpZChxdWV1ZVJ1bklkLCBcInF1ZXVlUnVuSWRcIil9YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJERUxFVEVcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IC4uLnRoaXMuaGVhZGVycywgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZGVsZXRlIHJ1biBmcm9tIGFubm90YXRpb24gcXVldWVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzaXplIG9mIGFuIGFubm90YXRpb24gcXVldWUuXG4gICAgICogQHBhcmFtIHF1ZXVlSWQgLSBUaGUgSUQgb2YgdGhlIGFubm90YXRpb24gcXVldWVcbiAgICAgKi9cbiAgICBhc3luYyBnZXRTaXplRnJvbUFubm90YXRpb25RdWV1ZShxdWV1ZUlkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vYW5ub3RhdGlvbi1xdWV1ZXMvJHthc3NlcnRVdWlkKHF1ZXVlSWQsIFwicXVldWVJZFwiKX0vc2l6ZWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZ2V0IHNpemUgZnJvbSBhbm5vdGF0aW9uIHF1ZXVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFzeW5jIF9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHRoaXMuX2dldFNldHRpbmdzKCk7XG4gICAgICAgIHJldHVybiBvd25lciA9PSBcIi1cIiB8fCBzZXR0aW5ncy50ZW5hbnRfaGFuZGxlID09PSBvd25lcjtcbiAgICB9XG4gICAgYXN5bmMgX293bmVyQ29uZmxpY3RFcnJvcihhY3Rpb24sIG93bmVyKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgQ2Fubm90ICR7YWN0aW9ufSBmb3IgYW5vdGhlciB0ZW5hbnQuXFxuXG4gICAgICBDdXJyZW50IHRlbmFudDogJHtzZXR0aW5ncy50ZW5hbnRfaGFuZGxlfVxcblxuICAgICAgUmVxdWVzdGVkIHRlbmFudDogJHtvd25lcn1gKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldExhdGVzdENvbW1pdEhhc2gocHJvbXB0T3duZXJBbmROYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vY29tbWl0cy8ke3Byb21wdE93bmVyQW5kTmFtZX0vP2xpbWl0PSR7MX0mb2Zmc2V0PSR7MH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImdldCBsYXRlc3QgY29tbWl0IGhhc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKGpzb24uY29tbWl0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb24uY29tbWl0c1swXS5jb21taXRfaGFzaDtcbiAgICB9XG4gICAgYXN5bmMgX2xpa2VPclVubGlrZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBsaWtlKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7IGxpa2U6IGxpa2UgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vbGlrZXMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgYCR7bGlrZSA/IFwibGlrZVwiIDogXCJ1bmxpa2VcIn0gcHJvbXB0YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFByb21wdFVybChwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgY29tbWl0SGFzaF0gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIGlmIChjb21taXRIYXNoICE9PSBcImxhdGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9odWIvJHtvd25lcn0vJHtwcm9tcHROYW1lfS8ke2NvbW1pdEhhc2guc3Vic3RyaW5nKDAsIDgpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5nZXRIb3N0VXJsKCl9L2h1Yi8ke293bmVyfS8ke3Byb21wdE5hbWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICAgIGlmIChjb21taXRIYXNoICE9PSBcImxhdGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wcm9tcHRzLyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNoLnN1YnN0cmluZygwLCA4KX0/b3JnYW5pemF0aW9uSWQ9JHtzZXR0aW5ncy5pZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuZ2V0SG9zdFVybCgpfS9wcm9tcHRzLyR7cHJvbXB0TmFtZX0/b3JnYW5pemF0aW9uSWQ9JHtzZXR0aW5ncy5pZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IHByb21wdCA9IGF3YWl0IHRoaXMuZ2V0UHJvbXB0KHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICByZXR1cm4gISFwcm9tcHQ7XG4gICAgfVxuICAgIGFzeW5jIGxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlrZU9yVW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHRydWUpO1xuICAgIH1cbiAgICBhc3luYyB1bmxpa2VQcm9tcHQocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlrZU9yVW5saWtlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIGZhbHNlKTtcbiAgICB9XG4gICAgYXN5bmMgKmxpc3RDb21taXRzKHByb21wdE93bmVyQW5kTmFtZSkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNvbW1pdHMgb2YgdGhpcy5fZ2V0UGFnaW5hdGVkKGAvY29tbWl0cy8ke3Byb21wdE93bmVyQW5kTmFtZX0vYCwgbmV3IFVSTFNlYXJjaFBhcmFtcygpLCAocmVzKSA9PiByZXMuY29tbWl0cykpIHtcbiAgICAgICAgICAgIHlpZWxkKiBjb21taXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jICpsaXN0UHJvbXB0cyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcInNvcnRfZmllbGRcIiwgb3B0aW9ucz8uc29ydEZpZWxkID8/IFwidXBkYXRlZF9hdFwiKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcInNvcnRfZGlyZWN0aW9uXCIsIFwiZGVzY1wiKTtcbiAgICAgICAgcGFyYW1zLmFwcGVuZChcImlzX2FyY2hpdmVkXCIsICghIW9wdGlvbnM/LmlzQXJjaGl2ZWQpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNQdWJsaWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcImlzX3B1YmxpY1wiLCBvcHRpb25zLmlzUHVibGljLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zPy5xdWVyeSkge1xuICAgICAgICAgICAgcGFyYW1zLmFwcGVuZChcInF1ZXJ5XCIsIG9wdGlvbnMucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcHJvbXB0cyBvZiB0aGlzLl9nZXRQYWdpbmF0ZWQoXCIvcmVwb3NcIiwgcGFyYW1zLCAocmVzKSA9PiByZXMucmVwb3MpKSB7XG4gICAgICAgICAgICB5aWVsZCogcHJvbXB0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRQcm9tcHQocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3JlcG9zLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlcz8uc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJnZXQgcHJvbXB0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlPy5qc29uKCk7XG4gICAgICAgIGlmIChyZXN1bHQ/LnJlcG8pIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVwbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgdGhpcy5fZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgaWYgKG9wdGlvbnM/LmlzUHVibGljICYmICFzZXR0aW5ncy50ZW5hbnRfaGFuZGxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBjcmVhdGUgYSBwdWJsaWMgcHJvbXB0IHdpdGhvdXQgZmlyc3RcXG5cbiAgICAgICAgY3JlYXRpbmcgYSBMYW5nQ2hhaW4gSHViIGhhbmRsZS5cbiAgICAgICAgWW91IGNhbiBhZGQgYSBoYW5kbGUgYnkgY3JlYXRpbmcgYSBwdWJsaWMgcHJvbXB0IGF0OlxcblxuICAgICAgICBodHRwczovL3NtaXRoLmxhbmdjaGFpbi5jb20vcHJvbXB0c2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMuX2N1cnJlbnRUZW5hbnRJc093bmVyKG93bmVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IGF3YWl0IHRoaXMuX293bmVyQ29uZmxpY3RFcnJvcihcImNyZWF0ZSBhIHByb21wdFwiLCBvd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHJlcG9faGFuZGxlOiBwcm9tcHROYW1lLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnM/LmRlc2NyaXB0aW9uICYmIHsgZGVzY3JpcHRpb246IG9wdGlvbnMuZGVzY3JpcHRpb24gfSksXG4gICAgICAgICAgICAuLi4ob3B0aW9ucz8ucmVhZG1lICYmIHsgcmVhZG1lOiBvcHRpb25zLnJlYWRtZSB9KSxcbiAgICAgICAgICAgIC4uLihvcHRpb25zPy50YWdzICYmIHsgdGFnczogb3B0aW9ucy50YWdzIH0pLFxuICAgICAgICAgICAgaXNfcHVibGljOiAhIW9wdGlvbnM/LmlzUHVibGljLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcmVwb3MvYCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogeyAuLi50aGlzLmhlYWRlcnMsIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmFpc2VGb3JTdGF0dXMocmVzLCBcImNyZWF0ZSBwcm9tcHRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByZXBvIH0gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiByZXBvO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVDb21taXQocHJvbXB0SWRlbnRpZmllciwgb2JqZWN0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGRvZXMgbm90IGV4aXN0LCB5b3UgbXVzdCBjcmVhdGUgaXQgZmlyc3QuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtvd25lciwgcHJvbXB0TmFtZSwgX10gPSBwYXJzZVByb21wdElkZW50aWZpZXIocHJvbXB0SWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCA9IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2ggPT09IFwibGF0ZXN0XCIgfHwgIW9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2hcbiAgICAgICAgICAgID8gYXdhaXQgdGhpcy5fZ2V0TGF0ZXN0Q29tbWl0SGFzaChgJHtvd25lcn0vJHtwcm9tcHROYW1lfWApXG4gICAgICAgICAgICA6IG9wdGlvbnM/LnBhcmVudENvbW1pdEhhc2g7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBtYW5pZmVzdDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmplY3QpKSxcbiAgICAgICAgICAgIHBhcmVudF9jb21taXQ6IHJlc29sdmVkUGFyZW50Q29tbWl0SGFzaCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2FsbGVyLmNhbGwoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5fZmV0Y2goYCR7dGhpcy5hcGlVcmx9L2NvbW1pdHMvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5oZWFkZXJzLCBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJjcmVhdGUgY29tbWl0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByb21wdFVybChgJHtvd25lcn0vJHtwcm9tcHROYW1lfSR7cmVzdWx0LmNvbW1pdF9oYXNoID8gYDoke3Jlc3VsdC5jb21taXRfaGFzaH1gIDogXCJcIn1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBkYXRlcyBMaXN0IG9mIEV4YW1wbGVVcGRhdGVXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cHNlcnRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwZGF0ZSByZXNwb25zZVxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZUV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBkYXRlcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwZGF0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGRhdGVzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0RGF0YXNldEV4YW1wbGVzTXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggZGVwbG95bWVudCBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBncmFkZSB5b3VyIGRlcGxveW1lbnQgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgdXBkYXRlcykge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUlkID0gZXhhbXBsZS5pZDtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdGhlIG1haW4gZXhhbXBsZSBib2R5XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQm9keSA9IHtcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBleGFtcGxlLm1ldGFkYXRhIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNwbGl0ICYmIHsgc3BsaXQ6IGV4YW1wbGUuc3BsaXQgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIG1haW4gZXhhbXBsZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEV4YW1wbGUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlQm9keSwgYFNlcmlhbGl6aW5nIGJvZHkgZm9yIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEV4YW1wbGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChleGFtcGxlSWQsIGV4YW1wbGVCbG9iKTtcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRJbnB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmlucHV0cywgYFNlcmlhbGl6aW5nIGlucHV0cyBmb3IgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkSW5wdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5pbnB1dHNgLCBpbnB1dHNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBvdXRwdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZE91dHB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLm91dHB1dHMsIGBTZXJpYWxpemluZyBvdXRwdXRzIHdobGUgdXBkYXRpbmcgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXRwdXRzQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZE91dHB1dHNdLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChgJHtleGFtcGxlSWR9Lm91dHB1dHNgLCBvdXRwdXRzQmxvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgYXR0YWNobWVudHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBhdHRhY2htZW50XSBvZiBPYmplY3QuZW50cmllcyhleGFtcGxlLmF0dGFjaG1lbnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW21pbWVUeXBlLCBkYXRhXSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZSA9IGF0dGFjaG1lbnQubWltZVR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXR0YWNobWVudC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGFjaG1lbnRCbG9iID0gbmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBgJHttaW1lVHlwZX07IGxlbmd0aD0ke2RhdGEuYnl0ZUxlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudC4ke25hbWV9YCwgYXR0YWNobWVudEJsb2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleGFtcGxlLmF0dGFjaG1lbnRzX29wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9ucyA9IHNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nKGV4YW1wbGUuYXR0YWNobWVudHNfb3BlcmF0aW9ucywgYFNlcmlhbGl6aW5nIGF0dGFjaG1lbnRzIHdoaWxlIHVwZGF0aW5nIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudHNPcGVyYXRpb25zQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEF0dGFjaG1lbnRzT3BlcmF0aW9uc10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0uYXR0YWNobWVudHNfb3BlcmF0aW9uc2AsIGF0dGFjaG1lbnRzT3BlcmF0aW9uc0Jsb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFzZXRJZFRvVXNlID0gZGF0YXNldElkID8/IHVwZGF0ZXNbMF0/LmRhdGFzZXRfaWQ7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3RoaXMuX2dldFBsYXRmb3JtRW5kcG9pbnRQYXRoKGBkYXRhc2V0cy8ke2RhdGFzZXRJZFRvVXNlfS9leGFtcGxlc2ApfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGRhdGUgZXhhbXBsZXNcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGV4YW1wbGVzIHdpdGggYXR0YWNobWVudHMgdXNpbmcgbXVsdGlwYXJ0IGZvcm0gZGF0YS5cbiAgICAgKiBAcGFyYW0gdXBsb2FkcyBMaXN0IG9mIEV4YW1wbGVVcGxvYWRXaXRoQXR0YWNobWVudHMgb2JqZWN0cyB0byB1cGxvYWRcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggdGhlIHVwbG9hZCByZXNwb25zZVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgTGFuZ1NtaXRoIHZlcnNpb25zLCBwbGVhc2UgdXNlIGBjcmVhdGVFeGFtcGxlc2AgaW5zdGVhZFxuICAgICAqL1xuICAgIGFzeW5jIHVwbG9hZEV4YW1wbGVzTXVsdGlwYXJ0KGRhdGFzZXRJZCwgdXBsb2FkcyA9IFtdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRFeGFtcGxlc011bHRpcGFydChkYXRhc2V0SWQsIHVwbG9hZHMpO1xuICAgIH1cbiAgICBhc3luYyBfdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQoZGF0YXNldElkLCB1cGxvYWRzID0gW10pIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fZ2V0RGF0YXNldEV4YW1wbGVzTXVsdGlQYXJ0U3VwcG9ydCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91ciBMYW5nU21pdGggZGVwbG95bWVudCBkb2VzIG5vdCBhbGxvdyB1c2luZyB0aGUgbXVsdGlwYXJ0IGV4YW1wbGVzIGVuZHBvaW50LCBwbGVhc2UgdXBncmFkZSB5b3VyIGRlcGxveW1lbnQgdG8gdGhlIGxhdGVzdCB2ZXJzaW9uLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGV4YW1wbGUgb2YgdXBsb2Fkcykge1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZUlkID0gKGV4YW1wbGUuaWQgPz8gdXVpZC52NCgpKS50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgbWFpbiBleGFtcGxlIGJvZHlcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGVCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGNyZWF0ZWRfYXQ6IGV4YW1wbGUuY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS5tZXRhZGF0YSAmJiB7IG1ldGFkYXRhOiBleGFtcGxlLm1ldGFkYXRhIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnNwbGl0ICYmIHsgc3BsaXQ6IGV4YW1wbGUuc3BsaXQgfSksXG4gICAgICAgICAgICAgICAgLi4uKGV4YW1wbGUuc291cmNlX3J1bl9pZCAmJiB7IHNvdXJjZV9ydW5faWQ6IGV4YW1wbGUuc291cmNlX3J1bl9pZCB9KSxcbiAgICAgICAgICAgICAgICAuLi4oZXhhbXBsZS51c2Vfc291cmNlX3J1bl9pbyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIHVzZV9zb3VyY2VfcnVuX2lvOiBleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2lvLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLihleGFtcGxlLnVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHM6IGV4YW1wbGUudXNlX3NvdXJjZV9ydW5fYXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQWRkIG1haW4gZXhhbXBsZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZEV4YW1wbGUgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlQm9keSwgYFNlcmlhbGl6aW5nIGJvZHkgZm9yIHVwbG9hZGVkIGV4YW1wbGUgd2l0aCBpZDogJHtleGFtcGxlSWR9YCk7XG4gICAgICAgICAgICBjb25zdCBleGFtcGxlQmxvYiA9IG5ldyBCbG9iKFtzdHJpbmdpZmllZEV4YW1wbGVdLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChleGFtcGxlSWQsIGV4YW1wbGVCbG9iKTtcbiAgICAgICAgICAgIC8vIEFkZCBpbnB1dHMgaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGV4YW1wbGUuaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZpZWRJbnB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLmlucHV0cywgYFNlcmlhbGl6aW5nIGlucHV0cyBmb3IgdXBsb2FkZWQgZXhhbXBsZSB3aXRoIGlkOiAke2V4YW1wbGVJZH1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dHNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkSW5wdXRzXSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5pbnB1dHNgLCBpbnB1dHNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBvdXRwdXRzIGlmIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChleGFtcGxlLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdpZmllZE91dHB1dHMgPSBzZXJpYWxpemVQYXlsb2FkRm9yVHJhY2luZyhleGFtcGxlLm91dHB1dHMsIGBTZXJpYWxpemluZyBvdXRwdXRzIGZvciB1cGxvYWRlZCBleGFtcGxlIHdpdGggaWQ6ICR7ZXhhbXBsZUlkfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dHNCbG9iID0gbmV3IEJsb2IoW3N0cmluZ2lmaWVkT3V0cHV0c10sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGAke2V4YW1wbGVJZH0ub3V0cHV0c2AsIG91dHB1dHNCbG9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBhdHRhY2htZW50cyBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoZXhhbXBsZS5hdHRhY2htZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIGF0dGFjaG1lbnRdIG9mIE9iamVjdC5lbnRyaWVzKGV4YW1wbGUuYXR0YWNobWVudHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGF0dGFjaG1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbbWltZVR5cGUsIGRhdGFdID0gYXR0YWNobWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlID0gYXR0YWNobWVudC5taW1lVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhdHRhY2htZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0YWNobWVudEJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGAke21pbWVUeXBlfTsgbGVuZ3RoPSR7ZGF0YS5ieXRlTGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7ZXhhbXBsZUlkfS5hdHRhY2htZW50LiR7bmFtZX1gLCBhdHRhY2htZW50QmxvYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0ke3RoaXMuX2dldFBsYXRmb3JtRW5kcG9pbnRQYXRoKGBkYXRhc2V0cy8ke2RhdGFzZXRJZH0vZXhhbXBsZXNgKX1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KHRoaXMudGltZW91dF9tcyksXG4gICAgICAgICAgICAgICAgLi4udGhpcy5mZXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IHJhaXNlRm9yU3RhdHVzKHJlcywgXCJ1cGxvYWQgZXhhbXBsZXNcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5wcm9tcHRFeGlzdHMocHJvbXB0SWRlbnRpZmllcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9tcHQgZG9lcyBub3QgZXhpc3QsIHlvdSBtdXN0IGNyZWF0ZSBpdCBmaXJzdC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKCEoYXdhaXQgdGhpcy5fY3VycmVudFRlbmFudElzT3duZXIob3duZXIpKSkge1xuICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5fb3duZXJDb25mbGljdEVycm9yKFwidXBkYXRlIGEgcHJvbXB0XCIsIG93bmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmIChvcHRpb25zPy5kZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5kZXNjcmlwdGlvbiA9IG9wdGlvbnMuZGVzY3JpcHRpb247XG4gICAgICAgIGlmIChvcHRpb25zPy5yZWFkbWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHBheWxvYWQucmVhZG1lID0gb3B0aW9ucy5yZWFkbWU7XG4gICAgICAgIGlmIChvcHRpb25zPy50YWdzICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBwYXlsb2FkLnRhZ3MgPSBvcHRpb25zLnRhZ3M7XG4gICAgICAgIGlmIChvcHRpb25zPy5pc1B1YmxpYyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19wdWJsaWMgPSBvcHRpb25zLmlzUHVibGljO1xuICAgICAgICBpZiAob3B0aW9ucz8uaXNBcmNoaXZlZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcGF5bG9hZC5pc19hcmNoaXZlZCA9IG9wdGlvbnMuaXNBcmNoaXZlZDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgcGF5bG9hZCBpcyBlbXB0eVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGF5bG9hZCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB2YWxpZCB1cGRhdGUgb3B0aW9ucyBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUEFUQ0hcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsLnRpbWVvdXQodGhpcy50aW1lb3V0X21zKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLmZldGNoT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwidXBkYXRlIHByb21wdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVQcm9tcHQocHJvbXB0SWRlbnRpZmllcikge1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLnByb21wdEV4aXN0cyhwcm9tcHRJZGVudGlmaWVyKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb21wdCBkb2VzIG5vdCBleGlzdCwgeW91IG11c3QgY3JlYXRlIGl0IGZpcnN0LlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3duZXIsIHByb21wdE5hbWUsIF9dID0gcGFyc2VQcm9tcHRJZGVudGlmaWVyKHByb21wdElkZW50aWZpZXIpO1xuICAgICAgICBpZiAoIShhd2FpdCB0aGlzLl9jdXJyZW50VGVuYW50SXNPd25lcihvd25lcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLl9vd25lckNvbmZsaWN0RXJyb3IoXCJkZWxldGUgYSBwcm9tcHRcIiwgb3duZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5jYWxsZXIuY2FsbChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLl9mZXRjaChgJHt0aGlzLmFwaVVybH0vcmVwb3MvJHtvd25lcn0vJHtwcm9tcHROYW1lfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiREVMRVRFXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwiZGVsZXRlIHByb21wdFwiKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgIH1cbiAgICBhc3luYyBwdWxsUHJvbXB0Q29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBwcm9tcHROYW1lLCBjb21taXRIYXNoXSA9IHBhcnNlUHJvbXB0SWRlbnRpZmllcihwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNhbGxlci5jYWxsKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuX2ZldGNoKGAke3RoaXMuYXBpVXJsfS9jb21taXRzLyR7b3duZXJ9LyR7cHJvbXB0TmFtZX0vJHtjb21taXRIYXNofSR7b3B0aW9ucz8uaW5jbHVkZU1vZGVsID8gXCI/aW5jbHVkZV9tb2RlbD10cnVlXCIgOiBcIlwifWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwudGltZW91dCh0aGlzLnRpbWVvdXRfbXMpLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuZmV0Y2hPcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByYWlzZUZvclN0YXR1cyhyZXMsIFwicHVsbCBwcm9tcHQgY29tbWl0XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG93bmVyLFxuICAgICAgICAgICAgcmVwbzogcHJvbXB0TmFtZSxcbiAgICAgICAgICAgIGNvbW1pdF9oYXNoOiByZXN1bHQuY29tbWl0X2hhc2gsXG4gICAgICAgICAgICBtYW5pZmVzdDogcmVzdWx0Lm1hbmlmZXN0LFxuICAgICAgICAgICAgZXhhbXBsZXM6IHJlc3VsdC5leGFtcGxlcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgYGltcG9ydCB7IHB1bGwgfSBmcm9tIFwibGFuZ2NoYWluL2h1YlwiYCBpbnN0ZWFkLlxuICAgICAqIFVzaW5nIHRoaXMgbWV0aG9kIGRpcmVjdGx5IHJldHVybnMgdGhlIEpTT04gc3RyaW5nIG9mIHRoZSBwcm9tcHQgcmF0aGVyIHRoYW4gYSBMYW5nQ2hhaW4gb2JqZWN0LlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXN5bmMgX3B1bGxQcm9tcHQocHJvbXB0SWRlbnRpZmllciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcm9tcHRPYmplY3QgPSBhd2FpdCB0aGlzLnB1bGxQcm9tcHRDb21taXQocHJvbXB0SWRlbnRpZmllciwge1xuICAgICAgICAgICAgaW5jbHVkZU1vZGVsOiBvcHRpb25zPy5pbmNsdWRlTW9kZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHQgPSBKU09OLnN0cmluZ2lmeShwcm9tcHRPYmplY3QubWFuaWZlc3QpO1xuICAgICAgICByZXR1cm4gcHJvbXB0O1xuICAgIH1cbiAgICBhc3luYyBwdXNoUHJvbXB0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG9yIHVwZGF0ZSBwcm9tcHQgbWV0YWRhdGFcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMucHJvbXB0RXhpc3RzKHByb21wdElkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucyAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5zb21lKChrZXkpID0+IGtleSAhPT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVByb21wdChwcm9tcHRJZGVudGlmaWVyLCB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zPy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgICAgIHRhZ3M6IG9wdGlvbnM/LnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGlzUHVibGljOiBvcHRpb25zPy5pc1B1YmxpYyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3JlYXRlUHJvbXB0KHByb21wdElkZW50aWZpZXIsIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucz8uZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgcmVhZG1lOiBvcHRpb25zPy5yZWFkbWUsXG4gICAgICAgICAgICAgICAgdGFnczogb3B0aW9ucz8udGFncyxcbiAgICAgICAgICAgICAgICBpc1B1YmxpYzogb3B0aW9ucz8uaXNQdWJsaWMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnM/Lm9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFByb21wdFVybChwcm9tcHRJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBjb21taXQgd2l0aCB0aGUgbmV3IG1hbmlmZXN0XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuY3JlYXRlQ29tbWl0KHByb21wdElkZW50aWZpZXIsIG9wdGlvbnM/Lm9iamVjdCwge1xuICAgICAgICAgICAgcGFyZW50Q29tbWl0SGFzaDogb3B0aW9ucz8ucGFyZW50Q29tbWl0SGFzaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIGEgcHVibGljIGRhdGFzZXQgdG8geW91ciBvd24gbGFuZ3NtaXRoIHRlbmFudC5cbiAgICAgKiBUaGlzIG9wZXJhdGlvbiBpcyBpZGVtcG90ZW50LiBJZiB5b3UgYWxyZWFkeSBoYXZlIGEgZGF0YXNldCB3aXRoIHRoZSBnaXZlbiBuYW1lLFxuICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBkbyBub3RoaW5nLlxuICBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5PclVybCBUaGUgdG9rZW4gb2YgdGhlIHB1YmxpYyBkYXRhc2V0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQWRkaXRpb25hbCBvcHRpb25zIGZvciBjbG9uaW5nIHRoZSBkYXRhc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VBcGlVcmxdIFRoZSBVUkwgb2YgdGhlIGxhbmdzbWl0aCBzZXJ2ZXIgd2hlcmUgdGhlIGRhdGEgaXMgaG9zdGVkLiBEZWZhdWx0cyB0byB0aGUgQVBJIFVSTCBvZiB5b3VyIGN1cnJlbnQgY2xpZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5kYXRhc2V0TmFtZV0gVGhlIG5hbWUgb2YgdGhlIGRhdGFzZXQgdG8gY3JlYXRlIGluIHlvdXIgdGVuYW50LiBEZWZhdWx0cyB0byB0aGUgbmFtZSBvZiB0aGUgcHVibGljIGRhdGFzZXQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgY2xvbmVQdWJsaWNEYXRhc2V0KHRva2VuT3JVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IHNvdXJjZUFwaVVybCA9IHRoaXMuYXBpVXJsLCBkYXRhc2V0TmFtZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgW3BhcnNlZEFwaVVybCwgdG9rZW5VdWlkXSA9IHRoaXMucGFyc2VUb2tlbk9yVXJsKHRva2VuT3JVcmwsIHNvdXJjZUFwaVVybCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZUNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgICAgICAgICAgYXBpVXJsOiBwYXJzZWRBcGlVcmwsXG4gICAgICAgICAgICAvLyBQbGFjZWhvbGRlciBBUEkga2V5IG5vdCBuZWVkZWQgYW55bW9yZSBpbiBtb3N0IGNhc2VzLCBidXRcbiAgICAgICAgICAgIC8vIHNvbWUgcHJpdmF0ZSBkZXBsb3ltZW50cyBtYXkgaGF2ZSBBUEkga2V5LWJhc2VkIHJhdGUgbGltaXRpbmdcbiAgICAgICAgICAgIC8vIHRoYXQgd291bGQgY2F1c2UgdGhpcyB0byBmYWlsIGlmIHdlIHByb3ZpZGUgbm8gdmFsdWUuXG4gICAgICAgICAgICBhcGlLZXk6IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRzID0gYXdhaXQgc291cmNlQ2xpZW50LnJlYWRTaGFyZWREYXRhc2V0KHRva2VuVXVpZCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRGF0YXNldE5hbWUgPSBkYXRhc2V0TmFtZSB8fCBkcy5uYW1lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGF3YWl0IHRoaXMuaGFzRGF0YXNldCh7IGRhdGFzZXRJZDogZmluYWxEYXRhc2V0TmFtZSB9KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBEYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0gYWxyZWFkeSBleGlzdHMgaW4geW91ciB0ZW5hbnQuIFNraXBwaW5nLmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gYC5oYXNEYXRhc2V0YCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBkYXRhc2V0IGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgLy8gbm8tb3AgaW4gdGhhdCBjYXNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gRmV0Y2ggZXhhbXBsZXMgZmlyc3QsIHRoZW4gY3JlYXRlIHRoZSBkYXRhc2V0XG4gICAgICAgIGNvbnN0IGV4YW1wbGVzID0gYXdhaXQgc291cmNlQ2xpZW50Lmxpc3RTaGFyZWRFeGFtcGxlcyh0b2tlblV1aWQpO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gYXdhaXQgdGhpcy5jcmVhdGVEYXRhc2V0KGZpbmFsRGF0YXNldE5hbWUsIHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBkcy5kYXRhX3R5cGUgfHwgXCJrdlwiLFxuICAgICAgICAgICAgaW5wdXRzU2NoZW1hOiBkcy5pbnB1dHNfc2NoZW1hX2RlZmluaXRpb24gPz8gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3V0cHV0c1NjaGVtYTogZHMub3V0cHV0c19zY2hlbWFfZGVmaW5pdGlvbiA/PyB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVFeGFtcGxlcyh7XG4gICAgICAgICAgICAgICAgaW5wdXRzOiBleGFtcGxlcy5tYXAoKGUpID0+IGUuaW5wdXRzKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiBleGFtcGxlcy5mbGF0TWFwKChlKSA9PiAoZS5vdXRwdXRzID8gW2Uub3V0cHV0c10gOiBbXSkpLFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJZDogZGF0YXNldC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyBkYXRhc2V0ICR7ZmluYWxEYXRhc2V0TmFtZX0uIGAgK1xuICAgICAgICAgICAgICAgIFwiWW91IHNob3VsZCBkZWxldGUgaXQgbWFudWFsbHkuXCIpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZVRva2VuT3JVcmwodXJsT3JUb2tlbiwgYXBpVXJsLCBudW1QYXJ0cyA9IDIsIGtpbmQgPSBcImRhdGFzZXRcIikge1xuICAgICAgICAvLyBUcnkgcGFyc2luZyBhcyBVVUlEXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhc3NlcnRVdWlkKHVybE9yVG9rZW4pOyAvLyBXaWxsIHRocm93IGlmIGl0J3Mgbm90IGEgVVVJRC5cbiAgICAgICAgICAgIHJldHVybiBbYXBpVXJsLCB1cmxPclRva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gbm8tb3AgaWYgaXQncyBub3QgYSB1dWlkXG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgYXMgVVJMXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybE9yVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgcGF0aFBhcnRzID0gcGFyc2VkVXJsLnBhdGhuYW1lXG4gICAgICAgICAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHBhcnQpID0+IHBhcnQgIT09IFwiXCIpO1xuICAgICAgICAgICAgaWYgKHBhdGhQYXJ0cy5sZW5ndGggPj0gbnVtUGFydHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblV1aWQgPSBwYXRoUGFydHNbcGF0aFBhcnRzLmxlbmd0aCAtIG51bVBhcnRzXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FwaVVybCwgdG9rZW5VdWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkw6ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMgJHtraW5kfSBVUkwgb3IgdG9rZW46ICR7dXJsT3JUb2tlbn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBd2FpdHMgYWxsIHBlbmRpbmcgdHJhY2UgYmF0Y2hlcy4gVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgd2hlcmVcbiAgICAgKiB5b3UgbmVlZCB0byBiZSBzdXJlIHRoYXQgYWxsIHRyYWNpbmcgcmVxdWVzdHMgZmluaXNoIGJlZm9yZSBleGVjdXRpb24gZW5kcyxcbiAgICAgKiBzdWNoIGFzIHNlcnZlcmxlc3MgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwibGFuZ3NtaXRoXCI7XG4gICAgICpcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgQ2xpZW50KCk7XG4gICAgICpcbiAgICAgKiB0cnkge1xuICAgICAqICAgLy8gVHJhY2luZyBoYXBwZW5zIGhlcmVcbiAgICAgKiAgIC4uLlxuICAgICAqIH0gZmluYWxseSB7XG4gICAgICogICBhd2FpdCBjbGllbnQuYXdhaXRQZW5kaW5nVHJhY2VCYXRjaGVzKCk7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSBhbGwgY3VycmVudGx5IHBlbmRpbmcgdHJhY2VzIGhhdmUgc2VudC5cbiAgICAgKi9cbiAgICBhc3luYyBhd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hbnVhbEZsdXNoTW9kZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiW1dBUk5JTkddOiBXaGVuIHRyYWNpbmcgaW4gbWFudWFsIGZsdXNoIG1vZGUsIHlvdSBtdXN0IGNhbGwgYGF3YWl0IGNsaWVudC5mbHVzaCgpYCBtYW51YWxseSB0byBzdWJtaXQgdHJhY2UgYmF0Y2hlcy5cIik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyYWNlYWJsZXMgdXNlIGEgYmFja2dyb3VuZGVkIHByb21pc2UgYmVmb3JlIHVwZGF0aW5nIHJ1bnMgdG8gYXZvaWQgYmxvY2tpbmdcbiAgICAgICAgICogYW5kIHRvIGFsbG93IHdhaXRpbmcgZm9yIGNoaWxkIHJ1bnMgdG8gZW5kLiBXYWl0aW5nIGEgc21hbGwgYW1vdW50IG9mIHRpbWVcbiAgICAgICAgICogaGVyZSBlbnN1cmVzIHRoYXQgdGhleSBhcmUgYWJsZSB0byBlbnF1ZXVlIHRoZWlyIHJ1biBvcGVyYXRpb24gYmVmb3JlIHdlIGF3YWl0XG4gICAgICAgICAqIHF1ZXVlZCBydW4gb3BlcmF0aW9ucyBiZWxvdzpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcnVuID0gYXdhaXQgdHJhY2VhYmxlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICogICByZXR1cm4gXCJIZWxsbywgd29ybGQhXCI7XG4gICAgICAgICAqIH0sIHsgY2xpZW50IH0pKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGF3YWl0IGNsaWVudC5hd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMoKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxKSk7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIC4uLnRoaXMuYXV0b0JhdGNoUXVldWUuaXRlbXMubWFwKCh7IGl0ZW1Qcm9taXNlIH0pID0+IGl0ZW1Qcm9taXNlKSxcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hJbmdlc3RDYWxsZXIucXVldWUub25JZGxlKCksXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAodGhpcy5sYW5nU21pdGhUb09URUxUcmFuc2xhdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGdldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cygpPy5ERUZBVUxUX0xBTkdTTUlUSF9TUEFOX1BST0NFU1NPUj8uZm9yY2VGbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNFeGFtcGxlQ3JlYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIFwiZGF0YXNldF9pZFwiIGluIGlucHV0IHx8IFwiZGF0YXNldF9uYW1lXCIgaW4gaW5wdXQ7XG59XG4iXSwibmFtZXMiOlsidXVpZCIsIkxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IiLCJnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMiLCJnZXRPVEVMVHJhY2UiLCJnZXRPVEVMQ29udGV4dCIsIkFzeW5jQ2FsbGVyIiwiY29udmVydExhbmdDaGFpbk1lc3NhZ2VUb0V4YW1wbGUiLCJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ1NtaXRoRW52VmFyc01ldGFkYXRhIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImdldFJ1bnRpbWVFbnZpcm9ubWVudCIsImdldE90ZWxFbmFibGVkIiwiZ2V0RW52IiwiX192ZXJzaW9uX18iLCJhc3NlcnRVdWlkIiwid2Fybk9uY2UiLCJwYXJzZVByb21wdElkZW50aWZpZXIiLCJyYWlzZUZvclN0YXR1cyIsImlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvciIsIl9nbG9iYWxGZXRjaEltcGxlbWVudGF0aW9uSXNOb2RlRmV0Y2giLCJfZ2V0RmV0Y2hJbXBsZW1lbnRhdGlvbiIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZVBheWxvYWRGb3JUcmFjaW5nIiwibWVyZ2VSdW50aW1lRW52SW50b1J1biIsInJ1biIsImNhY2hlZEVudlZhcnMiLCJvbWl0VHJhY2VkUnVudGltZUluZm8iLCJydW50aW1lRW52IiwiZW52VmFycyIsImV4dHJhIiwibWV0YWRhdGEiLCJydW50aW1lIiwicmV2aXNpb25faWQiLCJ1bmRlZmluZWQiLCJnZXRUcmFjaW5nU2FtcGxpbmdSYXRlIiwiY29uZmlnUmF0ZSIsInNhbXBsaW5nUmF0ZVN0ciIsInRvU3RyaW5nIiwic2FtcGxpbmdSYXRlIiwicGFyc2VGbG9hdCIsIkVycm9yIiwiaXNMb2NhbGhvc3QiLCJ1cmwiLCJzdHJpcHBlZFVybCIsInJlcGxhY2UiLCJob3N0bmFtZSIsInNwbGl0IiwidG9BcnJheSIsIml0ZXJhYmxlIiwicmVzdWx0IiwiaXRlbSIsInB1c2giLCJ0cmltUXVvdGVzIiwic3RyIiwidHJpbSIsImhhbmRsZTQyOSIsInJlc3BvbnNlIiwic3RhdHVzIiwicmV0cnlBZnRlciIsInBhcnNlSW50IiwiaGVhZGVycyIsImdldCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIl9mb3JtYXRGZWVkYmFja1Njb3JlIiwic2NvcmUiLCJOdW1iZXIiLCJ0b0ZpeGVkIiwiREVGQVVMVF9VTkNPTVBSRVNTRURfQkFUQ0hfU0laRV9MSU1JVF9CWVRFUyIsIkRFRkFVTFRfTUFYX1NJWkVfQllURVMiLCJTRVJWRVJfSU5GT19SRVFVRVNUX1RJTUVPVVRfTVMiLCJERUZBVUxUX0JBVENIX1NJWkVfTElNSVQiLCJERUZBVUxUX0FQSV9VUkwiLCJBdXRvQmF0Y2hRdWV1ZSIsImNvbnN0cnVjdG9yIiwibWF4U2l6ZUJ5dGVzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInBlZWsiLCJpdGVtcyIsIml0ZW1Qcm9taXNlUmVzb2x2ZSIsIml0ZW1Qcm9taXNlIiwic2l6ZSIsImlkIiwibGVuZ3RoIiwic2l6ZUJ5dGVzIiwiY29uc29sZSIsIndhcm4iLCJhY3Rpb24iLCJwYXlsb2FkIiwib3RlbENvbnRleHQiLCJhcGlLZXkiLCJhcGlVcmwiLCJwb3AiLCJ1cFRvU2l6ZUJ5dGVzIiwidXBUb1NpemUiLCJwb3BwZWQiLCJwb3BwZWRTaXplQnl0ZXMiLCJzaGlmdCIsIm1hcCIsIml0IiwiZm9yRWFjaCIsIkNsaWVudCIsIl9mZXRjaCIsImZldGNoSW1wbGVtZW50YXRpb24iLCJkZWJ1ZyIsImNvbmZpZyIsIlNldCIsImRlZmF1bHRDb25maWciLCJnZXREZWZhdWx0Q2xpZW50Q29uZmlnIiwidHJhY2luZ1NhbXBsZVJhdGUiLCJ0cmFjaW5nU2FtcGxpbmdSYXRlIiwiZW5kc1dpdGgiLCJzbGljZSIsIndlYlVybCIsIndvcmtzcGFjZUlkIiwidGltZW91dF9tcyIsImNhbGxlciIsImNhbGxlck9wdGlvbnMiLCJtYXhSZXRyaWVzIiwidHJhY2VCYXRjaENvbmN1cnJlbmN5IiwibWF4TWVtb3J5IiwibWF4SW5nZXN0TWVtb3J5Qnl0ZXMiLCJiYXRjaEluZ2VzdENhbGxlciIsIm1heENvbmN1cnJlbmN5IiwibWF4UXVldWVTaXplQnl0ZXMiLCJvbkZhaWxlZFJlc3BvbnNlSG9vayIsImhpZGVJbnB1dHMiLCJhbm9ueW1pemVyIiwiaGlkZU91dHB1dHMiLCJhdXRvQmF0Y2hUcmFjaW5nIiwiYXV0b0JhdGNoUXVldWUiLCJibG9ja09uUm9vdFJ1bkZpbmFsaXphdGlvbiIsImJhdGNoU2l6ZUJ5dGVzTGltaXQiLCJiYXRjaFNpemVMaW1pdCIsImZldGNoT3B0aW9ucyIsIm1hbnVhbEZsdXNoTW9kZSIsImxhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3IiLCJjYWNoZWRMU0VudlZhcnNGb3JNZXRhZGF0YSIsImdldEhvc3RVcmwiLCJpbmNsdWRlcyIsIl9nZXRQbGF0Zm9ybUVuZHBvaW50UGF0aCIsInBhdGgiLCJuZWVkc1YxUHJlZml4IiwicHJvY2Vzc0lucHV0cyIsImlucHV0cyIsInByb2Nlc3NPdXRwdXRzIiwib3V0cHV0cyIsInByZXBhcmVSdW5DcmVhdGVPclVwZGF0ZUlucHV0cyIsInJ1blBhcmFtcyIsIl9nZXRSZXNwb25zZSIsInF1ZXJ5UGFyYW1zIiwicGFyYW1zU3RyaW5nIiwiY2FsbCIsInJlcyIsIm1ldGhvZCIsInNpZ25hbCIsIkFib3J0U2lnbmFsIiwidGltZW91dCIsIl9nZXQiLCJqc29uIiwiX2dldFBhZ2luYXRlZCIsIlVSTFNlYXJjaFBhcmFtcyIsInRyYW5zZm9ybSIsIm9mZnNldCIsImxpbWl0Iiwic2V0IiwiU3RyaW5nIiwiX2dldEN1cnNvclBhZ2luYXRlZExpc3QiLCJib2R5IiwicmVxdWVzdE1ldGhvZCIsImRhdGFLZXkiLCJib2R5UGFyYW1zIiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3BvbnNlQm9keSIsImN1cnNvcnMiLCJuZXh0IiwiY3Vyc29yIiwiX3Nob3VsZFNhbXBsZSIsIk1hdGgiLCJyYW5kb20iLCJfZmlsdGVyRm9yU2FtcGxpbmciLCJydW5zIiwicGF0Y2giLCJzYW1wbGVkIiwiZmlsdGVyZWRQb3N0VXVpZHMiLCJoYXMiLCJ0cmFjZV9pZCIsImRlbGV0ZSIsInRyYWNlSWQiLCJhZGQiLCJfZ2V0QmF0Y2hTaXplTGltaXRCeXRlcyIsInNlcnZlckluZm8iLCJfZW5zdXJlU2VydmVySW5mbyIsImJhdGNoX2luZ2VzdF9jb25maWciLCJzaXplX2xpbWl0X2J5dGVzIiwiX2dldEJhdGNoU2l6ZUxpbWl0Iiwic2l6ZV9saW1pdCIsIl9nZXREYXRhc2V0RXhhbXBsZXNNdWx0aVBhcnRTdXBwb3J0IiwiaW5zdGFuY2VfZmxhZ3MiLCJkYXRhc2V0X2V4YW1wbGVzX211bHRpcGFydF9lbmFibGVkIiwiZHJhaW5BdXRvQmF0Y2hRdWV1ZSIsImJhdGNoU2l6ZUxpbWl0Qnl0ZXMiLCJwcm9taXNlcyIsImJhdGNoIiwiZG9uZSIsImJhdGNoZXNCeURlc3RpbmF0aW9uIiwicmVkdWNlIiwiYWNjIiwiaXNEZWZhdWx0IiwiYmF0Y2hLZXkiLCJiYXRjaFByb21pc2VzIiwiZW50cmllcyIsImJhdGNoUHJvbWlzZSIsIl9wcm9jZXNzQmF0Y2giLCJhbGxCYXRjaGVzUHJvbWlzZSIsImFsbCIsImZpbmFsbHkiLCJvcHRpb25zIiwiYmF0Y2hTaXplQnl0ZXMiLCJzdW0iLCJfc2VuZEJhdGNoVG9PVEVMVHJhbnNsYXRvciIsImluZ2VzdFBhcmFtcyIsInJ1bkNyZWF0ZXMiLCJmaWx0ZXIiLCJydW5VcGRhdGVzIiwidXNlTXVsdGlwYXJ0IiwiX211bHRpcGFydERpc2FibGVkIiwidXNlX211bHRpcGFydF9lbmRwb2ludCIsInVzZUd6aXAiLCJnemlwX2JvZHlfZW5hYmxlZCIsIm11bHRpcGFydEluZ2VzdFJ1bnMiLCJlIiwiYmF0Y2hJbmdlc3RSdW5zIiwiZXJyb3IiLCJvdGVsQ29udGV4dE1hcCIsIk1hcCIsIm9wZXJhdGlvbnMiLCJvcGVyYXRpb24iLCJleHBvcnRCYXRjaCIsInByb2Nlc3NSdW5PcGVyYXRpb24iLCJjbGVhclRpbWVvdXQiLCJhdXRvQmF0Y2hUaW1lb3V0Iiwic2l6ZUxpbWl0Qnl0ZXMiLCJzaXplTGltaXQiLCJhdXRvQmF0Y2hBZ2dyZWdhdGlvbkRlbGF5TXMiLCJfZ2V0U2VydmVySW5mbyIsIkFjY2VwdCIsImxvZyIsIl9nZXRTZXJ2ZXJJbmZvUHJvbWlzZSIsIl9zZXJ2ZXJJbmZvIiwibWVzc2FnZSIsInRoZW4iLCJfZ2V0U2V0dGluZ3MiLCJzZXR0aW5ncyIsImZsdXNoIiwiX2Nsb25lQ3VycmVudE9URUxDb250ZXh0Iiwib3RlbF90cmFjZSIsIm90ZWxfY29udGV4dCIsImN1cnJlbnRTcGFuIiwiZ2V0QWN0aXZlU3BhbiIsInNldFNwYW4iLCJhY3RpdmUiLCJjcmVhdGVSdW4iLCJzZXNzaW9uX25hbWUiLCJwcm9qZWN0X25hbWUiLCJydW5DcmVhdGUiLCJzdGFydF90aW1lIiwiRGF0ZSIsIm5vdyIsImRvdHRlZF9vcmRlciIsImNhdGNoIiwibWVyZ2VkUnVuQ3JlYXRlUGFyYW0iLCJwcmVwYXJlZENyZWF0ZVBhcmFtcyIsImNyZWF0ZSIsInByZXBhcmVkVXBkYXRlUGFyYW1zIiwidXBkYXRlIiwiY3JlYXRlQnlJZCIsInBhcmFtcyIsInN0YW5kYWxvbmVVcGRhdGVzIiwidXBkYXRlUGFyYW0iLCJ2YWx1ZXMiLCJyYXdCYXRjaCIsInBvc3QiLCJiYXRjaENodW5rcyIsImsiLCJrZXkiLCJiYXRjaEl0ZW1zIiwicmV2ZXJzZSIsImJhdGNoSXRlbSIsInJ1bklkcyIsImNvbmNhdCIsImpvaW4iLCJfcG9zdEJhdGNoSW5nZXN0UnVucyIsImNhbGxXaXRoT3B0aW9ucyIsImFsbEF0dGFjaG1lbnRzIiwicHJlcGFyZWRDcmVhdGUiLCJhdHRhY2htZW50cyIsImludmFsaWRSdW5DcmVhdGUiLCJmaW5kIiwiaW52YWxpZFJ1blVwZGF0ZSIsInJ1blVwZGF0ZSIsImFjY3VtdWxhdGVkQ29udGV4dCIsImFjY3VtdWxhdGVkUGFydHMiLCJwYXlsb2FkcyIsIm9yaWdpbmFsUGF5bG9hZCIsImV2ZW50cyIsInNlcmlhbGl6ZWQiLCJmaWVsZHMiLCJzdHJpbmdpZmllZFBheWxvYWQiLCJuYW1lIiwiQmxvYiIsInR5cGUiLCJzdHJpbmdpZmllZFZhbHVlIiwiYXR0YWNobWVudCIsImNvbnRlbnRUeXBlIiwiY29udGVudCIsIkFycmF5IiwiaXNBcnJheSIsIm1pbWVUeXBlIiwiZGF0YSIsImJ5dGVMZW5ndGgiLCJfc2VuZE11bHRpcGFydFJlcXVlc3QiLCJfY3JlYXRlTm9kZUZldGNoQm9keSIsInBhcnRzIiwiYm91bmRhcnkiLCJjaHVua3MiLCJwYXJ0IiwiYXJyYXlCdWZmZXIiLCJfY3JlYXRlTXVsdGlwYXJ0U3RyZWFtIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJ3cml0ZUNodW5rIiwiY2h1bmsiLCJlbnF1ZXVlIiwiZW5jb2RlIiwicGF5bG9hZFN0cmVhbSIsInJlYWRlciIsImdldFJlYWRlciIsInJlYWQiLCJyZWxlYXNlTG9jayIsImNsb3NlIiwiY29udGV4dCIsImlzTm9kZUZldGNoIiwiYnVpbGRCdWZmZXJlZCIsImJ1aWxkU3RyZWFtIiwic2VuZFdpdGhSZXRyeSIsImJvZHlGYWN0b3J5IiwidHJhbnNmb3JtZWRCb2R5IiwicGlwZVRocm91Z2giLCJDb21wcmVzc2lvblN0cmVhbSIsImR1cGxleCIsInN0cmVhbWVkQXR0ZW1wdCIsIm11bHRpcGFydFN0cmVhbWluZ0Rpc2FibGVkIiwidXBkYXRlUnVuIiwicnVuSWQiLCJlbmRfdGltZSIsInBhcmVudF9ydW5faWQiLCJyZWFkUnVuIiwibG9hZENoaWxkUnVucyIsIl9sb2FkQ2hpbGRSdW5zIiwiZ2V0UnVuVXJsIiwicHJvamVjdE9wdHMiLCJzZXNzaW9uSWQiLCJzZXNzaW9uX2lkIiwicHJvamVjdE5hbWUiLCJyZWFkUHJvamVjdCIsInByb2plY3RJZCIsInByb2plY3QiLCJ0ZW5hbnRJZCIsIl9nZXRUZW5hbnRJZCIsInJ1bl8iLCJhcHBfcGF0aCIsImJhc2VVcmwiLCJjaGlsZFJ1bnMiLCJsaXN0UnVucyIsImlzUm9vdCIsInRyZWVtYXAiLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwiY2hpbGRSdW4iLCJzdGFydHNXaXRoIiwiY2hpbGRfcnVucyIsInByb3BzIiwicGFyZW50UnVuSWQiLCJyZWZlcmVuY2VFeGFtcGxlSWQiLCJzdGFydFRpbWUiLCJleGVjdXRpb25PcmRlciIsInJ1blR5cGUiLCJxdWVyeSIsInRyYWNlRmlsdGVyIiwidHJlZUZpbHRlciIsInNlbGVjdCIsIm9yZGVyIiwicHJvamVjdElkcyIsInByb2plY3ROYW1lcyIsInByb2plY3RJZHNfIiwiZGVmYXVsdF9zZWxlY3QiLCJzZXNzaW9uIiwicnVuX3R5cGUiLCJyZWZlcmVuY2VfZXhhbXBsZSIsInRyYWNlX2ZpbHRlciIsInRyZWVfZmlsdGVyIiwiZXhlY3V0aW9uX29yZGVyIiwicGFyZW50X3J1biIsInRvSVNPU3RyaW5nIiwidHJhY2UiLCJpc19yb290IiwicnVuc1lpZWxkZWQiLCJuZXdSdW5zIiwibGlzdEdyb3VwUnVucyIsImdyb3VwQnkiLCJlbmRUaW1lIiwiYmFzZUJvZHkiLCJncm91cF9ieSIsImN1cnJlbnRPZmZzZXQiLCJjdXJyZW50Qm9keSIsImZpbHRlcmVkUGF5bG9hZCIsImZyb21FbnRyaWVzIiwiXyIsImdyb3VwcyIsInRvdGFsIiwidGhyZWFkIiwiZ2V0UnVuU3RhdHMiLCJwYXJlbnRSdW4iLCJyZWZlcmVuY2VFeGFtcGxlSWRzIiwiZGF0YVNvdXJjZVR5cGUiLCJkYXRhX3NvdXJjZV90eXBlIiwic2hhcmVSdW4iLCJzaGFyZUlkIiwicnVuX2lkIiwic2hhcmVfdG9rZW4iLCJ2NCIsInVuc2hhcmVSdW4iLCJyZWFkUnVuU2hhcmVkTGluayIsImxpc3RTaGFyZWRSdW5zIiwic2hhcmVUb2tlbiIsImFwcGVuZCIsInJlYWREYXRhc2V0U2hhcmVkU2NoZW1hIiwiZGF0YXNldElkIiwiZGF0YXNldE5hbWUiLCJkYXRhc2V0IiwicmVhZERhdGFzZXQiLCJzaGFyZVNjaGVtYSIsInNoYXJlRGF0YXNldCIsImRhdGFzZXRfaWQiLCJ1bnNoYXJlRGF0YXNldCIsInJlYWRTaGFyZWREYXRhc2V0IiwibGlzdFNoYXJlZEV4YW1wbGVzIiwiZXhhbXBsZUlkcyIsInVybFBhcmFtcyIsInYiLCJvayIsImRldGFpbCIsInN0YXR1c1RleHQiLCJleGFtcGxlIiwiX2hvc3RVcmwiLCJjcmVhdGVQcm9qZWN0IiwiZGVzY3JpcHRpb24iLCJ1cHNlcnQiLCJwcm9qZWN0RXh0cmEiLCJyZWZlcmVuY2VEYXRhc2V0SWQiLCJ1cHNlcnRfIiwiZW5kcG9pbnQiLCJzZXJpYWxpemVkQm9keSIsInVwZGF0ZVByb2plY3QiLCJoYXNQcm9qZWN0IiwiaW5jbHVkZVN0YXRzIiwiZ2V0UHJvamVjdFVybCIsImdldERhdGFzZXRVcmwiLCJfdGVuYW50SWQiLCJwcm9qZWN0cyIsInRlbmFudF9pZCIsImxpc3RQcm9qZWN0cyIsIm5hbWVDb250YWlucyIsInJlZmVyZW5jZURhdGFzZXROYW1lIiwiZGF0YXNldFZlcnNpb24iLCJyZWZlcmVuY2VGcmVlIiwiZGVsZXRlUHJvamVjdCIsInByb2plY3RJZF8iLCJ1cGxvYWRDc3YiLCJjc3ZGaWxlIiwiZmlsZU5hbWUiLCJpbnB1dEtleXMiLCJvdXRwdXRLZXlzIiwiZGF0YVR5cGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiY3JlYXRlRGF0YXNldCIsImlucHV0c1NjaGVtYSIsIm91dHB1dHNTY2hlbWEiLCJkYXRhX3R5cGUiLCJpbnB1dHNfc2NoZW1hX2RlZmluaXRpb24iLCJvdXRwdXRzX3NjaGVtYV9kZWZpbml0aW9uIiwiaGFzRGF0YXNldCIsInRvTG9jYWxlTG93ZXJDYXNlIiwiZGlmZkRhdGFzZXRWZXJzaW9ucyIsImZyb21WZXJzaW9uIiwidG9WZXJzaW9uIiwiZGF0YXNldElkXyIsImZyb21fdmVyc2lvbiIsInRvX3ZlcnNpb24iLCJyZWFkRGF0YXNldE9wZW5haUZpbmV0dW5pbmciLCJkYXRhc2V0VGV4dCIsInRleHQiLCJsaW5lIiwicGFyc2UiLCJsaXN0RGF0YXNldHMiLCJkYXRhc2V0SWRzIiwiZGF0YXNldE5hbWVDb250YWlucyIsImlkXyIsImRhdGFzZXRzIiwidXBkYXRlRGF0YXNldCIsIl9kYXRhc2V0SWQiLCJ1cGRhdGVEYXRhc2V0VGFnIiwiYXNPZiIsInRhZyIsImFzX29mIiwiZGVsZXRlRGF0YXNldCIsImluZGV4RGF0YXNldCIsInNpbWlsYXJFeGFtcGxlcyIsImNyZWF0ZUV4YW1wbGUiLCJpbnB1dHNPclVwZGF0ZSIsImlzRXhhbXBsZUNyZWF0ZSIsImRhdGFzZXROYW1lXyIsImRhdGFzZXRfbmFtZSIsImNyZWF0ZWRBdF8iLCJjcmVhdGVkQXQiLCJjcmVhdGVkX2F0IiwiZXhhbXBsZUlkIiwic291cmNlX3J1bl9pZCIsInNvdXJjZVJ1bklkIiwidXNlX3NvdXJjZV9ydW5faW8iLCJ1c2VTb3VyY2VSdW5JTyIsInVzZV9zb3VyY2VfcnVuX2F0dGFjaG1lbnRzIiwidXNlU291cmNlUnVuQXR0YWNobWVudHMiLCJfdXBsb2FkRXhhbXBsZXNNdWx0aXBhcnQiLCJyZWFkRXhhbXBsZSIsImV4YW1wbGVfaWRzIiwiY3JlYXRlRXhhbXBsZXMiLCJwcm9wc09yVXBsb2FkcyIsInVwbG9hZHMiLCJleGFtcGxlcyIsInNwbGl0cyIsInNvdXJjZVJ1bklkcyIsInVzZVNvdXJjZVJ1bklPcyIsImZvcm1hdHRlZEV4YW1wbGVzIiwiaW5wdXQiLCJpZHgiLCJjcmVhdGVMTE1FeGFtcGxlIiwiZ2VuZXJhdGlvbiIsIm91dHB1dCIsImNyZWF0ZUNoYXRFeGFtcGxlIiwiZ2VuZXJhdGlvbnMiLCJmaW5hbElucHV0IiwiZmluYWxPdXRwdXQiLCJyYXdFeGFtcGxlIiwiYXR0YWNobWVudF91cmxzIiwicmVzdCIsInByZXNpZ25lZF91cmwiLCJtaW1lX3R5cGUiLCJsaXN0RXhhbXBsZXMiLCJpbmxpbmVTM1VybHMiLCJpbmNsdWRlQXR0YWNobWVudHMiLCJkYXRhc2V0X3ZlcnNpb24iLCJpbmxpbmVTM1VybHNfIiwic2VyaWFsaXplZE1ldGFkYXRhIiwiZmllbGQiLCJpIiwicmF3RXhhbXBsZXMiLCJkZWxldGVFeGFtcGxlIiwiZGVsZXRlRXhhbXBsZXMiLCJoYXJkRGVsZXRlIiwiaGFyZF9kZWxldGUiLCJ1cGRhdGVFeGFtcGxlIiwiZXhhbXBsZUlkT3JVcGRhdGUiLCJ1cGRhdGVUb1VzZSIsIl91cGRhdGVFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZUV4YW1wbGVzIiwicmVhZERhdGFzZXRWZXJzaW9uIiwicmVzb2x2ZWREYXRhc2V0SWQiLCJsaXN0RGF0YXNldFNwbGl0cyIsInVwZGF0ZURhdGFzZXRTcGxpdHMiLCJzcGxpdE5hbWUiLCJyZW1vdmUiLCJzcGxpdF9uYW1lIiwiY3JlYXRlRmVlZGJhY2siLCJjb3JyZWN0aW9uIiwiY29tbWVudCIsInNvdXJjZUluZm8iLCJmZWVkYmFja1NvdXJjZVR5cGUiLCJmZWVkYmFja0lkIiwiZmVlZGJhY2tDb25maWciLCJjb21wYXJhdGl2ZUV4cGVyaW1lbnRJZCIsImZlZWRiYWNrX3NvdXJjZSIsImZlZWRiYWNrIiwiY29tcGFyYXRpdmVfZXhwZXJpbWVudF9pZCIsInVwZGF0ZUZlZWRiYWNrIiwiZmVlZGJhY2tVcGRhdGUiLCJyZWFkRmVlZGJhY2siLCJkZWxldGVGZWVkYmFjayIsImxpc3RGZWVkYmFjayIsImZlZWRiYWNrS2V5cyIsImZlZWRiYWNrU291cmNlVHlwZXMiLCJmZWVkYmFja3MiLCJjcmVhdGVQcmVzaWduZWRGZWVkYmFja1Rva2VuIiwiZmVlZGJhY2tLZXkiLCJleHBpcmF0aW9uIiwiZmVlZGJhY2tfa2V5IiwiZmVlZGJhY2tfY29uZmlnIiwiaG91cnMiLCJtaW51dGVzIiwiZGF5cyIsImNyZWF0ZUNvbXBhcmF0aXZlRXhwZXJpbWVudCIsImV4cGVyaW1lbnRJZHMiLCJyZWZlcmVuY2VfZGF0YXNldF9pZCIsImV4cGVyaW1lbnRfaWRzIiwibGlzdFByZXNpZ25lZEZlZWRiYWNrVG9rZW5zIiwidG9rZW5zIiwiX3NlbGVjdEV2YWxSZXN1bHRzIiwicmVzdWx0cyIsInJlc3VsdHNfIiwiX2xvZ0V2YWx1YXRpb25GZWVkYmFjayIsImV2YWx1YXRvclJlc3BvbnNlIiwiZXZhbFJlc3VsdHMiLCJzb3VyY2VJbmZvXyIsImV2YWx1YXRvckluZm8iLCJydW5JZF8iLCJ0YXJnZXRSdW5JZCIsImxvZ0V2YWx1YXRpb25GZWVkYmFjayIsImxpc3RBbm5vdGF0aW9uUXVldWVzIiwicXVldWVJZHMiLCJtaW4iLCJjb3VudCIsInF1ZXVlcyIsImNyZWF0ZUFubm90YXRpb25RdWV1ZSIsInF1ZXVlSWQiLCJydWJyaWNJbnN0cnVjdGlvbnMiLCJydWJyaWNfaW5zdHJ1Y3Rpb25zIiwicmVhZEFubm90YXRpb25RdWV1ZSIsInVwZGF0ZUFubm90YXRpb25RdWV1ZSIsImRlbGV0ZUFubm90YXRpb25RdWV1ZSIsImFkZFJ1bnNUb0Fubm90YXRpb25RdWV1ZSIsImdldFJ1bkZyb21Bbm5vdGF0aW9uUXVldWUiLCJpbmRleCIsImRlbGV0ZVJ1bkZyb21Bbm5vdGF0aW9uUXVldWUiLCJxdWV1ZVJ1bklkIiwiZ2V0U2l6ZUZyb21Bbm5vdGF0aW9uUXVldWUiLCJfY3VycmVudFRlbmFudElzT3duZXIiLCJvd25lciIsInRlbmFudF9oYW5kbGUiLCJfb3duZXJDb25mbGljdEVycm9yIiwiX2dldExhdGVzdENvbW1pdEhhc2giLCJwcm9tcHRPd25lckFuZE5hbWUiLCJjb21taXRzIiwiY29tbWl0X2hhc2giLCJfbGlrZU9yVW5saWtlUHJvbXB0IiwicHJvbXB0SWRlbnRpZmllciIsImxpa2UiLCJwcm9tcHROYW1lIiwiX2dldFByb21wdFVybCIsImNvbW1pdEhhc2giLCJzdWJzdHJpbmciLCJwcm9tcHRFeGlzdHMiLCJwcm9tcHQiLCJnZXRQcm9tcHQiLCJsaWtlUHJvbXB0IiwidW5saWtlUHJvbXB0IiwibGlzdENvbW1pdHMiLCJsaXN0UHJvbXB0cyIsInNvcnRGaWVsZCIsImlzQXJjaGl2ZWQiLCJpc1B1YmxpYyIsInByb21wdHMiLCJyZXBvcyIsInJlcG8iLCJjcmVhdGVQcm9tcHQiLCJyZXBvX2hhbmRsZSIsInJlYWRtZSIsInRhZ3MiLCJpc19wdWJsaWMiLCJjcmVhdGVDb21taXQiLCJvYmplY3QiLCJyZXNvbHZlZFBhcmVudENvbW1pdEhhc2giLCJwYXJlbnRDb21taXRIYXNoIiwibWFuaWZlc3QiLCJwYXJlbnRfY29tbWl0IiwidXBkYXRlRXhhbXBsZXNNdWx0aXBhcnQiLCJ1cGRhdGVzIiwiZXhhbXBsZUJvZHkiLCJzdHJpbmdpZmllZEV4YW1wbGUiLCJleGFtcGxlQmxvYiIsInN0cmluZ2lmaWVkSW5wdXRzIiwiaW5wdXRzQmxvYiIsInN0cmluZ2lmaWVkT3V0cHV0cyIsIm91dHB1dHNCbG9iIiwiYXR0YWNobWVudEJsb2IiLCJhdHRhY2htZW50c19vcGVyYXRpb25zIiwic3RyaW5naWZpZWRBdHRhY2htZW50c09wZXJhdGlvbnMiLCJhdHRhY2htZW50c09wZXJhdGlvbnNCbG9iIiwiZGF0YXNldElkVG9Vc2UiLCJ1cGxvYWRFeGFtcGxlc011bHRpcGFydCIsInVwZGF0ZVByb21wdCIsImlzX2FyY2hpdmVkIiwia2V5cyIsImRlbGV0ZVByb21wdCIsInB1bGxQcm9tcHRDb21taXQiLCJpbmNsdWRlTW9kZWwiLCJfcHVsbFByb21wdCIsInByb21wdE9iamVjdCIsInB1c2hQcm9tcHQiLCJzb21lIiwiY2xvbmVQdWJsaWNEYXRhc2V0IiwidG9rZW5PclVybCIsInNvdXJjZUFwaVVybCIsInBhcnNlZEFwaVVybCIsInRva2VuVXVpZCIsInBhcnNlVG9rZW5PclVybCIsInNvdXJjZUNsaWVudCIsImRzIiwiZmluYWxEYXRhc2V0TmFtZSIsImZsYXRNYXAiLCJ1cmxPclRva2VuIiwibnVtUGFydHMiLCJraW5kIiwicGFyc2VkVXJsIiwiVVJMIiwicGF0aFBhcnRzIiwicGF0aG5hbWUiLCJhd2FpdFBlbmRpbmdUcmFjZUJhdGNoZXMiLCJxdWV1ZSIsIm9uSWRsZSIsIkRFRkFVTFRfTEFOR1NNSVRIX1NQQU5fUFJPQ0VTU09SIiwiZm9yY2VGbHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/env.js":
/*!********************************************!*\
  !*** ./node_modules/langsmith/dist/env.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isTracingEnabled: () => (/* binding */ isTracingEnabled)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst isTracingEnabled = (tracingEnabled)=>{\n    if (tracingEnabled !== undefined) {\n        return tracingEnabled;\n    }\n    const envVars = [\n        \"TRACING_V2\",\n        \"TRACING\"\n    ];\n    return !!envVars.find((envVar)=>(0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(envVar) === \"true\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlFO0FBQzFELE1BQU1DLG1CQUFtQixDQUFDQztJQUM3QixJQUFJQSxtQkFBbUJDLFdBQVc7UUFDOUIsT0FBT0Q7SUFDWDtJQUNBLE1BQU1FLFVBQVU7UUFBQztRQUFjO0tBQVU7SUFDekMsT0FBTyxDQUFDLENBQUNBLFFBQVFDLElBQUksQ0FBQyxDQUFDQyxTQUFXTiw4RUFBK0JBLENBQUNNLFlBQVk7QUFDbEYsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9lbnYuanM/ZTU5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5leHBvcnQgY29uc3QgaXNUcmFjaW5nRW5hYmxlZCA9ICh0cmFjaW5nRW5hYmxlZCkgPT4ge1xuICAgIGlmICh0cmFjaW5nRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cmFjaW5nRW5hYmxlZDtcbiAgICB9XG4gICAgY29uc3QgZW52VmFycyA9IFtcIlRSQUNJTkdfVjJcIiwgXCJUUkFDSU5HXCJdO1xuICAgIHJldHVybiAhIWVudlZhcnMuZmluZCgoZW52VmFyKSA9PiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKGVudlZhcikgPT09IFwidHJ1ZVwiKTtcbn07XG4iXSwibmFtZXMiOlsiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsImlzVHJhY2luZ0VuYWJsZWQiLCJ0cmFjaW5nRW5hYmxlZCIsInVuZGVmaW5lZCIsImVudlZhcnMiLCJmaW5kIiwiZW52VmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js":
/*!********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AI_SDK_LLM_OPERATIONS: () => (/* binding */ AI_SDK_LLM_OPERATIONS),\n/* harmony export */   AI_SDK_TOOL_OPERATIONS: () => (/* binding */ AI_SDK_TOOL_OPERATIONS),\n/* harmony export */   GENAI_COMPLETION: () => (/* binding */ GENAI_COMPLETION),\n/* harmony export */   GENAI_PROMPT: () => (/* binding */ GENAI_PROMPT),\n/* harmony export */   GEN_AI_ASSISTANT_MESSAGE: () => (/* binding */ GEN_AI_ASSISTANT_MESSAGE),\n/* harmony export */   GEN_AI_CHOICE: () => (/* binding */ GEN_AI_CHOICE),\n/* harmony export */   GEN_AI_OPERATION_NAME: () => (/* binding */ GEN_AI_OPERATION_NAME),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_BODY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_BODY),\n/* harmony export */   GEN_AI_REQUEST_EXTRA_QUERY: () => (/* binding */ GEN_AI_REQUEST_EXTRA_QUERY),\n/* harmony export */   GEN_AI_REQUEST_FREQUENCY_PENALTY: () => (/* binding */ GEN_AI_REQUEST_FREQUENCY_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_MAX_TOKENS: () => (/* binding */ GEN_AI_REQUEST_MAX_TOKENS),\n/* harmony export */   GEN_AI_REQUEST_MODEL: () => (/* binding */ GEN_AI_REQUEST_MODEL),\n/* harmony export */   GEN_AI_REQUEST_PRESENCE_PENALTY: () => (/* binding */ GEN_AI_REQUEST_PRESENCE_PENALTY),\n/* harmony export */   GEN_AI_REQUEST_TEMPERATURE: () => (/* binding */ GEN_AI_REQUEST_TEMPERATURE),\n/* harmony export */   GEN_AI_REQUEST_TOP_P: () => (/* binding */ GEN_AI_REQUEST_TOP_P),\n/* harmony export */   GEN_AI_RESPONSE_FINISH_REASONS: () => (/* binding */ GEN_AI_RESPONSE_FINISH_REASONS),\n/* harmony export */   GEN_AI_RESPONSE_ID: () => (/* binding */ GEN_AI_RESPONSE_ID),\n/* harmony export */   GEN_AI_RESPONSE_MODEL: () => (/* binding */ GEN_AI_RESPONSE_MODEL),\n/* harmony export */   GEN_AI_RESPONSE_SERVICE_TIER: () => (/* binding */ GEN_AI_RESPONSE_SERVICE_TIER),\n/* harmony export */   GEN_AI_RESPONSE_SYSTEM_FINGERPRINT: () => (/* binding */ GEN_AI_RESPONSE_SYSTEM_FINGERPRINT),\n/* harmony export */   GEN_AI_SERIALIZED_DOC: () => (/* binding */ GEN_AI_SERIALIZED_DOC),\n/* harmony export */   GEN_AI_SERIALIZED_NAME: () => (/* binding */ GEN_AI_SERIALIZED_NAME),\n/* harmony export */   GEN_AI_SERIALIZED_SIGNATURE: () => (/* binding */ GEN_AI_SERIALIZED_SIGNATURE),\n/* harmony export */   GEN_AI_SYSTEM: () => (/* binding */ GEN_AI_SYSTEM),\n/* harmony export */   GEN_AI_SYSTEM_MESSAGE: () => (/* binding */ GEN_AI_SYSTEM_MESSAGE),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_INPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_INPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKENS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKENS),\n/* harmony export */   GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS: () => (/* binding */ GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS),\n/* harmony export */   GEN_AI_USAGE_TOTAL_TOKENS: () => (/* binding */ GEN_AI_USAGE_TOTAL_TOKENS),\n/* harmony export */   GEN_AI_USER_MESSAGE: () => (/* binding */ GEN_AI_USER_MESSAGE),\n/* harmony export */   LANGSMITH_DOTTED_ORDER: () => (/* binding */ LANGSMITH_DOTTED_ORDER),\n/* harmony export */   LANGSMITH_IS_ROOT: () => (/* binding */ LANGSMITH_IS_ROOT),\n/* harmony export */   LANGSMITH_METADATA: () => (/* binding */ LANGSMITH_METADATA),\n/* harmony export */   LANGSMITH_NAME: () => (/* binding */ LANGSMITH_NAME),\n/* harmony export */   LANGSMITH_PARENT_RUN_ID: () => (/* binding */ LANGSMITH_PARENT_RUN_ID),\n/* harmony export */   LANGSMITH_REFERENCE_EXAMPLE_ID: () => (/* binding */ LANGSMITH_REFERENCE_EXAMPLE_ID),\n/* harmony export */   LANGSMITH_REQUEST_HEADERS: () => (/* binding */ LANGSMITH_REQUEST_HEADERS),\n/* harmony export */   LANGSMITH_REQUEST_STREAMING: () => (/* binding */ LANGSMITH_REQUEST_STREAMING),\n/* harmony export */   LANGSMITH_RUNTIME: () => (/* binding */ LANGSMITH_RUNTIME),\n/* harmony export */   LANGSMITH_RUN_ID: () => (/* binding */ LANGSMITH_RUN_ID),\n/* harmony export */   LANGSMITH_RUN_TYPE: () => (/* binding */ LANGSMITH_RUN_TYPE),\n/* harmony export */   LANGSMITH_SESSION_ID: () => (/* binding */ LANGSMITH_SESSION_ID),\n/* harmony export */   LANGSMITH_SESSION_NAME: () => (/* binding */ LANGSMITH_SESSION_NAME),\n/* harmony export */   LANGSMITH_TAGS: () => (/* binding */ LANGSMITH_TAGS),\n/* harmony export */   LANGSMITH_TRACEABLE: () => (/* binding */ LANGSMITH_TRACEABLE),\n/* harmony export */   LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID: () => (/* binding */ LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID),\n/* harmony export */   LANGSMITH_TRACE_ID: () => (/* binding */ LANGSMITH_TRACE_ID),\n/* harmony export */   LANGSMITH_USAGE_METADATA: () => (/* binding */ LANGSMITH_USAGE_METADATA)\n/* harmony export */ });\n// OpenTelemetry GenAI semantic convention attribute names\nconst GEN_AI_OPERATION_NAME = \"gen_ai.operation.name\";\nconst GEN_AI_SYSTEM = \"gen_ai.system\";\nconst GEN_AI_REQUEST_MODEL = \"gen_ai.request.model\";\nconst GEN_AI_RESPONSE_MODEL = \"gen_ai.response.model\";\nconst GEN_AI_USAGE_INPUT_TOKENS = \"gen_ai.usage.input_tokens\";\nconst GEN_AI_USAGE_OUTPUT_TOKENS = \"gen_ai.usage.output_tokens\";\nconst GEN_AI_USAGE_TOTAL_TOKENS = \"gen_ai.usage.total_tokens\";\nconst GEN_AI_REQUEST_MAX_TOKENS = \"gen_ai.request.max_tokens\";\nconst GEN_AI_REQUEST_TEMPERATURE = \"gen_ai.request.temperature\";\nconst GEN_AI_REQUEST_TOP_P = \"gen_ai.request.top_p\";\nconst GEN_AI_REQUEST_FREQUENCY_PENALTY = \"gen_ai.request.frequency_penalty\";\nconst GEN_AI_REQUEST_PRESENCE_PENALTY = \"gen_ai.request.presence_penalty\";\nconst GEN_AI_RESPONSE_FINISH_REASONS = \"gen_ai.response.finish_reasons\";\nconst GENAI_PROMPT = \"gen_ai.prompt\";\nconst GENAI_COMPLETION = \"gen_ai.completion\";\nconst GEN_AI_REQUEST_EXTRA_QUERY = \"gen_ai.request.extra_query\";\nconst GEN_AI_REQUEST_EXTRA_BODY = \"gen_ai.request.extra_body\";\nconst GEN_AI_SERIALIZED_NAME = \"gen_ai.serialized.name\";\nconst GEN_AI_SERIALIZED_SIGNATURE = \"gen_ai.serialized.signature\";\nconst GEN_AI_SERIALIZED_DOC = \"gen_ai.serialized.doc\";\nconst GEN_AI_RESPONSE_ID = \"gen_ai.response.id\";\nconst GEN_AI_RESPONSE_SERVICE_TIER = \"gen_ai.response.service_tier\";\nconst GEN_AI_RESPONSE_SYSTEM_FINGERPRINT = \"gen_ai.response.system_fingerprint\";\nconst GEN_AI_USAGE_INPUT_TOKEN_DETAILS = \"gen_ai.usage.input_token_details\";\nconst GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS = \"gen_ai.usage.output_token_details\";\n// LangSmith custom attributes\nconst LANGSMITH_SESSION_ID = \"langsmith.trace.session_id\";\nconst LANGSMITH_SESSION_NAME = \"langsmith.trace.session_name\";\nconst LANGSMITH_RUN_TYPE = \"langsmith.span.kind\";\nconst LANGSMITH_NAME = \"langsmith.trace.name\";\nconst LANGSMITH_METADATA = \"langsmith.metadata\";\nconst LANGSMITH_TAGS = \"langsmith.span.tags\";\nconst LANGSMITH_RUNTIME = \"langsmith.span.runtime\";\nconst LANGSMITH_REQUEST_STREAMING = \"langsmith.request.streaming\";\nconst LANGSMITH_REQUEST_HEADERS = \"langsmith.request.headers\";\nconst LANGSMITH_RUN_ID = \"langsmith.span.id\";\nconst LANGSMITH_TRACE_ID = \"langsmith.trace.id\";\nconst LANGSMITH_DOTTED_ORDER = \"langsmith.span.dotted_order\";\nconst LANGSMITH_PARENT_RUN_ID = \"langsmith.span.parent_id\";\nconst LANGSMITH_USAGE_METADATA = \"langsmith.usage_metadata\";\nconst LANGSMITH_REFERENCE_EXAMPLE_ID = \"langsmith.reference_example_id\";\nconst LANGSMITH_TRACEABLE = \"langsmith.traceable\";\nconst LANGSMITH_IS_ROOT = \"langsmith.is_root\";\nconst LANGSMITH_TRACEABLE_PARENT_OTEL_SPAN_ID = \"langsmith.traceable_parent_otel_span_id\";\n// GenAI event names\nconst GEN_AI_SYSTEM_MESSAGE = \"gen_ai.system.message\";\nconst GEN_AI_USER_MESSAGE = \"gen_ai.user.message\";\nconst GEN_AI_ASSISTANT_MESSAGE = \"gen_ai.assistant.message\";\nconst GEN_AI_CHOICE = \"gen_ai.choice\";\nconst AI_SDK_LLM_OPERATIONS = [\n    \"ai.generateText.doGenerate\",\n    \"ai.streamText.doStream\",\n    \"ai.generateObject.doGenerate\",\n    \"ai.streamObject.doStream\"\n];\nconst AI_SDK_TOOL_OPERATIONS = [\n    \"ai.toolCall\"\n];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwwREFBMEQ7QUFDbkQsTUFBTUEsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyxnQkFBZ0IsZ0JBQWdCO0FBQ3RDLE1BQU1DLHVCQUF1Qix1QkFBdUI7QUFDcEQsTUFBTUMsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsNEJBQTRCLDRCQUE0QjtBQUM5RCxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsdUJBQXVCLHVCQUF1QjtBQUNwRCxNQUFNQyxtQ0FBbUMsbUNBQW1DO0FBQzVFLE1BQU1DLGtDQUFrQyxrQ0FBa0M7QUFDMUUsTUFBTUMsaUNBQWlDLGlDQUFpQztBQUN4RSxNQUFNQyxlQUFlLGdCQUFnQjtBQUNyQyxNQUFNQyxtQkFBbUIsb0JBQW9CO0FBQzdDLE1BQU1DLDZCQUE2Qiw2QkFBNkI7QUFDaEUsTUFBTUMsNEJBQTRCLDRCQUE0QjtBQUM5RCxNQUFNQyx5QkFBeUIseUJBQXlCO0FBQ3hELE1BQU1DLDhCQUE4Qiw4QkFBOEI7QUFDbEUsTUFBTUMsd0JBQXdCLHdCQUF3QjtBQUN0RCxNQUFNQyxxQkFBcUIscUJBQXFCO0FBQ2hELE1BQU1DLCtCQUErQiwrQkFBK0I7QUFDcEUsTUFBTUMscUNBQXFDLHFDQUFxQztBQUNoRixNQUFNQyxtQ0FBbUMsbUNBQW1DO0FBQzVFLE1BQU1DLG9DQUFvQyxvQ0FBb0M7QUFDckYsOEJBQThCO0FBQ3ZCLE1BQU1DLHVCQUF1Qiw2QkFBNkI7QUFDMUQsTUFBTUMseUJBQXlCLCtCQUErQjtBQUM5RCxNQUFNQyxxQkFBcUIsc0JBQXNCO0FBQ2pELE1BQU1DLGlCQUFpQix1QkFBdUI7QUFDOUMsTUFBTUMscUJBQXFCLHFCQUFxQjtBQUNoRCxNQUFNQyxpQkFBaUIsc0JBQXNCO0FBQzdDLE1BQU1DLG9CQUFvQix5QkFBeUI7QUFDbkQsTUFBTUMsOEJBQThCLDhCQUE4QjtBQUNsRSxNQUFNQyw0QkFBNEIsNEJBQTRCO0FBQzlELE1BQU1DLG1CQUFtQixvQkFBb0I7QUFDN0MsTUFBTUMscUJBQXFCLHFCQUFxQjtBQUNoRCxNQUFNQyx5QkFBeUIsOEJBQThCO0FBQzdELE1BQU1DLDBCQUEwQiwyQkFBMkI7QUFDM0QsTUFBTUMsMkJBQTJCLDJCQUEyQjtBQUM1RCxNQUFNQyxpQ0FBaUMsaUNBQWlDO0FBQ3hFLE1BQU1DLHNCQUFzQixzQkFBc0I7QUFDbEQsTUFBTUMsb0JBQW9CLG9CQUFvQjtBQUM5QyxNQUFNQywwQ0FBMEMsMENBQTBDO0FBQ2pHLG9CQUFvQjtBQUNiLE1BQU1DLHdCQUF3Qix3QkFBd0I7QUFDdEQsTUFBTUMsc0JBQXNCLHNCQUFzQjtBQUNsRCxNQUFNQywyQkFBMkIsMkJBQTJCO0FBQzVELE1BQU1DLGdCQUFnQixnQkFBZ0I7QUFDdEMsTUFBTUMsd0JBQXdCO0lBQ2pDO0lBQ0E7SUFDQTtJQUNBO0NBQ0gsQ0FBQztBQUNLLE1BQU1DLHlCQUF5QjtJQUFDO0NBQWMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC9jb25zdGFudHMuanM/ZDAzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBPcGVuVGVsZW1ldHJ5IEdlbkFJIHNlbWFudGljIGNvbnZlbnRpb24gYXR0cmlidXRlIG5hbWVzXG5leHBvcnQgY29uc3QgR0VOX0FJX09QRVJBVElPTl9OQU1FID0gXCJnZW5fYWkub3BlcmF0aW9uLm5hbWVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNID0gXCJnZW5fYWkuc3lzdGVtXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFUVVFU1RfTU9ERUwgPSBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX01PREVMID0gXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TID0gXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUyA9IFwiZ2VuX2FpLnVzYWdlLnRvdGFsX3Rva2Vuc1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX01BWF9UT0tFTlMgPSBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRSA9IFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9UT1BfUCA9IFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSA9IFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZID0gXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TID0gXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9QUk9NUFQgPSBcImdlbl9haS5wcm9tcHRcIjtcbmV4cG9ydCBjb25zdCBHRU5BSV9DT01QTEVUSU9OID0gXCJnZW5fYWkuY29tcGxldGlvblwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZID0gXCJnZW5fYWkucmVxdWVzdC5leHRyYV9xdWVyeVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFkgPSBcImdlbl9haS5yZXF1ZXN0LmV4dHJhX2JvZHlcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9OQU1FID0gXCJnZW5fYWkuc2VyaWFsaXplZC5uYW1lXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1NFUklBTElaRURfU0lHTkFUVVJFID0gXCJnZW5fYWkuc2VyaWFsaXplZC5zaWduYXR1cmVcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfU0VSSUFMSVpFRF9ET0MgPSBcImdlbl9haS5zZXJpYWxpemVkLmRvY1wiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9JRCA9IFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI7XG5leHBvcnQgY29uc3QgR0VOX0FJX1JFU1BPTlNFX1NFUlZJQ0VfVElFUiA9IFwiZ2VuX2FpLnJlc3BvbnNlLnNlcnZpY2VfdGllclwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9SRVNQT05TRV9TWVNURU1fRklOR0VSUFJJTlQgPSBcImdlbl9haS5yZXNwb25zZS5zeXN0ZW1fZmluZ2VycHJpbnRcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUyA9IFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2VuX2RldGFpbHNcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMgPSBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5fZGV0YWlsc1wiO1xuLy8gTGFuZ1NtaXRoIGN1c3RvbSBhdHRyaWJ1dGVzXG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fSUQgPSBcImxhbmdzbWl0aC50cmFjZS5zZXNzaW9uX2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1NFU1NJT05fTkFNRSA9IFwibGFuZ3NtaXRoLnRyYWNlLnNlc3Npb25fbmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fVFlQRSA9IFwibGFuZ3NtaXRoLnNwYW4ua2luZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9OQU1FID0gXCJsYW5nc21pdGgudHJhY2UubmFtZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9NRVRBREFUQSA9IFwibGFuZ3NtaXRoLm1ldGFkYXRhXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RBR1MgPSBcImxhbmdzbWl0aC5zcGFuLnRhZ3NcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUlVOVElNRSA9IFwibGFuZ3NtaXRoLnNwYW4ucnVudGltZVwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SRVFVRVNUX1NUUkVBTUlORyA9IFwibGFuZ3NtaXRoLnJlcXVlc3Quc3RyZWFtaW5nXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUyA9IFwibGFuZ3NtaXRoLnJlcXVlc3QuaGVhZGVyc1wiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9SVU5fSUQgPSBcImxhbmdzbWl0aC5zcGFuLmlkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1RSQUNFX0lEID0gXCJsYW5nc21pdGgudHJhY2UuaWRcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfRE9UVEVEX09SREVSID0gXCJsYW5nc21pdGguc3Bhbi5kb3R0ZWRfb3JkZXJcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUEFSRU5UX1JVTl9JRCA9IFwibGFuZ3NtaXRoLnNwYW4ucGFyZW50X2lkXCI7XG5leHBvcnQgY29uc3QgTEFOR1NNSVRIX1VTQUdFX01FVEFEQVRBID0gXCJsYW5nc21pdGgudXNhZ2VfbWV0YWRhdGFcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfUkVGRVJFTkNFX0VYQU1QTEVfSUQgPSBcImxhbmdzbWl0aC5yZWZlcmVuY2VfZXhhbXBsZV9pZFwiO1xuZXhwb3J0IGNvbnN0IExBTkdTTUlUSF9UUkFDRUFCTEUgPSBcImxhbmdzbWl0aC50cmFjZWFibGVcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfSVNfUk9PVCA9IFwibGFuZ3NtaXRoLmlzX3Jvb3RcIjtcbmV4cG9ydCBjb25zdCBMQU5HU01JVEhfVFJBQ0VBQkxFX1BBUkVOVF9PVEVMX1NQQU5fSUQgPSBcImxhbmdzbWl0aC50cmFjZWFibGVfcGFyZW50X290ZWxfc3Bhbl9pZFwiO1xuLy8gR2VuQUkgZXZlbnQgbmFtZXNcbmV4cG9ydCBjb25zdCBHRU5fQUlfU1lTVEVNX01FU1NBR0UgPSBcImdlbl9haS5zeXN0ZW0ubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9VU0VSX01FU1NBR0UgPSBcImdlbl9haS51c2VyLm1lc3NhZ2VcIjtcbmV4cG9ydCBjb25zdCBHRU5fQUlfQVNTSVNUQU5UX01FU1NBR0UgPSBcImdlbl9haS5hc3Npc3RhbnQubWVzc2FnZVwiO1xuZXhwb3J0IGNvbnN0IEdFTl9BSV9DSE9JQ0UgPSBcImdlbl9haS5jaG9pY2VcIjtcbmV4cG9ydCBjb25zdCBBSV9TREtfTExNX09QRVJBVElPTlMgPSBbXG4gICAgXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgIFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgIFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG5dO1xuZXhwb3J0IGNvbnN0IEFJX1NES19UT09MX09QRVJBVElPTlMgPSBbXCJhaS50b29sQ2FsbFwiXTtcbiJdLCJuYW1lcyI6WyJHRU5fQUlfT1BFUkFUSU9OX05BTUUiLCJHRU5fQUlfU1lTVEVNIiwiR0VOX0FJX1JFUVVFU1RfTU9ERUwiLCJHRU5fQUlfUkVTUE9OU0VfTU9ERUwiLCJHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5TIiwiR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMiLCJHRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TIiwiR0VOX0FJX1JFUVVFU1RfTUFYX1RPS0VOUyIsIkdFTl9BSV9SRVFVRVNUX1RFTVBFUkFUVVJFIiwiR0VOX0FJX1JFUVVFU1RfVE9QX1AiLCJHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSIsIkdFTl9BSV9SRVFVRVNUX1BSRVNFTkNFX1BFTkFMVFkiLCJHRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlMiLCJHRU5BSV9QUk9NUFQiLCJHRU5BSV9DT01QTEVUSU9OIiwiR0VOX0FJX1JFUVVFU1RfRVhUUkFfUVVFUlkiLCJHRU5fQUlfUkVRVUVTVF9FWFRSQV9CT0RZIiwiR0VOX0FJX1NFUklBTElaRURfTkFNRSIsIkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSIsIkdFTl9BSV9TRVJJQUxJWkVEX0RPQyIsIkdFTl9BSV9SRVNQT05TRV9JRCIsIkdFTl9BSV9SRVNQT05TRV9TRVJWSUNFX1RJRVIiLCJHRU5fQUlfUkVTUE9OU0VfU1lTVEVNX0ZJTkdFUlBSSU5UIiwiR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOX0RFVEFJTFMiLCJHRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMiLCJMQU5HU01JVEhfU0VTU0lPTl9JRCIsIkxBTkdTTUlUSF9TRVNTSU9OX05BTUUiLCJMQU5HU01JVEhfUlVOX1RZUEUiLCJMQU5HU01JVEhfTkFNRSIsIkxBTkdTTUlUSF9NRVRBREFUQSIsIkxBTkdTTUlUSF9UQUdTIiwiTEFOR1NNSVRIX1JVTlRJTUUiLCJMQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkciLCJMQU5HU01JVEhfUkVRVUVTVF9IRUFERVJTIiwiTEFOR1NNSVRIX1JVTl9JRCIsIkxBTkdTTUlUSF9UUkFDRV9JRCIsIkxBTkdTTUlUSF9ET1RURURfT1JERVIiLCJMQU5HU01JVEhfUEFSRU5UX1JVTl9JRCIsIkxBTkdTTUlUSF9VU0FHRV9NRVRBREFUQSIsIkxBTkdTTUlUSF9SRUZFUkVOQ0VfRVhBTVBMRV9JRCIsIkxBTkdTTUlUSF9UUkFDRUFCTEUiLCJMQU5HU01JVEhfSVNfUk9PVCIsIkxBTkdTTUlUSF9UUkFDRUFCTEVfUEFSRU5UX09URUxfU1BBTl9JRCIsIkdFTl9BSV9TWVNURU1fTUVTU0FHRSIsIkdFTl9BSV9VU0VSX01FU1NBR0UiLCJHRU5fQUlfQVNTSVNUQU5UX01FU1NBR0UiLCJHRU5fQUlfQ0hPSUNFIiwiQUlfU0RLX0xMTV9PUEVSQVRJT05TIiwiQUlfU0RLX1RPT0xfT1BFUkFUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/dist/experimental/otel/translator.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LangSmithToOTELTranslator: () => (/* binding */ LangSmithToOTELTranslator)\n/* harmony export */ });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"(rsc)/./node_modules/langsmith/dist/experimental/otel/constants.js\");\n/* harmony import */ var _singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../singletons/otel.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/otel.js\");\n\n\nconst WELL_KNOWN_OPERATION_NAMES = {\n    llm: \"chat\",\n    tool: \"execute_tool\",\n    retriever: \"embeddings\",\n    embedding: \"embeddings\",\n    prompt: \"chat\"\n};\nfunction getOperationName(runType) {\n    return WELL_KNOWN_OPERATION_NAMES[runType] || runType;\n}\nclass LangSmithToOTELTranslator {\n    constructor(){\n        Object.defineProperty(this, \"spans\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n    }\n    exportBatch(operations, otelContextMap) {\n        for (const op of operations){\n            try {\n                if (!op.run) {\n                    continue;\n                }\n                if (op.operation === \"post\") {\n                    const span = this.createSpanForRun(op, op.run, otelContextMap.get(op.id));\n                    if (span && !op.run.end_time) {\n                        this.spans.set(op.id, span);\n                    }\n                } else {\n                    this.updateSpanForRun(op, op.run);\n                }\n            } catch (e) {\n                console.error(`Error processing operation ${op.id}:`, e);\n            }\n        }\n    }\n    createSpanForRun(op, runInfo, otelContext) {\n        const activeSpan = otelContext && (0,_singletons_otel_js__WEBPACK_IMPORTED_MODULE_1__.getOTELTrace)().getSpan(otelContext);\n        if (!activeSpan) {\n            return;\n        }\n        try {\n            return this.finishSpanSetup(activeSpan, runInfo, op);\n        } catch (e) {\n            console.error(`Failed to create span for run ${op.id}:`, e);\n            return undefined;\n        }\n    }\n    finishSpanSetup(span, runInfo, op) {\n        // Set all attributes\n        this.setSpanAttributes(span, runInfo, op);\n        // Set status based on error\n        if (runInfo.error) {\n            span.setStatus({\n                code: 2\n            }); // ERROR status\n            span.recordException(new Error(runInfo.error));\n        } else {\n            span.setStatus({\n                code: 1\n            }); // OK status\n        }\n        // End the span if end_time is present\n        if (runInfo.end_time) {\n            span.end(new Date(runInfo.end_time));\n        }\n        return span;\n    }\n    updateSpanForRun(op, runInfo) {\n        try {\n            const span = this.spans.get(op.id);\n            if (!span) {\n                console.debug(`No span found for run ${op.id} during update`);\n                return;\n            }\n            // Update attributes\n            this.setSpanAttributes(span, runInfo, op);\n            // Update status based on error\n            if (runInfo.error) {\n                span.setStatus({\n                    code: 2\n                }); // ERROR status\n                span.recordException(new Error(runInfo.error));\n            } else {\n                span.setStatus({\n                    code: 1\n                }); // OK status\n            }\n            // End the span if end_time is present\n            const endTime = runInfo.end_time;\n            if (endTime) {\n                span.end(new Date(endTime));\n                this.spans.delete(op.id);\n            }\n        } catch (e) {\n            console.error(`Failed to update span for run ${op.id}:`, e);\n        }\n    }\n    extractModelName(runInfo) {\n        // Try to get model name from metadata\n        if (runInfo.extra?.metadata) {\n            const metadata = runInfo.extra.metadata;\n            // First check for ls_model_name in metadata\n            if (metadata.ls_model_name) {\n                return metadata.ls_model_name;\n            }\n            // Then check invocation_params for model info\n            if (metadata.invocation_params) {\n                const invocationParams = metadata.invocation_params;\n                if (invocationParams.model) {\n                    return invocationParams.model;\n                } else if (invocationParams.model_name) {\n                    return invocationParams.model_name;\n                }\n            }\n        }\n        return;\n    }\n    setSpanAttributes(span, runInfo, op) {\n        if (\"run_type\" in runInfo && runInfo.run_type) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_RUN_TYPE, runInfo.run_type);\n            // Set GenAI attributes according to OTEL semantic conventions\n            const operationName = getOperationName(runInfo.run_type || \"chain\");\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_OPERATION_NAME, operationName);\n        }\n        if (\"name\" in runInfo && runInfo.name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_NAME, runInfo.name);\n        }\n        if (\"session_id\" in runInfo && runInfo.session_id) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_ID, runInfo.session_id);\n        }\n        if (\"session_name\" in runInfo && runInfo.session_name) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_SESSION_NAME, runInfo.session_name);\n        }\n        // Set gen_ai.system\n        this.setGenAiSystem(span, runInfo);\n        // Set model name if available\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, modelName);\n        }\n        // Set token usage information\n        if (\"prompt_tokens\" in runInfo && typeof runInfo.prompt_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, runInfo.prompt_tokens);\n        }\n        if (\"completion_tokens\" in runInfo && typeof runInfo.completion_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, runInfo.completion_tokens);\n        }\n        if (\"total_tokens\" in runInfo && typeof runInfo.total_tokens === \"number\") {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, runInfo.total_tokens);\n        }\n        // Set other parameters from invocation_params\n        this.setInvocationParameters(span, runInfo);\n        // Set metadata and tags if available\n        const metadata = runInfo.extra?.metadata || {};\n        for (const [key, value] of Object.entries(metadata)){\n            if (value !== null && value !== undefined) {\n                span.setAttribute(`${_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_METADATA}.${key}`, String(value));\n            }\n        }\n        const tags = runInfo.tags;\n        if (tags && Array.isArray(tags)) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, tags.join(\", \"));\n        } else if (tags) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_TAGS, String(tags));\n        }\n        // Support additional serialized attributes, if present\n        if (\"serialized\" in runInfo && typeof runInfo.serialized === \"object\") {\n            const serialized = runInfo.serialized;\n            if (serialized.name) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_NAME, String(serialized.name));\n            }\n            if (serialized.signature) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_SIGNATURE, String(serialized.signature));\n            }\n            if (serialized.doc) {\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SERIALIZED_DOC, String(serialized.doc));\n            }\n        }\n        // Set inputs/outputs if available\n        this.setIOAttributes(span, op);\n    }\n    setGenAiSystem(span, runInfo) {\n        // Default to \"langchain\" if we can't determine the system\n        let system = \"langchain\";\n        // Extract model name to determine the system\n        const modelName = this.extractModelName(runInfo);\n        if (modelName) {\n            const modelLower = modelName.toLowerCase();\n            if (modelLower.includes(\"anthropic\") || modelLower.startsWith(\"claude\")) {\n                system = \"anthropic\";\n            } else if (modelLower.includes(\"bedrock\")) {\n                system = \"aws.bedrock\";\n            } else if (modelLower.includes(\"azure\") && modelLower.includes(\"openai\")) {\n                system = \"az.ai.openai\";\n            } else if (modelLower.includes(\"azure\") && modelLower.includes(\"inference\")) {\n                system = \"az.ai.inference\";\n            } else if (modelLower.includes(\"cohere\")) {\n                system = \"cohere\";\n            } else if (modelLower.includes(\"deepseek\")) {\n                system = \"deepseek\";\n            } else if (modelLower.includes(\"gemini\")) {\n                system = \"gemini\";\n            } else if (modelLower.includes(\"groq\")) {\n                system = \"groq\";\n            } else if (modelLower.includes(\"watson\") || modelLower.includes(\"ibm\")) {\n                system = \"ibm.watsonx.ai\";\n            } else if (modelLower.includes(\"mistral\")) {\n                system = \"mistral_ai\";\n            } else if (modelLower.includes(\"gpt\") || modelLower.includes(\"openai\")) {\n                system = \"openai\";\n            } else if (modelLower.includes(\"perplexity\") || modelLower.includes(\"sonar\")) {\n                system = \"perplexity\";\n            } else if (modelLower.includes(\"vertex\")) {\n                system = \"vertex_ai\";\n            } else if (modelLower.includes(\"xai\") || modelLower.includes(\"grok\")) {\n                system = \"xai\";\n            }\n        }\n        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_SYSTEM, system);\n    }\n    setInvocationParameters(span, runInfo) {\n        if (!runInfo.extra?.metadata?.invocation_params) {\n            return;\n        }\n        const invocationParams = runInfo.extra.metadata.invocation_params;\n        // Set relevant invocation parameters\n        if (invocationParams.max_tokens !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MAX_TOKENS, invocationParams.max_tokens);\n        }\n        if (invocationParams.temperature !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TEMPERATURE, invocationParams.temperature);\n        }\n        if (invocationParams.top_p !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_TOP_P, invocationParams.top_p);\n        }\n        if (invocationParams.frequency_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_FREQUENCY_PENALTY, invocationParams.frequency_penalty);\n        }\n        if (invocationParams.presence_penalty !== undefined) {\n            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_PRESENCE_PENALTY, invocationParams.presence_penalty);\n        }\n    }\n    setIOAttributes(span, op) {\n        if (op.run.inputs) {\n            try {\n                const inputs = op.run.inputs;\n                if (typeof inputs === \"object\" && inputs !== null) {\n                    if (inputs.model && Array.isArray(inputs.messages)) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_MODEL, inputs.model);\n                    }\n                    // Set additional request attributes if available\n                    if (inputs.stream !== undefined) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_STREAMING, inputs.stream);\n                    }\n                    if (inputs.extra_headers) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.LANGSMITH_REQUEST_HEADERS, JSON.stringify(inputs.extra_headers));\n                    }\n                    if (inputs.extra_query) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_QUERY, JSON.stringify(inputs.extra_query));\n                    }\n                    if (inputs.extra_body) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_REQUEST_EXTRA_BODY, JSON.stringify(inputs.extra_body));\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_PROMPT, JSON.stringify(inputs));\n            } catch (e) {\n                console.debug(`Failed to process inputs for run ${op.id}`, e);\n            }\n        }\n        if (op.run.outputs) {\n            try {\n                const outputs = op.run.outputs;\n                // Extract token usage from outputs (for LLM runs)\n                const tokenUsage = this.getUnifiedRunTokens(outputs);\n                if (tokenUsage) {\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKENS, tokenUsage[0]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKENS, tokenUsage[1]);\n                    span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_TOTAL_TOKENS, tokenUsage[0] + tokenUsage[1]);\n                }\n                if (outputs && typeof outputs === \"object\") {\n                    if (outputs.model) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_MODEL, String(outputs.model));\n                    }\n                    // Extract additional response attributes\n                    if (outputs.id) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_ID, outputs.id);\n                    }\n                    if (outputs.choices && Array.isArray(outputs.choices)) {\n                        const finishReasons = outputs.choices// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .map((choice)=>choice.finish_reason)// eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        .filter((reason)=>reason).map(String);\n                        if (finishReasons.length > 0) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_FINISH_REASONS, finishReasons.join(\", \"));\n                        }\n                    }\n                    if (outputs.service_tier) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SERVICE_TIER, outputs.service_tier);\n                    }\n                    if (outputs.system_fingerprint) {\n                        span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_RESPONSE_SYSTEM_FINGERPRINT, outputs.system_fingerprint);\n                    }\n                    if (outputs.usage_metadata && typeof outputs.usage_metadata === \"object\") {\n                        const usageMetadata = outputs.usage_metadata;\n                        if (usageMetadata.input_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_INPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.input_token_details));\n                        }\n                        if (usageMetadata.output_token_details) {\n                            span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GEN_AI_USAGE_OUTPUT_TOKEN_DETAILS, JSON.stringify(usageMetadata.output_token_details));\n                        }\n                    }\n                }\n                span.setAttribute(_constants_js__WEBPACK_IMPORTED_MODULE_0__.GENAI_COMPLETION, JSON.stringify(outputs));\n            } catch (e) {\n                console.debug(`Failed to process outputs for run ${op.id}`, e);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getUnifiedRunTokens(outputs) {\n        if (!outputs) {\n            return null;\n        }\n        // Search in non-generations lists\n        let tokenUsage = this.extractUnifiedRunTokens(outputs.usage_metadata);\n        if (tokenUsage) {\n            return tokenUsage;\n        }\n        // Find if direct kwarg in outputs\n        const keys = Object.keys(outputs);\n        for (const key of keys){\n            const haystack = outputs[key];\n            if (!haystack || typeof haystack !== \"object\") {\n                continue;\n            }\n            tokenUsage = this.extractUnifiedRunTokens(haystack.usage_metadata);\n            if (tokenUsage) {\n                return tokenUsage;\n            }\n            if (haystack.lc === 1 && haystack.kwargs && typeof haystack.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(haystack.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        // Find in generations\n        const generations = outputs.generations || [];\n        if (!Array.isArray(generations)) {\n            return null;\n        }\n        const flatGenerations = Array.isArray(generations[0]) ? generations.flat() : generations;\n        for (const generation of flatGenerations){\n            if (typeof generation === \"object\" && generation.message && typeof generation.message === \"object\" && generation.message.kwargs && typeof generation.message.kwargs === \"object\") {\n                tokenUsage = this.extractUnifiedRunTokens(generation.message.kwargs.usage_metadata);\n                if (tokenUsage) {\n                    return tokenUsage;\n                }\n            }\n        }\n        return null;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extractUnifiedRunTokens(outputs) {\n        if (!outputs || typeof outputs !== \"object\") {\n            return null;\n        }\n        if (typeof outputs.input_tokens !== \"number\" || typeof outputs.output_tokens !== \"number\") {\n            return null;\n        }\n        return [\n            outputs.input_tokens,\n            outputs.output_tokens\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvZXhwZXJpbWVudGFsL290ZWwvdHJhbnNsYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDWTtBQUN4RCxNQUFNRSw2QkFBNkI7SUFDL0JDLEtBQUs7SUFDTEMsTUFBTTtJQUNOQyxXQUFXO0lBQ1hDLFdBQVc7SUFDWEMsUUFBUTtBQUNaO0FBQ0EsU0FBU0MsaUJBQWlCQyxPQUFPO0lBQzdCLE9BQU9QLDBCQUEwQixDQUFDTyxRQUFRLElBQUlBO0FBQ2xEO0FBQ08sTUFBTUM7SUFDVEMsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sSUFBSUM7UUFDZjtJQUNKO0lBQ0FDLFlBQVlDLFVBQVUsRUFBRUMsY0FBYyxFQUFFO1FBQ3BDLEtBQUssTUFBTUMsTUFBTUYsV0FBWTtZQUN6QixJQUFJO2dCQUNBLElBQUksQ0FBQ0UsR0FBR0MsR0FBRyxFQUFFO29CQUNUO2dCQUNKO2dCQUNBLElBQUlELEdBQUdFLFNBQVMsS0FBSyxRQUFRO29CQUN6QixNQUFNQyxPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLENBQUNKLElBQUlBLEdBQUdDLEdBQUcsRUFBRUYsZUFBZU0sR0FBRyxDQUFDTCxHQUFHTSxFQUFFO29CQUN2RSxJQUFJSCxRQUFRLENBQUNILEdBQUdDLEdBQUcsQ0FBQ00sUUFBUSxFQUFFO3dCQUMxQixJQUFJLENBQUNDLEtBQUssQ0FBQ0MsR0FBRyxDQUFDVCxHQUFHTSxFQUFFLEVBQUVIO29CQUMxQjtnQkFDSixPQUNLO29CQUNELElBQUksQ0FBQ08sZ0JBQWdCLENBQUNWLElBQUlBLEdBQUdDLEdBQUc7Z0JBQ3BDO1lBQ0osRUFDQSxPQUFPVSxHQUFHO2dCQUNOQyxRQUFRQyxLQUFLLENBQUMsQ0FBQywyQkFBMkIsRUFBRWIsR0FBR00sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFF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V0FBV0MsT0FBTyxLQUFLLFlBQzlCRCxXQUFXQyxPQUFPLENBQUNMLE1BQU0sSUFDekIsT0FBT0ksV0FBV0MsT0FBTyxDQUFDTCxNQUFNLEtBQUssVUFBVTtnQkFDL0M1QixhQUFhLElBQUksQ0FBQ3dCLHVCQUF1QixDQUFDUSxXQUFXQyxPQUFPLENBQUNMLE1BQU0sQ0FBQ1gsY0FBYztnQkFDbEYsSUFBSWpCLFlBQVk7b0JBQ1osT0FBT0E7Z0JBQ1g7WUFDSjtRQUNKO1FBQ0EsT0FBTztJQUNYO0lBQ0EsOERBQThEO0lBQzlEd0Isd0JBQXdCekIsT0FBTyxFQUFFO1FBQzdCLElBQUksQ0FBQ0EsV0FBVyxPQUFPQSxZQUFZLFVBQVU7WUFDekMsT0FBTztRQUNYO1FBQ0EsSUFBSSxPQUFPQSxRQUFRbUMsWUFBWSxLQUFLLFlBQ2hDLE9BQU9uQyxRQUFRb0MsYUFBYSxLQUFLLFVBQVU7WUFDM0MsT0FBTztRQUNYO1FBQ0EsT0FBTztZQUFDcEMsUUFBUW1DLFlBQVk7WUFBRW5DLFFBQVFvQyxhQUFhO1NBQUM7SUFDeEQ7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9leHBlcmltZW50YWwvb3RlbC90cmFuc2xhdG9yLmpzP2Y0NTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgZ2V0T1RFTFRyYWNlIH0gZnJvbSBcIi4uLy4uL3NpbmdsZXRvbnMvb3RlbC5qc1wiO1xuY29uc3QgV0VMTF9LTk9XTl9PUEVSQVRJT05fTkFNRVMgPSB7XG4gICAgbGxtOiBcImNoYXRcIixcbiAgICB0b29sOiBcImV4ZWN1dGVfdG9vbFwiLFxuICAgIHJldHJpZXZlcjogXCJlbWJlZGRpbmdzXCIsXG4gICAgZW1iZWRkaW5nOiBcImVtYmVkZGluZ3NcIixcbiAgICBwcm9tcHQ6IFwiY2hhdFwiLFxufTtcbmZ1bmN0aW9uIGdldE9wZXJhdGlvbk5hbWUocnVuVHlwZSkge1xuICAgIHJldHVybiBXRUxMX0tOT1dOX09QRVJBVElPTl9OQU1FU1tydW5UeXBlXSB8fCBydW5UeXBlO1xufVxuZXhwb3J0IGNsYXNzIExhbmdTbWl0aFRvT1RFTFRyYW5zbGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGFuc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBleHBvcnRCYXRjaChvcGVyYXRpb25zLCBvdGVsQ29udGV4dE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcC5ydW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcC5vcGVyYXRpb24gPT09IFwicG9zdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmNyZWF0ZVNwYW5Gb3JSdW4ob3AsIG9wLnJ1biwgb3RlbENvbnRleHRNYXAuZ2V0KG9wLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGFuICYmICFvcC5ydW4uZW5kX3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhbnMuc2V0KG9wLmlkLCBzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTcGFuRm9yUnVuKG9wLCBvcC5ydW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBvcGVyYXRpb24gJHtvcC5pZH06YCwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3BhbkZvclJ1bihvcCwgcnVuSW5mbywgb3RlbENvbnRleHQpIHtcbiAgICAgICAgY29uc3QgYWN0aXZlU3BhbiA9IG90ZWxDb250ZXh0ICYmIGdldE9URUxUcmFjZSgpLmdldFNwYW4ob3RlbENvbnRleHQpO1xuICAgICAgICBpZiAoIWFjdGl2ZVNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoU3BhblNldHVwKGFjdGl2ZVNwYW4sIHJ1bkluZm8sIG9wKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBzcGFuIGZvciBydW4gJHtvcC5pZH06YCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaFNwYW5TZXR1cChzcGFuLCBydW5JbmZvLCBvcCkge1xuICAgICAgICAvLyBTZXQgYWxsIGF0dHJpYnV0ZXNcbiAgICAgICAgdGhpcy5zZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCk7XG4gICAgICAgIC8vIFNldCBzdGF0dXMgYmFzZWQgb24gZXJyb3JcbiAgICAgICAgaWYgKHJ1bkluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMiB9KTsgLy8gRVJST1Igc3RhdHVzXG4gICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihuZXcgRXJyb3IocnVuSW5mby5lcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiAxIH0pOyAvLyBPSyBzdGF0dXNcbiAgICAgICAgfVxuICAgICAgICAvLyBFbmQgdGhlIHNwYW4gaWYgZW5kX3RpbWUgaXMgcHJlc2VudFxuICAgICAgICBpZiAocnVuSW5mby5lbmRfdGltZSkge1xuICAgICAgICAgICAgc3Bhbi5lbmQobmV3IERhdGUocnVuSW5mby5lbmRfdGltZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICB1cGRhdGVTcGFuRm9yUnVuKG9wLCBydW5JbmZvKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5zcGFucy5nZXQob3AuaWQpO1xuICAgICAgICAgICAgaWYgKCFzcGFuKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgTm8gc3BhbiBmb3VuZCBmb3IgcnVuICR7b3AuaWR9IGR1cmluZyB1cGRhdGVgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgYXR0cmlidXRlc1xuICAgICAgICAgICAgdGhpcy5zZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGJhc2VkIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAocnVuSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMiB9KTsgLy8gRVJST1Igc3RhdHVzXG4gICAgICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24obmV3IEVycm9yKHJ1bkluZm8uZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogMSB9KTsgLy8gT0sgc3RhdHVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbmQgdGhlIHNwYW4gaWYgZW5kX3RpbWUgaXMgcHJlc2VudFxuICAgICAgICAgICAgY29uc3QgZW5kVGltZSA9IHJ1bkluZm8uZW5kX3RpbWU7XG4gICAgICAgICAgICBpZiAoZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHNwYW4uZW5kKG5ldyBEYXRlKGVuZFRpbWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNwYW5zLmRlbGV0ZShvcC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgc3BhbiBmb3IgcnVuICR7b3AuaWR9OmAsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4dHJhY3RNb2RlbE5hbWUocnVuSW5mbykge1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IG1vZGVsIG5hbWUgZnJvbSBtZXRhZGF0YVxuICAgICAgICBpZiAocnVuSW5mby5leHRyYT8ubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gcnVuSW5mby5leHRyYS5tZXRhZGF0YTtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGZvciBsc19tb2RlbF9uYW1lIGluIG1ldGFkYXRhXG4gICAgICAgICAgICBpZiAobWV0YWRhdGEubHNfbW9kZWxfbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YS5sc19tb2RlbF9uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlbiBjaGVjayBpbnZvY2F0aW9uX3BhcmFtcyBmb3IgbW9kZWwgaW5mb1xuICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmludm9jYXRpb25fcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW52b2NhdGlvblBhcmFtcyA9IG1ldGFkYXRhLmludm9jYXRpb25fcGFyYW1zO1xuICAgICAgICAgICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnZvY2F0aW9uUGFyYW1zLm1vZGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpbnZvY2F0aW9uUGFyYW1zLm1vZGVsX25hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGludm9jYXRpb25QYXJhbXMubW9kZWxfbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRTcGFuQXR0cmlidXRlcyhzcGFuLCBydW5JbmZvLCBvcCkge1xuICAgICAgICBpZiAoXCJydW5fdHlwZVwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5ydW5fdHlwZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9SVU5fVFlQRSwgcnVuSW5mby5ydW5fdHlwZSk7XG4gICAgICAgICAgICAvLyBTZXQgR2VuQUkgYXR0cmlidXRlcyBhY2NvcmRpbmcgdG8gT1RFTCBzZW1hbnRpYyBjb252ZW50aW9uc1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IGdldE9wZXJhdGlvbk5hbWUocnVuSW5mby5ydW5fdHlwZSB8fCBcImNoYWluXCIpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9PUEVSQVRJT05fTkFNRSwgb3BlcmF0aW9uTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwibmFtZVwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5uYW1lKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX05BTUUsIHJ1bkluZm8ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic2Vzc2lvbl9pZFwiIGluIHJ1bkluZm8gJiYgcnVuSW5mby5zZXNzaW9uX2lkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1NFU1NJT05fSUQsIHJ1bkluZm8uc2Vzc2lvbl9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwic2Vzc2lvbl9uYW1lXCIgaW4gcnVuSW5mbyAmJiBydW5JbmZvLnNlc3Npb25fbmFtZSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9TRVNTSU9OX05BTUUsIHJ1bkluZm8uc2Vzc2lvbl9uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgZ2VuX2FpLnN5c3RlbVxuICAgICAgICB0aGlzLnNldEdlbkFpU3lzdGVtKHNwYW4sIHJ1bkluZm8pO1xuICAgICAgICAvLyBTZXQgbW9kZWwgbmFtZSBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgbW9kZWxOYW1lID0gdGhpcy5leHRyYWN0TW9kZWxOYW1lKHJ1bkluZm8pO1xuICAgICAgICBpZiAobW9kZWxOYW1lKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfTU9ERUwsIG1vZGVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRva2VuIHVzYWdlIGluZm9ybWF0aW9uXG4gICAgICAgIGlmIChcInByb21wdF90b2tlbnNcIiBpbiBydW5JbmZvICYmXG4gICAgICAgICAgICB0eXBlb2YgcnVuSW5mby5wcm9tcHRfdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOUywgcnVuSW5mby5wcm9tcHRfdG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjb21wbGV0aW9uX3Rva2Vuc1wiIGluIHJ1bkluZm8gJiZcbiAgICAgICAgICAgIHR5cGVvZiBydW5JbmZvLmNvbXBsZXRpb25fdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTlMsIHJ1bkluZm8uY29tcGxldGlvbl90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcInRvdGFsX3Rva2Vuc1wiIGluIHJ1bkluZm8gJiYgdHlwZW9mIHJ1bkluZm8udG90YWxfdG9rZW5zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUywgcnVuSW5mby50b3RhbF90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBvdGhlciBwYXJhbWV0ZXJzIGZyb20gaW52b2NhdGlvbl9wYXJhbXNcbiAgICAgICAgdGhpcy5zZXRJbnZvY2F0aW9uUGFyYW1ldGVycyhzcGFuLCBydW5JbmZvKTtcbiAgICAgICAgLy8gU2V0IG1ldGFkYXRhIGFuZCB0YWdzIGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHJ1bkluZm8uZXh0cmE/Lm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoYCR7Y29uc3RhbnRzLkxBTkdTTUlUSF9NRVRBREFUQX0uJHtrZXl9YCwgU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFncyA9IHJ1bkluZm8udGFncztcbiAgICAgICAgaWYgKHRhZ3MgJiYgQXJyYXkuaXNBcnJheSh0YWdzKSkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9UQUdTLCB0YWdzLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGFncykge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkxBTkdTTUlUSF9UQUdTLCBTdHJpbmcodGFncykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1cHBvcnQgYWRkaXRpb25hbCBzZXJpYWxpemVkIGF0dHJpYnV0ZXMsIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKFwic2VyaWFsaXplZFwiIGluIHJ1bkluZm8gJiYgdHlwZW9mIHJ1bkluZm8uc2VyaWFsaXplZCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHJ1bkluZm8uc2VyaWFsaXplZDtcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVkLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NFUklBTElaRURfTkFNRSwgU3RyaW5nKHNlcmlhbGl6ZWQubmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWQuc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSwgU3RyaW5nKHNlcmlhbGl6ZWQuc2lnbmF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZC5kb2MpIHtcbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1NFUklBTElaRURfRE9DLCBTdHJpbmcoc2VyaWFsaXplZC5kb2MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgaW5wdXRzL291dHB1dHMgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRoaXMuc2V0SU9BdHRyaWJ1dGVzKHNwYW4sIG9wKTtcbiAgICB9XG4gICAgc2V0R2VuQWlTeXN0ZW0oc3BhbiwgcnVuSW5mbykge1xuICAgICAgICAvLyBEZWZhdWx0IHRvIFwibGFuZ2NoYWluXCIgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHRoZSBzeXN0ZW1cbiAgICAgICAgbGV0IHN5c3RlbSA9IFwibGFuZ2NoYWluXCI7XG4gICAgICAgIC8vIEV4dHJhY3QgbW9kZWwgbmFtZSB0byBkZXRlcm1pbmUgdGhlIHN5c3RlbVxuICAgICAgICBjb25zdCBtb2RlbE5hbWUgPSB0aGlzLmV4dHJhY3RNb2RlbE5hbWUocnVuSW5mbyk7XG4gICAgICAgIGlmIChtb2RlbE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsTG93ZXIgPSBtb2RlbE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYW50aHJvcGljXCIpIHx8IG1vZGVsTG93ZXIuc3RhcnRzV2l0aChcImNsYXVkZVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYW50aHJvcGljXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiYmVkcm9ja1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYXdzLmJlZHJvY2tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJhenVyZVwiKSAmJlxuICAgICAgICAgICAgICAgIG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJvcGVuYWlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImF6LmFpLm9wZW5haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImF6dXJlXCIpICYmXG4gICAgICAgICAgICAgICAgbW9kZWxMb3dlci5pbmNsdWRlcyhcImluZmVyZW5jZVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiYXouYWkuaW5mZXJlbmNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiY29oZXJlXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJjb2hlcmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJkZWVwc2Vla1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiZGVlcHNlZWtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJnZW1pbmlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImdlbWluaVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcImdyb3FcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcImdyb3FcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJ3YXRzb25cIikgfHwgbW9kZWxMb3dlci5pbmNsdWRlcyhcImlibVwiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwiaWJtLndhdHNvbnguYWlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJtaXN0cmFsXCIpKSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtID0gXCJtaXN0cmFsX2FpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ3B0XCIpIHx8IG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJvcGVuYWlcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcIm9wZW5haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcInBlcnBsZXhpdHlcIikgfHxcbiAgICAgICAgICAgICAgICBtb2RlbExvd2VyLmluY2x1ZGVzKFwic29uYXJcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInBlcnBsZXhpdHlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vZGVsTG93ZXIuaW5jbHVkZXMoXCJ2ZXJ0ZXhcIikpIHtcbiAgICAgICAgICAgICAgICBzeXN0ZW0gPSBcInZlcnRleF9haVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobW9kZWxMb3dlci5pbmNsdWRlcyhcInhhaVwiKSB8fCBtb2RlbExvd2VyLmluY2x1ZGVzKFwiZ3Jva1wiKSkge1xuICAgICAgICAgICAgICAgIHN5c3RlbSA9IFwieGFpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9TWVNURU0sIHN5c3RlbSk7XG4gICAgfVxuICAgIHNldEludm9jYXRpb25QYXJhbWV0ZXJzKHNwYW4sIHJ1bkluZm8pIHtcbiAgICAgICAgaWYgKCFydW5JbmZvLmV4dHJhPy5tZXRhZGF0YT8uaW52b2NhdGlvbl9wYXJhbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnZvY2F0aW9uUGFyYW1zID0gcnVuSW5mby5leHRyYS5tZXRhZGF0YS5pbnZvY2F0aW9uX3BhcmFtcztcbiAgICAgICAgLy8gU2V0IHJlbGV2YW50IGludm9jYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5tYXhfdG9rZW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9NQVhfVE9LRU5TLCBpbnZvY2F0aW9uUGFyYW1zLm1heF90b2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLnRlbXBlcmF0dXJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9URU1QRVJBVFVSRSwgaW52b2NhdGlvblBhcmFtcy50ZW1wZXJhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludm9jYXRpb25QYXJhbXMudG9wX3AgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX1RPUF9QLCBpbnZvY2F0aW9uUGFyYW1zLnRvcF9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2NhdGlvblBhcmFtcy5mcmVxdWVuY3lfcGVuYWx0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfRlJFUVVFTkNZX1BFTkFMVFksIGludm9jYXRpb25QYXJhbXMuZnJlcXVlbmN5X3BlbmFsdHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZvY2F0aW9uUGFyYW1zLnByZXNlbmNlX3BlbmFsdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVFVRVNUX1BSRVNFTkNFX1BFTkFMVFksIGludm9jYXRpb25QYXJhbXMucHJlc2VuY2VfcGVuYWx0eSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SU9BdHRyaWJ1dGVzKHNwYW4sIG9wKSB7XG4gICAgICAgIGlmIChvcC5ydW4uaW5wdXRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0cyA9IG9wLnJ1bi5pbnB1dHM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dHMgPT09IFwib2JqZWN0XCIgJiYgaW5wdXRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMubW9kZWwgJiYgQXJyYXkuaXNBcnJheShpbnB1dHMubWVzc2FnZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfTU9ERUwsIGlucHV0cy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFkZGl0aW9uYWwgcmVxdWVzdCBhdHRyaWJ1dGVzIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuTEFOR1NNSVRIX1JFUVVFU1RfU1RSRUFNSU5HLCBpbnB1dHMuc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRzLmV4dHJhX2hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5MQU5HU01JVEhfUkVRVUVTVF9IRUFERVJTLCBKU09OLnN0cmluZ2lmeShpbnB1dHMuZXh0cmFfaGVhZGVycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dHMuZXh0cmFfcXVlcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfUkVRVUVTVF9FWFRSQV9RVUVSWSwgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLmV4dHJhX3F1ZXJ5KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0cy5leHRyYV9ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFUVVFU1RfRVhUUkFfQk9EWSwgSlNPTi5zdHJpbmdpZnkoaW5wdXRzLmV4dHJhX2JvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOQUlfUFJPTVBULCBKU09OLnN0cmluZ2lmeShpbnB1dHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgRmFpbGVkIHRvIHByb2Nlc3MgaW5wdXRzIGZvciBydW4gJHtvcC5pZH1gLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3AucnVuLm91dHB1dHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0cyA9IG9wLnJ1bi5vdXRwdXRzO1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdG9rZW4gdXNhZ2UgZnJvbSBvdXRwdXRzIChmb3IgTExNIHJ1bnMpXG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5Vc2FnZSA9IHRoaXMuZ2V0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1VTQUdFX0lOUFVUX1RPS0VOUywgdG9rZW5Vc2FnZVswXSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOUywgdG9rZW5Vc2FnZVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfVE9UQUxfVE9LRU5TLCB0b2tlblVzYWdlWzBdICsgdG9rZW5Vc2FnZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzICYmIHR5cGVvZiBvdXRwdXRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX01PREVMLCBTdHJpbmcob3V0cHV0cy5tb2RlbCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgYWRkaXRpb25hbCByZXNwb25zZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX0lELCBvdXRwdXRzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy5jaG9pY2VzICYmIEFycmF5LmlzQXJyYXkob3V0cHV0cy5jaG9pY2VzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluaXNoUmVhc29ucyA9IG91dHB1dHMuY2hvaWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoY2hvaWNlKSA9PiBjaG9pY2UuZmluaXNoX3JlYXNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlYXNvbikgPT4gcmVhc29uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hSZWFzb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX0ZJTklTSF9SRUFTT05TLCBmaW5pc2hSZWFzb25zLmpvaW4oXCIsIFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dHMuc2VydmljZV90aWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOX0FJX1JFU1BPTlNFX1NFUlZJQ0VfVElFUiwgb3V0cHV0cy5zZXJ2aWNlX3RpZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXRzLnN5c3RlbV9maW5nZXJwcmludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RhbnRzLkdFTl9BSV9SRVNQT05TRV9TWVNURU1fRklOR0VSUFJJTlQsIG91dHB1dHMuc3lzdGVtX2ZpbmdlcnByaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0cy51c2FnZV9tZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIG91dHB1dHMudXNhZ2VfbWV0YWRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzYWdlTWV0YWRhdGEgPSBvdXRwdXRzLnVzYWdlX21ldGFkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlTWV0YWRhdGEuaW5wdXRfdG9rZW5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUywgSlNPTi5zdHJpbmdpZnkodXNhZ2VNZXRhZGF0YS5pbnB1dF90b2tlbl9kZXRhaWxzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXNhZ2VNZXRhZGF0YS5vdXRwdXRfdG9rZW5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0YW50cy5HRU5fQUlfVVNBR0VfT1VUUFVUX1RPS0VOX0RFVEFJTFMsIEpTT04uc3RyaW5naWZ5KHVzYWdlTWV0YWRhdGEub3V0cHV0X3Rva2VuX2RldGFpbHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdGFudHMuR0VOQUlfQ09NUExFVElPTiwgSlNPTi5zdHJpbmdpZnkob3V0cHV0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGBGYWlsZWQgdG8gcHJvY2VzcyBvdXRwdXRzIGZvciBydW4gJHtvcC5pZH1gLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGdldFVuaWZpZWRSdW5Ub2tlbnMob3V0cHV0cykge1xuICAgICAgICBpZiAoIW91dHB1dHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlYXJjaCBpbiBub24tZ2VuZXJhdGlvbnMgbGlzdHNcbiAgICAgICAgbGV0IHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKG91dHB1dHMudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBpZiBkaXJlY3Qga3dhcmcgaW4gb3V0cHV0c1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob3V0cHV0cyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhheXN0YWNrID0gb3V0cHV0c1trZXldO1xuICAgICAgICAgICAgaWYgKCFoYXlzdGFjayB8fCB0eXBlb2YgaGF5c3RhY2sgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKGhheXN0YWNrLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuVXNhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGF5c3RhY2subGMgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBoYXlzdGFjay5rd2FyZ3MgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgaGF5c3RhY2sua3dhcmdzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5Vc2FnZSA9IHRoaXMuZXh0cmFjdFVuaWZpZWRSdW5Ub2tlbnMoaGF5c3RhY2sua3dhcmdzLnVzYWdlX21ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5Vc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5Vc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCBpbiBnZW5lcmF0aW9uc1xuICAgICAgICBjb25zdCBnZW5lcmF0aW9ucyA9IG91dHB1dHMuZ2VuZXJhdGlvbnMgfHwgW107XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShnZW5lcmF0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYXRHZW5lcmF0aW9ucyA9IEFycmF5LmlzQXJyYXkoZ2VuZXJhdGlvbnNbMF0pXG4gICAgICAgICAgICA/IGdlbmVyYXRpb25zLmZsYXQoKVxuICAgICAgICAgICAgOiBnZW5lcmF0aW9ucztcbiAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0aW9uIG9mIGZsYXRHZW5lcmF0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lcmF0aW9uID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGlvbi5tZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGdlbmVyYXRpb24ubWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGdlbmVyYXRpb24ubWVzc2FnZS5rd2FyZ3MgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZ2VuZXJhdGlvbi5tZXNzYWdlLmt3YXJncyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRva2VuVXNhZ2UgPSB0aGlzLmV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zKGdlbmVyYXRpb24ubWVzc2FnZS5rd2FyZ3MudXNhZ2VfbWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblVzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlblVzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBleHRyYWN0VW5pZmllZFJ1blRva2VucyhvdXRwdXRzKSB7XG4gICAgICAgIGlmICghb3V0cHV0cyB8fCB0eXBlb2Ygb3V0cHV0cyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXRzLmlucHV0X3Rva2VucyAhPT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIG91dHB1dHMub3V0cHV0X3Rva2VucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvdXRwdXRzLmlucHV0X3Rva2Vucywgb3V0cHV0cy5vdXRwdXRfdG9rZW5zXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiY29uc3RhbnRzIiwiZ2V0T1RFTFRyYWNlIiwiV0VMTF9LTk9XTl9PUEVSQVRJT05fTkFNRVMiLCJsbG0iLCJ0b29sIiwicmV0cmlldmVyIiwiZW1iZWRkaW5nIiwicHJvbXB0IiwiZ2V0T3BlcmF0aW9uTmFtZSIsInJ1blR5cGUiLCJMYW5nU21pdGhUb09URUxUcmFuc2xhdG9yIiwiY29uc3RydWN0b3IiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiTWFwIiwiZXhwb3J0QmF0Y2giLCJvcGVyYXRpb25zIiwib3RlbENvbnRleHRNYXAiLCJvcCIsInJ1biIsIm9wZXJhdGlvbiIsInNwYW4iLCJjcmVhdGVTcGFuRm9yUnVuIiwiZ2V0IiwiaWQiLCJlbmRfdGltZSIsInNwYW5zIiwic2V0IiwidXBkYXRlU3BhbkZvclJ1biIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJydW5JbmZvIiwib3RlbENvbnRleHQiLCJhY3RpdmVTcGFuIiwiZ2V0U3BhbiIsImZpbmlzaFNwYW5TZXR1cCIsInVuZGVmaW5lZCIsInNldFNwYW5BdHRyaWJ1dGVzIiwic2V0U3RhdHVzIiwiY29kZSIsInJlY29yZEV4Y2VwdGlvbiIsIkVycm9yIiwiZW5kIiwiRGF0ZSIsImRlYnVnIiwiZW5kVGltZSIsImRlbGV0ZSIsImV4dHJhY3RNb2RlbE5hbWUiLCJleHRyYSIsIm1ldGFkYXRhIiwibHNfbW9kZWxfbmFtZSIsImludm9jYXRpb25fcGFyYW1zIiwiaW52b2NhdGlvblBhcmFtcyIsIm1vZGVsIiwibW9kZWxfbmFtZSIsInJ1bl90eXBlIiwic2V0QXR0cmlidXRlIiwiTEFOR1NNSVRIX1JVTl9UWVBFIiwib3BlcmF0aW9uTmFtZSIsIkdFTl9BSV9PUEVSQVRJT05fTkFNRSIsIm5hbWUiLCJMQU5HU01JVEhfTkFNRSIsInNlc3Npb25faWQiLCJMQU5HU01JVEhfU0VTU0lPTl9JRCIsInNlc3Npb25fbmFtZSIsIkxBTkdTTUlUSF9TRVNTSU9OX05BTUUiLCJzZXRHZW5BaVN5c3RlbSIsIm1vZGVsTmFtZSIsIkdFTl9BSV9SRVFVRVNUX01PREVMIiwicHJvbXB0X3Rva2VucyIsIkdFTl9BSV9VU0FHRV9JTlBVVF9UT0tFTlMiLCJjb21wbGV0aW9uX3Rva2VucyIsIkdFTl9BSV9VU0FHRV9PVVRQVVRfVE9LRU5TIiwidG90YWxfdG9rZW5zIiwiR0VOX0FJX1VTQUdFX1RPVEFMX1RPS0VOUyIsInNldEludm9jYXRpb25QYXJhbWV0ZXJzIiwia2V5IiwiZW50cmllcyIsIkxBTkdTTUlUSF9NRVRBREFUQSIsIlN0cmluZyIsInRhZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJMQU5HU01JVEhfVEFHUyIsImpvaW4iLCJzZXJpYWxpemVkIiwiR0VOX0FJX1NFUklBTElaRURfTkFNRSIsInNpZ25hdHVyZSIsIkdFTl9BSV9TRVJJQUxJWkVEX1NJR05BVFVSRSIsImRvYyIsIkdFTl9BSV9TRVJJQUxJWkVEX0RPQyIsInNldElPQXR0cmlidXRlcyIsInN5c3RlbSIsIm1vZGVsTG93ZXIiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3RhcnRzV2l0aCIsIkdFTl9BSV9TWVNURU0iLCJtYXhfdG9rZW5zIiwiR0VOX0FJX1JFUVVFU1RfTUFYX1RPS0VOUyIsInRlbXBlcmF0dXJlIiwiR0VOX0FJX1JFUVVFU1RfVEVNUEVSQVRVUkUiLCJ0b3BfcCIsIkdFTl9BSV9SRVFVRVNUX1RPUF9QIiwiZnJlcXVlbmN5X3BlbmFsdHkiLCJHRU5fQUlfUkVRVUVTVF9GUkVRVUVOQ1lfUEVOQUxUWSIsInByZXNlbmNlX3BlbmFsdHkiLCJHRU5fQUlfUkVRVUVTVF9QUkVTRU5DRV9QRU5BTFRZIiwiaW5wdXRzIiwibWVzc2FnZXMiLCJzdHJlYW0iLCJMQU5HU01JVEhfUkVRVUVTVF9TVFJFQU1JTkciLCJleHRyYV9oZWFkZXJzIiwiTEFOR1NNSVRIX1JFUVVFU1RfSEVBREVSUyIsIkpTT04iLCJzdHJpbmdpZnkiLCJleHRyYV9xdWVyeSIsIkdFTl9BSV9SRVFVRVNUX0VYVFJBX1FVRVJZIiwiZXh0cmFfYm9keSIsIkdFTl9BSV9SRVFVRVNUX0VYVFJBX0JPRFkiLCJHRU5BSV9QUk9NUFQiLCJvdXRwdXRzIiwidG9rZW5Vc2FnZSIsImdldFVuaWZpZWRSdW5Ub2tlbnMiLCJHRU5fQUlfUkVTUE9OU0VfTU9ERUwiLCJHRU5fQUlfUkVTUE9OU0VfSUQiLCJjaG9pY2VzIiwiZmluaXNoUmVhc29ucyIsIm1hcCIsImNob2ljZSIsImZpbmlzaF9yZWFzb24iLCJmaWx0ZXIiLCJyZWFzb24iLCJsZW5ndGgiLCJHRU5fQUlfUkVTUE9OU0VfRklOSVNIX1JFQVNPTlMiLCJzZXJ2aWNlX3RpZXIiLCJHRU5fQUlfUkVTUE9OU0VfU0VSVklDRV9USUVSIiwic3lzdGVtX2ZpbmdlcnByaW50IiwiR0VOX0FJX1JFU1BPTlNFX1NZU1RFTV9GSU5HRVJQUklOVCIsInVzYWdlX21ldGFkYXRhIiwidXNhZ2VNZXRhZGF0YSIsImlucHV0X3Rva2VuX2RldGFpbHMiLCJHRU5fQUlfVVNBR0VfSU5QVVRfVE9LRU5fREVUQUlMUyIsIm91dHB1dF90b2tlbl9kZXRhaWxzIiwiR0VOX0FJX1VTQUdFX09VVFBVVF9UT0tFTl9ERVRBSUxTIiwiR0VOQUlfQ09NUExFVElPTiIsImV4dHJhY3RVbmlmaWVkUnVuVG9rZW5zIiwia2V5cyIsImhheXN0YWNrIiwibGMiLCJrd2FyZ3MiLCJnZW5lcmF0aW9ucyIsImZsYXRHZW5lcmF0aW9ucyIsImZsYXQiLCJnZW5lcmF0aW9uIiwibWVzc2FnZSIsImlucHV0X3Rva2VucyIsIm91dHB1dF90b2tlbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/experimental/otel/translator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/langsmith/dist/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _run_trees_js__WEBPACK_IMPORTED_MODULE_1__.RunTree),\n/* harmony export */   __version__: () => (/* binding */ __version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _utils_project_js__WEBPACK_IMPORTED_MODULE_3__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__.overrideFetchImplementation),\n/* harmony export */   uuid7: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _uuid_js__WEBPACK_IMPORTED_MODULE_4__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _run_trees_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n/* harmony import */ var _singletons_fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./singletons/fetch.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/project.js */ \"(rsc)/./node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _uuid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uuid.js */ \"(rsc)/./node_modules/langsmith/dist/uuid.js\");\n\n\n\n\n\n// Update using yarn bump-version\nconst __version__ = \"0.4.2\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ0c7QUFDMkI7QUFDVDtBQUNWO0FBQ2pELGlDQUFpQztBQUMxQixNQUFNTSxjQUFjLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvaW5kZXguanM/YWEyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDbGllbnQsIH0gZnJvbSBcIi4vY2xpZW50LmpzXCI7XG5leHBvcnQgeyBSdW5UcmVlIH0gZnJvbSBcIi4vcnVuX3RyZWVzLmpzXCI7XG5leHBvcnQgeyBvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24gfSBmcm9tIFwiLi9zaW5nbGV0b25zL2ZldGNoLmpzXCI7XG5leHBvcnQgeyBnZXREZWZhdWx0UHJvamVjdE5hbWUgfSBmcm9tIFwiLi91dGlscy9wcm9qZWN0LmpzXCI7XG5leHBvcnQgeyB1dWlkNywgdXVpZDdGcm9tVGltZSB9IGZyb20gXCIuL3V1aWQuanNcIjtcbi8vIFVwZGF0ZSB1c2luZyB5YXJuIGJ1bXAtdmVyc2lvblxuZXhwb3J0IGNvbnN0IF9fdmVyc2lvbl9fID0gXCIwLjQuMlwiO1xuIl0sIm5hbWVzIjpbIkNsaWVudCIsIlJ1blRyZWUiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJnZXREZWZhdWx0UHJvamVjdE5hbWUiLCJ1dWlkNyIsInV1aWQ3RnJvbVRpbWUiLCJfX3ZlcnNpb25fXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/run_trees.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/run_trees.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* binding */ RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* binding */ convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* binding */ isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* binding */ isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client.js */ \"(rsc)/./node_modules/langsmith/dist/client.js\");\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/env.js\");\n/* harmony import */ var _utils_error_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/error.js */ \"(rsc)/./node_modules/langsmith/dist/utils/error.js\");\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n/* harmony import */ var _utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/context_vars.js */ \"(rsc)/./node_modules/langsmith/dist/utils/context_vars.js\");\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* harmony import */ var _utils_project_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/project.js */ \"(rsc)/./node_modules/langsmith/dist/utils/project.js\");\n/* harmony import */ var _utils_warn_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v5.js\");\n\n\n\n\n\n\n\n\n\n\n\nconst TIMESTAMP_LENGTH = 36;\n// DNS namespace for UUID v5 (same as Python's uuid.NAMESPACE_DNS)\nconst UUID_NAMESPACE_DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\nfunction getReplicaKey(replica) {\n    // Generate a unique key by hashing the replica's identifying properties\n    // This ensures each unique replica (combination of projectName, apiUrl, workspaceId, apiKey) gets a unique key\n    // Sort keys to ensure consistent hashing\n    const sortedKeys = Object.keys(replica).sort();\n    const keyData = sortedKeys.map((key)=>`${key}:${replica[key] ?? \"\"}`).join(\"|\");\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(keyData, UUID_NAMESPACE_DNS);\n}\nfunction stripNonAlphanumeric(input) {\n    return input.replace(/[-:.]/g, \"\");\n}\nfunction getMicrosecondPrecisionDatestring(epoch, executionOrder = 1) {\n    // Date only has millisecond precision, so we use the microseconds to break\n    // possible ties, avoiding incorrect run order\n    const paddedOrder = executionOrder.toFixed(0).slice(0, 3).padStart(3, \"0\");\n    return `${new Date(epoch).toISOString().slice(0, -1)}${paddedOrder}Z`;\n}\nfunction convertToDottedOrderFormat(epoch, runId, executionOrder = 1) {\n    const microsecondPrecisionDatestring = getMicrosecondPrecisionDatestring(epoch, executionOrder);\n    return {\n        dottedOrder: stripNonAlphanumeric(microsecondPrecisionDatestring) + runId,\n        microsecondPrecisionDatestring\n    };\n}\n/**\n * Baggage header information\n */ class Baggage {\n    constructor(metadata, tags, project_name, replicas){\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.metadata = metadata;\n        this.tags = tags;\n        this.project_name = project_name;\n        this.replicas = replicas;\n    }\n    static fromHeader(value) {\n        const items = value.split(\",\");\n        let metadata = {};\n        let tags = [];\n        let project_name;\n        let replicas;\n        for (const item of items){\n            const [key, uriValue] = item.split(\"=\");\n            const value = decodeURIComponent(uriValue);\n            if (key === \"langsmith-metadata\") {\n                metadata = JSON.parse(value);\n            } else if (key === \"langsmith-tags\") {\n                tags = value.split(\",\");\n            } else if (key === \"langsmith-project\") {\n                project_name = value;\n            } else if (key === \"langsmith-replicas\") {\n                replicas = JSON.parse(value);\n            }\n        }\n        return new Baggage(metadata, tags, project_name, replicas);\n    }\n    toHeader() {\n        const items = [];\n        if (this.metadata && Object.keys(this.metadata).length > 0) {\n            items.push(`langsmith-metadata=${encodeURIComponent(JSON.stringify(this.metadata))}`);\n        }\n        if (this.tags && this.tags.length > 0) {\n            items.push(`langsmith-tags=${encodeURIComponent(this.tags.join(\",\"))}`);\n        }\n        if (this.project_name) {\n            items.push(`langsmith-project=${encodeURIComponent(this.project_name)}`);\n        }\n        return items.join(\",\");\n    }\n}\nclass RunTree {\n    constructor(originalConfig){\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"run_type\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"project_name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"parent_run_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_runs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"end_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"extra\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"error\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serialized\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"reference_example_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"client\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"events\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"trace_id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"dotted_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tracingEnabled\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"child_execution_order\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Attachments associated with the run.\n         * Each entry is a tuple of [mime_type, bytes]\n         */ Object.defineProperty(this, \"attachments\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /**\n         * Projects to replicate this run to with optional updates.\n         */ Object.defineProperty(this, \"replicas\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"distributedParentId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_serialized_start_time\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If you pass in a run tree directly, return a shallow clone\n        if (isRunTree(originalConfig)) {\n            Object.assign(this, {\n                ...originalConfig\n            });\n            return;\n        }\n        const defaultConfig = RunTree.getDefaultConfig();\n        const { metadata, ...config } = originalConfig;\n        const client = config.client ?? RunTree.getSharedClient();\n        const dedupedMetadata = {\n            ...metadata,\n            ...config?.extra?.metadata\n        };\n        config.extra = {\n            ...config.extra,\n            metadata: dedupedMetadata\n        };\n        if (\"id\" in config && config.id == null) {\n            delete config.id;\n        }\n        Object.assign(this, {\n            ...defaultConfig,\n            ...config,\n            client\n        });\n        this.execution_order ??= 1;\n        this.child_execution_order ??= 1;\n        // Generate serialized start time for ID generation\n        if (!this.dotted_order) {\n            this._serialized_start_time = getMicrosecondPrecisionDatestring(this.start_time, this.execution_order);\n        }\n        // Generate id from serialized start_time if not provided\n        if (!this.id) {\n            this.id = (0,_utils_uuid_js__WEBPACK_IMPORTED_MODULE_8__.uuid7FromTime)(this._serialized_start_time ?? this.start_time);\n        }\n        if (!this.trace_id) {\n            if (this.parent_run) {\n                this.trace_id = this.parent_run.trace_id ?? this.id;\n            } else {\n                this.trace_id = this.id;\n            }\n        }\n        this.replicas = _ensureWriteReplicas(this.replicas);\n        // Now set the dotted order with the actual ID\n        if (!this.dotted_order) {\n            const { dottedOrder } = convertToDottedOrderFormat(this.start_time, this.id, this.execution_order);\n            if (this.parent_run) {\n                this.dotted_order = this.parent_run.dotted_order + \".\" + dottedOrder;\n            } else {\n                this.dotted_order = dottedOrder;\n            }\n        }\n    }\n    set metadata(metadata) {\n        this.extra = {\n            ...this.extra,\n            metadata: {\n                ...this.extra?.metadata,\n                ...metadata\n            }\n        };\n    }\n    get metadata() {\n        return this.extra?.metadata;\n    }\n    static getDefaultConfig() {\n        const start_time = Date.now();\n        return {\n            run_type: \"chain\",\n            project_name: (0,_utils_project_js__WEBPACK_IMPORTED_MODULE_6__.getDefaultProjectName)(),\n            child_runs: [],\n            api_url: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_ENDPOINT\") ?? \"http://localhost:1984\",\n            api_key: (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGCHAIN_API_KEY\"),\n            caller_options: {},\n            start_time,\n            serialized: {},\n            inputs: {},\n            extra: {}\n        };\n    }\n    static getSharedClient() {\n        if (!RunTree.sharedClient) {\n            RunTree.sharedClient = new _client_js__WEBPACK_IMPORTED_MODULE_0__.Client();\n        }\n        return RunTree.sharedClient;\n    }\n    createChild(config) {\n        const child_execution_order = this.child_execution_order + 1;\n        // Handle replicas: if child has its own replicas, use those; otherwise inherit parent's (with reroot stripped)\n        // Reroot should only apply to the run where it's explicitly configured, not propagate down\n        const inheritedReplicas = this.replicas?.map((replica)=>{\n            const { reroot, ...rest } = replica;\n            return rest;\n        });\n        const childReplicas = config.replicas ?? inheritedReplicas;\n        const child = new RunTree({\n            ...config,\n            parent_run: this,\n            project_name: this.project_name,\n            replicas: childReplicas,\n            client: this.client,\n            tracingEnabled: this.tracingEnabled,\n            execution_order: child_execution_order,\n            child_execution_order: child_execution_order\n        });\n        // Copy context vars over into the new run tree.\n        if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY in this) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            child[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY] = this[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._LC_CONTEXT_VARIABLES_KEY];\n        }\n        const LC_CHILD = Symbol.for(\"lc:child_config\");\n        const presentConfig = config.extra?.[LC_CHILD] ?? this.extra[LC_CHILD];\n        // tracing for LangChain is defined by the _parentRunId and runMap of the tracer\n        if (isRunnableConfigLike(presentConfig)) {\n            const newConfig = {\n                ...presentConfig\n            };\n            const callbacks = isCallbackManagerLike(newConfig.callbacks) ? newConfig.callbacks.copy?.() : undefined;\n            if (callbacks) {\n                // update the parent run id\n                Object.assign(callbacks, {\n                    _parentRunId: child.id\n                });\n                // only populate if we're in a newer LC.JS version\n                callbacks.handlers?.find(isLangChainTracerLike)?.updateFromRunTree?.(child);\n                newConfig.callbacks = callbacks;\n            }\n            child.extra[LC_CHILD] = newConfig;\n        }\n        // propagate child_execution_order upwards\n        const visited = new Set();\n        let current = this;\n        while(current != null && !visited.has(current.id)){\n            visited.add(current.id);\n            current.child_execution_order = Math.max(current.child_execution_order, child_execution_order);\n            current = current.parent_run;\n        }\n        this.child_runs.push(child);\n        return child;\n    }\n    async end(outputs, error, endTime = Date.now(), metadata) {\n        this.outputs = this.outputs ?? outputs;\n        this.error = this.error ?? error;\n        this.end_time = this.end_time ?? endTime;\n        if (metadata && Object.keys(metadata).length > 0) {\n            this.extra = this.extra ? {\n                ...this.extra,\n                metadata: {\n                    ...this.extra.metadata,\n                    ...metadata\n                }\n            } : {\n                metadata\n            };\n        }\n    }\n    _convertToCreate(run, runtimeEnv, excludeChildRuns = true) {\n        const runExtra = run.extra ?? {};\n        // Avoid overwriting the runtime environment if it's already set\n        if (runExtra?.runtime?.library === undefined) {\n            if (!runExtra.runtime) {\n                runExtra.runtime = {};\n            }\n            if (runtimeEnv) {\n                for (const [k, v] of Object.entries(runtimeEnv)){\n                    if (!runExtra.runtime[k]) {\n                        runExtra.runtime[k] = v;\n                    }\n                }\n            }\n        }\n        let child_runs;\n        let parent_run_id;\n        if (!excludeChildRuns) {\n            child_runs = run.child_runs.map((child_run)=>this._convertToCreate(child_run, runtimeEnv, excludeChildRuns));\n            parent_run_id = undefined;\n        } else {\n            parent_run_id = run.parent_run?.id ?? run.parent_run_id;\n            child_runs = [];\n        }\n        return {\n            id: run.id,\n            name: run.name,\n            start_time: run._serialized_start_time ?? run.start_time,\n            end_time: run.end_time,\n            run_type: run.run_type,\n            reference_example_id: run.reference_example_id,\n            extra: runExtra,\n            serialized: run.serialized,\n            error: run.error,\n            inputs: run.inputs,\n            outputs: run.outputs,\n            session_name: run.project_name,\n            child_runs: child_runs,\n            parent_run_id: parent_run_id,\n            trace_id: run.trace_id,\n            dotted_order: run.dotted_order,\n            tags: run.tags,\n            attachments: run.attachments,\n            events: run.events\n        };\n    }\n    _sliceParentId(parentId, run) {\n        /**\n         * Slice the parent id from dotted order.\n         * Additionally check if the current run is a child of the parent. If so, update\n         * the parent_run_id to undefined, and set the trace id to the new root id after\n         * parent_id.\n         */ if (run.dotted_order) {\n            const segs = run.dotted_order.split(\".\");\n            let startIdx = null;\n            // Find the index of the parent ID in the dotted order\n            for(let idx = 0; idx < segs.length; idx++){\n                const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                if (segId === parentId) {\n                    startIdx = idx;\n                    break;\n                }\n            }\n            if (startIdx !== null) {\n                // Trim segments to start after parent_id (exclusive)\n                const trimmedSegs = segs.slice(startIdx + 1);\n                // Rebuild dotted_order\n                run.dotted_order = trimmedSegs.join(\".\");\n                if (trimmedSegs.length > 0) {\n                    run.trace_id = trimmedSegs[0].slice(-TIMESTAMP_LENGTH);\n                } else {\n                    run.trace_id = run.id;\n                }\n            }\n        }\n        if (run.parent_run_id === parentId) {\n            // We've found the new root node.\n            run.parent_run_id = undefined;\n        }\n    }\n    _setReplicaTraceRoot(replicaKey, traceRootId) {\n        // Set the replica trace root in context vars on this run and all descendants\n        const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n        replicaTraceRoots[replicaKey] = traceRootId;\n        (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.setContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY, replicaTraceRoots);\n        // Recursively update all descendants to avoid race conditions\n        // around run tree creation vs processing time\n        for (const child of this.child_runs){\n            child._setReplicaTraceRoot(replicaKey, traceRootId);\n        }\n    }\n    _remapForProject(params) {\n        const { projectName, runtimeEnv, excludeChildRuns = true, reroot = false, distributedParentId, apiUrl, apiKey, workspaceId } = params;\n        const baseRun = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n        // Skip remapping if project name is the same\n        if (projectName === this.project_name) {\n            return {\n                ...baseRun,\n                session_name: projectName\n            };\n        }\n        // Apply reroot logic before ID remapping\n        if (reroot) {\n            if (distributedParentId) {\n                // If we have a distributed parent ID, slice at that point\n                this._sliceParentId(distributedParentId, baseRun);\n            } else {\n                // If no distributed parent ID, simply make this run a root run\n                // by removing parent_run_id and resetting trace info\n                baseRun.parent_run_id = undefined;\n                // Keep the current run as the trace root\n                if (baseRun.dotted_order) {\n                    // Reset dotted order to just this run\n                    const segs = baseRun.dotted_order.split(\".\");\n                    if (segs.length > 0) {\n                        baseRun.dotted_order = segs[segs.length - 1];\n                        baseRun.trace_id = baseRun.id;\n                    }\n                }\n            }\n            // Store this run's original ID in context vars so descendants know the new trace root\n            // We store the original ID (before remapping) so it can be found in dotted_order\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId\n            });\n            this._setReplicaTraceRoot(replicaKey, baseRun.id);\n        }\n        // If an ancestor was rerooted for this replica, update trace_id and dotted_order\n        // to reflect the new trace hierarchy. This is tracked via context variables.\n        let ancestorRerootedTraceId;\n        if (!reroot) {\n            const replicaTraceRoots = (0,_utils_context_vars_js__WEBPACK_IMPORTED_MODULE_4__.getContextVar)(this, _singletons_constants_js__WEBPACK_IMPORTED_MODULE_3__._REPLICA_TRACE_ROOTS_KEY) ?? {};\n            const replicaKey = getReplicaKey({\n                projectName,\n                apiUrl,\n                apiKey,\n                workspaceId\n            });\n            ancestorRerootedTraceId = replicaTraceRoots[replicaKey];\n            if (ancestorRerootedTraceId) {\n                // An ancestor was rerooted for this replica, so set our trace_id\n                // to the ancestor's original (unmapped) ID. It will be remapped along with other IDs.\n                baseRun.trace_id = ancestorRerootedTraceId;\n                // Also slice the dotted_order to start from the new trace root\n                // This ensures descendants of a rerooted ancestor have correct hierarchy\n                if (baseRun.dotted_order) {\n                    const segs = baseRun.dotted_order.split(\".\");\n                    let rootIdx = null;\n                    // Find the new trace root's segment in dotted_order\n                    for(let idx = 0; idx < segs.length; idx++){\n                        const segId = segs[idx].slice(-TIMESTAMP_LENGTH);\n                        if (segId === ancestorRerootedTraceId) {\n                            rootIdx = idx;\n                            break;\n                        }\n                    }\n                    if (rootIdx !== null) {\n                        // Keep segments from new trace root onwards\n                        const trimmedSegs = segs.slice(rootIdx);\n                        baseRun.dotted_order = trimmedSegs.join(\".\");\n                    }\n                }\n            }\n        }\n        // Remap IDs for the replica using uuid5 (deterministic)\n        // This ensures consistency across runs in the same replica\n        const oldId = baseRun.id;\n        const newId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${oldId}:${projectName}`, UUID_NAMESPACE_DNS);\n        // Remap trace_id\n        let newTraceId;\n        if (baseRun.trace_id) {\n            newTraceId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.trace_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        } else {\n            newTraceId = newId;\n        }\n        // Remap parent_run_id\n        let newParentId;\n        if (baseRun.parent_run_id) {\n            newParentId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${baseRun.parent_run_id}:${projectName}`, UUID_NAMESPACE_DNS);\n        }\n        // Remap dotted_order segments\n        let newDottedOrder;\n        if (baseRun.dotted_order) {\n            const segs = baseRun.dotted_order.split(\".\");\n            const remappedSegs = segs.map((seg)=>{\n                // Extract the UUID from the segment (last TIMESTAMP_LENGTH characters)\n                const segId = seg.slice(-TIMESTAMP_LENGTH);\n                const remappedId = (0,uuid__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(`${segId}:${projectName}`, UUID_NAMESPACE_DNS);\n                // Replace the UUID part while keeping the timestamp prefix\n                return seg.slice(0, -TIMESTAMP_LENGTH) + remappedId;\n            });\n            newDottedOrder = remappedSegs.join(\".\");\n        }\n        return {\n            ...baseRun,\n            id: newId,\n            trace_id: newTraceId,\n            parent_run_id: newParentId,\n            dotted_order: newDottedOrder,\n            session_name: projectName\n        };\n    }\n    async postRun(excludeChildRuns = true) {\n        try {\n            const runtimeEnv = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getRuntimeEnvironment)();\n            if (this.replicas && this.replicas.length > 0) {\n                for (const { projectName, apiKey, apiUrl, workspaceId, reroot } of this.replicas){\n                    const runCreate = this._remapForProject({\n                        projectName: projectName ?? this.project_name,\n                        runtimeEnv,\n                        excludeChildRuns: true,\n                        reroot,\n                        distributedParentId: this.distributedParentId,\n                        apiUrl,\n                        apiKey,\n                        workspaceId\n                    });\n                    await this.client.createRun(runCreate, {\n                        apiKey,\n                        apiUrl,\n                        workspaceId\n                    });\n                }\n            } else {\n                const runCreate = this._convertToCreate(this, runtimeEnv, excludeChildRuns);\n                await this.client.createRun(runCreate);\n            }\n            if (!excludeChildRuns) {\n                (0,_utils_warn_js__WEBPACK_IMPORTED_MODULE_7__.warnOnce)(\"Posting with excludeChildRuns=false is deprecated and will be removed in a future version.\");\n                for (const childRun of this.child_runs){\n                    await childRun.postRun(false);\n                }\n            }\n            this.child_runs = [];\n        } catch (error) {\n            console.error(`Error in postRun for run ${this.id}:`, error);\n        }\n    }\n    async patchRun(options) {\n        if (this.replicas && this.replicas.length > 0) {\n            for (const { projectName, apiKey, apiUrl, workspaceId, updates, reroot } of this.replicas){\n                const runData = this._remapForProject({\n                    projectName: projectName ?? this.project_name,\n                    runtimeEnv: undefined,\n                    excludeChildRuns: true,\n                    reroot,\n                    distributedParentId: this.distributedParentId,\n                    apiUrl,\n                    apiKey,\n                    workspaceId\n                });\n                const updatePayload = {\n                    id: runData.id,\n                    name: runData.name,\n                    run_type: runData.run_type,\n                    start_time: runData.start_time,\n                    outputs: runData.outputs,\n                    error: runData.error,\n                    parent_run_id: runData.parent_run_id,\n                    session_name: runData.session_name,\n                    reference_example_id: runData.reference_example_id,\n                    end_time: runData.end_time,\n                    dotted_order: runData.dotted_order,\n                    trace_id: runData.trace_id,\n                    events: runData.events,\n                    tags: runData.tags,\n                    extra: runData.extra,\n                    attachments: this.attachments,\n                    ...updates\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    updatePayload.inputs = runData.inputs;\n                }\n                await this.client.updateRun(runData.id, updatePayload, {\n                    apiKey,\n                    apiUrl,\n                    workspaceId\n                });\n            }\n        } else {\n            try {\n                const runUpdate = {\n                    name: this.name,\n                    run_type: this.run_type,\n                    start_time: this._serialized_start_time ?? this.start_time,\n                    end_time: this.end_time,\n                    error: this.error,\n                    outputs: this.outputs,\n                    parent_run_id: this.parent_run?.id ?? this.parent_run_id,\n                    reference_example_id: this.reference_example_id,\n                    extra: this.extra,\n                    events: this.events,\n                    dotted_order: this.dotted_order,\n                    trace_id: this.trace_id,\n                    tags: this.tags,\n                    attachments: this.attachments,\n                    session_name: this.project_name\n                };\n                // Important that inputs is not a key in the run update\n                // if excluded because it will overwrite the run create if the\n                // two operations are merged during batching\n                if (!options?.excludeInputs) {\n                    runUpdate.inputs = this.inputs;\n                }\n                await this.client.updateRun(this.id, runUpdate);\n            } catch (error) {\n                console.error(`Error in patchRun for run ${this.id}`, error);\n            }\n        }\n        this.child_runs = [];\n    }\n    toJSON() {\n        return this._convertToCreate(this, undefined, false);\n    }\n    /**\n     * Add an event to the run tree.\n     * @param event - A single event or string to add\n     */ addEvent(event) {\n        if (!this.events) {\n            this.events = [];\n        }\n        if (typeof event === \"string\") {\n            this.events.push({\n                name: \"event\",\n                time: new Date().toISOString(),\n                message: event\n            });\n        } else {\n            this.events.push({\n                ...event,\n                time: event.time ?? new Date().toISOString()\n            });\n        }\n    }\n    static fromRunnableConfig(parentConfig, props) {\n        // We only handle the callback manager case for now\n        const callbackManager = parentConfig?.callbacks;\n        let parentRun;\n        let projectName;\n        let client;\n        let tracingEnabled = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.isTracingEnabled)();\n        if (callbackManager) {\n            const parentRunId = callbackManager?.getParentRunId?.() ?? \"\";\n            const langChainTracer = callbackManager?.handlers?.find((handler)=>handler?.name == \"langchain_tracer\");\n            parentRun = langChainTracer?.getRun?.(parentRunId);\n            projectName = langChainTracer?.projectName;\n            client = langChainTracer?.client;\n            tracingEnabled = tracingEnabled || !!langChainTracer;\n        }\n        if (!parentRun) {\n            return new RunTree({\n                ...props,\n                client,\n                tracingEnabled,\n                project_name: projectName\n            });\n        }\n        const parentRunTree = new RunTree({\n            name: parentRun.name,\n            id: parentRun.id,\n            trace_id: parentRun.trace_id,\n            dotted_order: parentRun.dotted_order,\n            client,\n            tracingEnabled,\n            project_name: projectName,\n            tags: [\n                ...new Set((parentRun?.tags ?? []).concat(parentConfig?.tags ?? []))\n            ],\n            extra: {\n                metadata: {\n                    ...parentRun?.extra?.metadata,\n                    ...parentConfig?.metadata\n                }\n            }\n        });\n        return parentRunTree.createChild(props);\n    }\n    static fromDottedOrder(dottedOrder) {\n        return this.fromHeaders({\n            \"langsmith-trace\": dottedOrder\n        });\n    }\n    static fromHeaders(headers, inheritArgs) {\n        const rawHeaders = \"get\" in headers && typeof headers.get === \"function\" ? {\n            \"langsmith-trace\": headers.get(\"langsmith-trace\"),\n            baggage: headers.get(\"baggage\")\n        } : headers;\n        const headerTrace = rawHeaders[\"langsmith-trace\"];\n        if (!headerTrace || typeof headerTrace !== \"string\") return undefined;\n        const parentDottedOrder = headerTrace.trim();\n        const parsedDottedOrder = parentDottedOrder.split(\".\").map((part)=>{\n            const [strTime, uuid] = part.split(\"Z\");\n            return {\n                strTime,\n                time: Date.parse(strTime + \"Z\"),\n                uuid\n            };\n        });\n        const traceId = parsedDottedOrder[0].uuid;\n        const config = {\n            ...inheritArgs,\n            name: inheritArgs?.[\"name\"] ?? \"parent\",\n            run_type: inheritArgs?.[\"run_type\"] ?? \"chain\",\n            start_time: inheritArgs?.[\"start_time\"] ?? Date.now(),\n            id: parsedDottedOrder.at(-1)?.uuid,\n            trace_id: traceId,\n            dotted_order: parentDottedOrder\n        };\n        if (rawHeaders[\"baggage\"] && typeof rawHeaders[\"baggage\"] === \"string\") {\n            const baggage = Baggage.fromHeader(rawHeaders[\"baggage\"]);\n            config.metadata = baggage.metadata;\n            config.tags = baggage.tags;\n            config.project_name = baggage.project_name;\n            config.replicas = baggage.replicas;\n        }\n        const runTree = new RunTree(config);\n        // Set the distributed parent ID to this run's ID for rerooting\n        runTree.distributedParentId = runTree.id;\n        return runTree;\n    }\n    toHeaders(headers) {\n        const result = {\n            \"langsmith-trace\": this.dotted_order,\n            baggage: new Baggage(this.extra?.metadata, this.tags, this.project_name, this.replicas).toHeader()\n        };\n        if (headers) {\n            for (const [key, value] of Object.entries(result)){\n                headers.set(key, value);\n            }\n        }\n        return result;\n    }\n}\nObject.defineProperty(RunTree, \"sharedClient\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: null\n});\nfunction isRunTree(x) {\n    return x != null && typeof x.createChild === \"function\" && typeof x.postRun === \"function\";\n}\nfunction isLangChainTracerLike(x) {\n    return typeof x === \"object\" && x != null && typeof x.name === \"string\" && x.name === \"langchain_tracer\";\n}\nfunction containsLangChainTracerLike(x) {\n    return Array.isArray(x) && x.some((callback)=>isLangChainTracerLike(callback));\n}\nfunction isCallbackManagerLike(x) {\n    return typeof x === \"object\" && x != null && Array.isArray(x.handlers);\n}\nfunction isRunnableConfigLike(x) {\n    // Check that it's an object with a callbacks arg\n    // that has either a CallbackManagerLike object with a langchain tracer within it\n    // or an array with a LangChainTracerLike object within it\n    const callbacks = x?.callbacks;\n    return x != null && typeof callbacks === \"object\" && // Callback manager with a langchain tracer\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (containsLangChainTracerLike(callbacks?.handlers) || // Or it's an array with a LangChainTracerLike object within it\n    containsLangChainTracerLike(callbacks));\n}\nfunction _getWriteReplicasFromEnv() {\n    const envVar = (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getEnvironmentVariable)(\"LANGSMITH_RUNS_ENDPOINTS\");\n    if (!envVar) return [];\n    try {\n        const parsed = JSON.parse(envVar);\n        if (Array.isArray(parsed)) {\n            const replicas = [];\n            for (const item of parsed){\n                if (typeof item !== \"object\" || item === null) {\n                    console.warn(`Invalid item type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected object, got ${typeof item}`);\n                    continue;\n                }\n                if (typeof item.api_url !== \"string\") {\n                    console.warn(`Invalid api_url type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_url}`);\n                    continue;\n                }\n                if (typeof item.api_key !== \"string\") {\n                    console.warn(`Invalid api_key type in LANGSMITH_RUNS_ENDPOINTS: ` + `expected string, got ${typeof item.api_key}`);\n                    continue;\n                }\n                replicas.push({\n                    apiUrl: item.api_url.replace(/\\/$/, \"\"),\n                    apiKey: item.api_key\n                });\n            }\n            return replicas;\n        } else if (typeof parsed === \"object\" && parsed !== null) {\n            _checkEndpointEnvUnset(parsed);\n            const replicas = [];\n            for (const [url, key] of Object.entries(parsed)){\n                const cleanUrl = url.replace(/\\/$/, \"\");\n                if (typeof key === \"string\") {\n                    replicas.push({\n                        apiUrl: cleanUrl,\n                        apiKey: key\n                    });\n                } else {\n                    console.warn(`Invalid value type in LANGSMITH_RUNS_ENDPOINTS for URL ${url}: ` + `expected string, got ${typeof key}`);\n                    continue;\n                }\n            }\n            return replicas;\n        } else {\n            console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" + `objects with api_url and api_key properties, or object mapping url->apiKey, got ${typeof parsed}`);\n            return [];\n        }\n    } catch (e) {\n        if ((0,_utils_error_js__WEBPACK_IMPORTED_MODULE_2__.isConflictingEndpointsError)(e)) {\n            throw e;\n        }\n        console.warn(\"Invalid LANGSMITH_RUNS_ENDPOINTS  must be valid JSON array of \" + \"objects with api_url and api_key properties, or object mapping url->apiKey\");\n        return [];\n    }\n}\nfunction _ensureWriteReplicas(replicas) {\n    // If null -> fetch from env\n    if (replicas) {\n        return replicas.map((replica)=>{\n            if (Array.isArray(replica)) {\n                return {\n                    projectName: replica[0],\n                    updates: replica[1]\n                };\n            }\n            return replica;\n        });\n    }\n    return _getWriteReplicasFromEnv();\n}\nfunction _checkEndpointEnvUnset(parsed) {\n    if (Object.keys(parsed).length > 0 && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_5__.getLangSmithEnvironmentVariable)(\"ENDPOINT\")) {\n        throw new _utils_error_js__WEBPACK_IMPORTED_MODULE_2__.ConflictingEndpointsError();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvcnVuX3RyZWVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ087QUFDK0M7QUFDTTtBQUMxQjtBQUNTO0FBQ3JCO0FBQ007QUFDdEI7QUFDTTtBQUNiO0FBQ3BDLE1BQU1nQixtQkFBbUI7QUFDekIsa0VBQWtFO0FBQ2xFLE1BQU1DLHFCQUFxQjtBQUMzQixTQUFTQyxjQUFjQyxPQUFPO0lBQzFCLHdFQUF3RTtJQUN4RSwrR0FBK0c7SUFDL0cseUNBQXlDO0lBQ3pDLE1BQU1DLGFBQWFDLE9BQU9DLElBQUksQ0FBQ0gsU0FBU0ksSUFBSTtJQUM1QyxNQUFNQyxVQUFVSixXQUNYSyxHQUFHLENBQUMsQ0FBQ0MsTUFBUSxDQUFDLEVBQUVBLElBQUksQ0FBQyxFQUFFUCxPQUFPLENBQUNPLElBQUksSUFBSSxHQUFHLENBQUMsRUFDM0NDLElBQUksQ0FBQztJQUNWLE9BQU9aLGdEQUFNQSxDQUFDUyxTQUFTUDtBQUMzQjtBQUNBLFNBQVNXLHFCQUFxQkMsS0FBSztJQUMvQixPQUFPQSxNQUFNQyxPQUFPLENBQUMsVUFBVTtBQUNuQztBQUNBLFNBQVNDLGtDQUFrQ0MsS0FBSyxFQUFFQyxpQkFBaUIsQ0FBQztJQUNoRSwyRUFBMkU7SUFDM0UsOENBQThDO0lBQzlDLE1BQU1DLGNBQWNELGVBQWVFLE9BQU8sQ0FBQyxHQUFHQyxLQUFLLENBQUMsR0FBRyxHQUFHQyxRQUFRLENBQUMsR0FBRztJQUN0RSxPQUFPLENBQUMsRUFBRSxJQUFJQyxLQUFLTixPQUFPTyxXQUFXLEdBQUdILEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFRixZQUFZLENBQUMsQ0FBQztBQUN6RTtBQUNPLFNBQVNNLDJCQUEyQlIsS0FBSyxFQUFFUyxLQUFLLEVBQUVSLGlCQUFpQixDQUFDO0lBQ3ZFLE1BQU1TLGlDQUFpQ1gsa0NBQWtDQyxPQUFPQztJQUNoRixPQUFPO1FBQ0hVLGFBQWFmLHFCQUFx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Q0osRUFDQSxPQUFPSyxHQUFHO1FBQ04sSUFBSTlPLDRFQUEyQkEsQ0FBQzhPLElBQUk7WUFDaEMsTUFBTUE7UUFDVjtRQUNBM0QsUUFBUXVELElBQUksQ0FBQyxvRUFDVDtRQUNKLE9BQU8sRUFBRTtJQUNiO0FBQ0o7QUFDQSxTQUFTckoscUJBQXFCdEMsUUFBUTtJQUNsQyw0QkFBNEI7SUFDNUIsSUFBSUEsVUFBVTtRQUNWLE9BQU9BLFNBQVN4QixHQUFHLENBQUMsQ0FBQ047WUFDakIsSUFBSWtOLE1BQU1DLE9BQU8sQ0FBQ25OLFVBQVU7Z0JBQ3hCLE9BQU87b0JBQ0g4SSxhQUFhOUksT0FBTyxDQUFDLEVBQUU7b0JBQ3ZCcUssU0FBU3JLLE9BQU8sQ0FBQyxFQUFFO2dCQUN2QjtZQUNKO1lBQ0EsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsT0FBT3NOO0FBQ1g7QUFDQSxTQUFTSSx1QkFBdUJGLE1BQU07SUFDbEMsSUFBSXROLE9BQU9DLElBQUksQ0FBQ3FOLFFBQVEzSyxNQUFNLEdBQUcsS0FDN0JyRCw4RUFBK0JBLENBQUMsYUFBYTtRQUM3QyxNQUFNLElBQUlSLHNFQUF5QkE7SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9ydW5fdHJlZXMuanM/NTEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7IGlzVHJhY2luZ0VuYWJsZWQgfSBmcm9tIFwiLi9lbnYuanNcIjtcbmltcG9ydCB7IGlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciwgQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciwgfSBmcm9tIFwiLi91dGlscy9lcnJvci5qc1wiO1xuaW1wb3J0IHsgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSwgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZLCB9IGZyb20gXCIuL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBnZXRDb250ZXh0VmFyLCBzZXRDb250ZXh0VmFyIH0gZnJvbSBcIi4vdXRpbHMvY29udGV4dF92YXJzLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnZpcm9ubWVudFZhcmlhYmxlLCBnZXRSdW50aW1lRW52aXJvbm1lbnQsIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0UHJvamVjdE5hbWUgfSBmcm9tIFwiLi91dGlscy9wcm9qZWN0LmpzXCI7XG5pbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4vdXRpbHMvZW52LmpzXCI7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gXCIuL3V0aWxzL3dhcm4uanNcIjtcbmltcG9ydCB7IHV1aWQ3RnJvbVRpbWUgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuaW1wb3J0IHsgdjUgYXMgdXVpZHY1IH0gZnJvbSBcInV1aWRcIjtcbmNvbnN0IFRJTUVTVEFNUF9MRU5HVEggPSAzNjtcbi8vIEROUyBuYW1lc3BhY2UgZm9yIFVVSUQgdjUgKHNhbWUgYXMgUHl0aG9uJ3MgdXVpZC5OQU1FU1BBQ0VfRE5TKVxuY29uc3QgVVVJRF9OQU1FU1BBQ0VfRE5TID0gXCI2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIjtcbmZ1bmN0aW9uIGdldFJlcGxpY2FLZXkocmVwbGljYSkge1xuICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGtleSBieSBoYXNoaW5nIHRoZSByZXBsaWNhJ3MgaWRlbnRpZnlpbmcgcHJvcGVydGllc1xuICAgIC8vIFRoaXMgZW5zdXJlcyBlYWNoIHVuaXF1ZSByZXBsaWNhIChjb21iaW5hdGlvbiBvZiBwcm9qZWN0TmFtZSwgYXBpVXJsLCB3b3Jrc3BhY2VJZCwgYXBpS2V5KSBnZXRzIGEgdW5pcXVlIGtleVxuICAgIC8vIFNvcnQga2V5cyB0byBlbnN1cmUgY29uc2lzdGVudCBoYXNoaW5nXG4gICAgY29uc3Qgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKHJlcGxpY2EpLnNvcnQoKTtcbiAgICBjb25zdCBrZXlEYXRhID0gc29ydGVkS2V5c1xuICAgICAgICAubWFwKChrZXkpID0+IGAke2tleX06JHtyZXBsaWNhW2tleV0gPz8gXCJcIn1gKVxuICAgICAgICAuam9pbihcInxcIik7XG4gICAgcmV0dXJuIHV1aWR2NShrZXlEYXRhLCBVVUlEX05BTUVTUEFDRV9ETlMpO1xufVxuZnVuY3Rpb24gc3RyaXBOb25BbHBoYW51bWVyaWMoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvWy06Ll0vZywgXCJcIik7XG59XG5mdW5jdGlvbiBnZXRNaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcoZXBvY2gsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIC8vIERhdGUgb25seSBoYXMgbWlsbGlzZWNvbmQgcHJlY2lzaW9uLCBzbyB3ZSB1c2UgdGhlIG1pY3Jvc2Vjb25kcyB0byBicmVha1xuICAgIC8vIHBvc3NpYmxlIHRpZXMsIGF2b2lkaW5nIGluY29ycmVjdCBydW4gb3JkZXJcbiAgICBjb25zdCBwYWRkZWRPcmRlciA9IGV4ZWN1dGlvbk9yZGVyLnRvRml4ZWQoMCkuc2xpY2UoMCwgMykucGFkU3RhcnQoMywgXCIwXCIpO1xuICAgIHJldHVybiBgJHtuZXcgRGF0ZShlcG9jaCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAtMSl9JHtwYWRkZWRPcmRlcn1aYDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Eb3R0ZWRPcmRlckZvcm1hdChlcG9jaCwgcnVuSWQsIGV4ZWN1dGlvbk9yZGVyID0gMSkge1xuICAgIGNvbnN0IG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyA9IGdldE1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyhlcG9jaCwgZXhlY3V0aW9uT3JkZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvdHRlZE9yZGVyOiBzdHJpcE5vbkFscGhhbnVtZXJpYyhtaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcpICsgcnVuSWQsXG4gICAgICAgIG1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyxcbiAgICB9O1xufVxuLyoqXG4gKiBCYWdnYWdlIGhlYWRlciBpbmZvcm1hdGlvblxuICovXG5jbGFzcyBCYWdnYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YSwgdGFncywgcHJvamVjdF9uYW1lLCByZXBsaWNhcykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb2plY3RfbmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXBsaWNhc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMucHJvamVjdF9uYW1lID0gcHJvamVjdF9uYW1lO1xuICAgICAgICB0aGlzLnJlcGxpY2FzID0gcmVwbGljYXM7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGVhZGVyKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdmFsdWUuc3BsaXQoXCIsXCIpO1xuICAgICAgICBsZXQgbWV0YWRhdGEgPSB7fTtcbiAgICAgICAgbGV0IHRhZ3MgPSBbXTtcbiAgICAgICAgbGV0IHByb2plY3RfbmFtZTtcbiAgICAgICAgbGV0IHJlcGxpY2FzO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHVyaVZhbHVlXSA9IGl0ZW0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQodXJpVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJsYW5nc21pdGgtbWV0YWRhdGFcIikge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLXRhZ3NcIikge1xuICAgICAgICAgICAgICAgIHRhZ3MgPSB2YWx1ZS5zcGxpdChcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgPT09IFwibGFuZ3NtaXRoLXByb2plY3RcIikge1xuICAgICAgICAgICAgICAgIHByb2plY3RfbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBcImxhbmdzbWl0aC1yZXBsaWNhc1wiKSB7XG4gICAgICAgICAgICAgICAgcmVwbGljYXMgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJhZ2dhZ2UobWV0YWRhdGEsIHRhZ3MsIHByb2plY3RfbmFtZSwgcmVwbGljYXMpO1xuICAgIH1cbiAgICB0b0hlYWRlcigpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgJiYgT2JqZWN0LmtleXModGhpcy5tZXRhZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLW1ldGFkYXRhPSR7ZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHRoaXMubWV0YWRhdGEpKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50YWdzICYmIHRoaXMudGFncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGBsYW5nc21pdGgtdGFncz0ke2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLnRhZ3Muam9pbihcIixcIikpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2plY3RfbmFtZSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChgbGFuZ3NtaXRoLXByb2plY3Q9JHtlbmNvZGVVUklDb21wb25lbnQodGhpcy5wcm9qZWN0X25hbWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcy5qb2luKFwiLFwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVuVHJlZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxDb25maWcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJydW5fdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwcm9qZWN0X25hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50X3J1blwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRfcnVuX2lkXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkX3J1bnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhcnRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmRfdGltZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJleHRyYVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImVycm9yXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNlcmlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5wdXRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm91dHB1dHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVmZXJlbmNlX2V4YW1wbGVfaWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xpZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImV2ZW50c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFjZV9pZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb3R0ZWRfb3JkZXJcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhY2luZ0VuYWJsZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZXhlY3V0aW9uX29yZGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNoaWxkX2V4ZWN1dGlvbl9vcmRlclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNobWVudHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBydW4uXG4gICAgICAgICAqIEVhY2ggZW50cnkgaXMgYSB0dXBsZSBvZiBbbWltZV90eXBlLCBieXRlc11cbiAgICAgICAgICovXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImF0dGFjaG1lbnRzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9qZWN0cyB0byByZXBsaWNhdGUgdGhpcyBydW4gdG8gd2l0aCBvcHRpb25hbCB1cGRhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVwbGljYXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlzdHJpYnV0ZWRQYXJlbnRJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc2VyaWFsaXplZF9zdGFydF90aW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHlvdSBwYXNzIGluIGEgcnVuIHRyZWUgZGlyZWN0bHksIHJldHVybiBhIHNoYWxsb3cgY2xvbmVcbiAgICAgICAgaWYgKGlzUnVuVHJlZShvcmlnaW5hbENvbmZpZykpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgeyAuLi5vcmlnaW5hbENvbmZpZyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0gUnVuVHJlZS5nZXREZWZhdWx0Q29uZmlnKCk7XG4gICAgICAgIGNvbnN0IHsgbWV0YWRhdGEsIC4uLmNvbmZpZyB9ID0gb3JpZ2luYWxDb25maWc7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbmZpZy5jbGllbnQgPz8gUnVuVHJlZS5nZXRTaGFyZWRDbGllbnQoKTtcbiAgICAgICAgY29uc3QgZGVkdXBlZE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICAuLi5jb25maWc/LmV4dHJhPy5tZXRhZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uZmlnLmV4dHJhID0geyAuLi5jb25maWcuZXh0cmEsIG1ldGFkYXRhOiBkZWR1cGVkTWV0YWRhdGEgfTtcbiAgICAgICAgaWYgKFwiaWRcIiBpbiBjb25maWcgJiYgY29uZmlnLmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IC4uLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZywgY2xpZW50IH0pO1xuICAgICAgICB0aGlzLmV4ZWN1dGlvbl9vcmRlciA/Pz0gMTtcbiAgICAgICAgdGhpcy5jaGlsZF9leGVjdXRpb25fb3JkZXIgPz89IDE7XG4gICAgICAgIC8vIEdlbmVyYXRlIHNlcmlhbGl6ZWQgc3RhcnQgdGltZSBmb3IgSUQgZ2VuZXJhdGlvblxuICAgICAgICBpZiAoIXRoaXMuZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPSBnZXRNaWNyb3NlY29uZFByZWNpc2lvbkRhdGVzdHJpbmcodGhpcy5zdGFydF90aW1lLCB0aGlzLmV4ZWN1dGlvbl9vcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2VuZXJhdGUgaWQgZnJvbSBzZXJpYWxpemVkIHN0YXJ0X3RpbWUgaWYgbm90IHByb3ZpZGVkXG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHV1aWQ3RnJvbVRpbWUodGhpcy5fc2VyaWFsaXplZF9zdGFydF90aW1lID8/IHRoaXMuc3RhcnRfdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRfcnVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZV9pZCA9IHRoaXMucGFyZW50X3J1bi50cmFjZV9pZCA/PyB0aGlzLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZV9pZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBsaWNhcyA9IF9lbnN1cmVXcml0ZVJlcGxpY2FzKHRoaXMucmVwbGljYXMpO1xuICAgICAgICAvLyBOb3cgc2V0IHRoZSBkb3R0ZWQgb3JkZXIgd2l0aCB0aGUgYWN0dWFsIElEXG4gICAgICAgIGlmICghdGhpcy5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG90dGVkT3JkZXIgfSA9IGNvbnZlcnRUb0RvdHRlZE9yZGVyRm9ybWF0KHRoaXMuc3RhcnRfdGltZSwgdGhpcy5pZCwgdGhpcy5leGVjdXRpb25fb3JkZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50X3J1bikge1xuICAgICAgICAgICAgICAgIHRoaXMuZG90dGVkX29yZGVyID0gdGhpcy5wYXJlbnRfcnVuLmRvdHRlZF9vcmRlciArIFwiLlwiICsgZG90dGVkT3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvdHRlZF9vcmRlciA9IGRvdHRlZE9yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBtZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmV4dHJhID0ge1xuICAgICAgICAgICAgLi4udGhpcy5leHRyYSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5leHRyYT8ubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgLi4ubWV0YWRhdGEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhPy5tZXRhZGF0YTtcbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRDb25maWcoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0X3RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVuX3R5cGU6IFwiY2hhaW5cIixcbiAgICAgICAgICAgIHByb2plY3RfbmFtZTogZ2V0RGVmYXVsdFByb2plY3ROYW1lKCksXG4gICAgICAgICAgICBjaGlsZF9ydW5zOiBbXSxcbiAgICAgICAgICAgIGFwaV91cmw6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fRU5EUE9JTlRcIikgPz8gXCJodHRwOi8vbG9jYWxob3N0OjE5ODRcIixcbiAgICAgICAgICAgIGFwaV9rZXk6IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HQ0hBSU5fQVBJX0tFWVwiKSxcbiAgICAgICAgICAgIGNhbGxlcl9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIHN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiB7fSxcbiAgICAgICAgICAgIGlucHV0czoge30sXG4gICAgICAgICAgICBleHRyYToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaGFyZWRDbGllbnQoKSB7XG4gICAgICAgIGlmICghUnVuVHJlZS5zaGFyZWRDbGllbnQpIHtcbiAgICAgICAgICAgIFJ1blRyZWUuc2hhcmVkQ2xpZW50ID0gbmV3IENsaWVudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSdW5UcmVlLnNoYXJlZENsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlQ2hpbGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkX2V4ZWN1dGlvbl9vcmRlciA9IHRoaXMuY2hpbGRfZXhlY3V0aW9uX29yZGVyICsgMTtcbiAgICAgICAgLy8gSGFuZGxlIHJlcGxpY2FzOiBpZiBjaGlsZCBoYXMgaXRzIG93biByZXBsaWNhcywgdXNlIHRob3NlOyBvdGhlcndpc2UgaW5oZXJpdCBwYXJlbnQncyAod2l0aCByZXJvb3Qgc3RyaXBwZWQpXG4gICAgICAgIC8vIFJlcm9vdCBzaG91bGQgb25seSBhcHBseSB0byB0aGUgcnVuIHdoZXJlIGl0J3MgZXhwbGljaXRseSBjb25maWd1cmVkLCBub3QgcHJvcGFnYXRlIGRvd25cbiAgICAgICAgY29uc3QgaW5oZXJpdGVkUmVwbGljYXMgPSB0aGlzLnJlcGxpY2FzPy5tYXAoKHJlcGxpY2EpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVyb290LCAuLi5yZXN0IH0gPSByZXBsaWNhO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGlsZFJlcGxpY2FzID0gY29uZmlnLnJlcGxpY2FzID8/IGluaGVyaXRlZFJlcGxpY2FzO1xuICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBSdW5UcmVlKHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIHBhcmVudF9ydW46IHRoaXMsXG4gICAgICAgICAgICBwcm9qZWN0X25hbWU6IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgcmVwbGljYXM6IGNoaWxkUmVwbGljYXMsXG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgdHJhY2luZ0VuYWJsZWQ6IHRoaXMudHJhY2luZ0VuYWJsZWQsXG4gICAgICAgICAgICBleGVjdXRpb25fb3JkZXI6IGNoaWxkX2V4ZWN1dGlvbl9vcmRlcixcbiAgICAgICAgICAgIGNoaWxkX2V4ZWN1dGlvbl9vcmRlcjogY2hpbGRfZXhlY3V0aW9uX29yZGVyLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ29weSBjb250ZXh0IHZhcnMgb3ZlciBpbnRvIHRoZSBuZXcgcnVuIHRyZWUuXG4gICAgICAgIGlmIChfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIGluIHRoaXMpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBjaGlsZFtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXSA9XG4gICAgICAgICAgICAgICAgdGhpc1tfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBMQ19DSElMRCA9IFN5bWJvbC5mb3IoXCJsYzpjaGlsZF9jb25maWdcIik7XG4gICAgICAgIGNvbnN0IHByZXNlbnRDb25maWcgPSBjb25maWcuZXh0cmE/LltMQ19DSElMRF0gPz9cbiAgICAgICAgICAgIHRoaXMuZXh0cmFbTENfQ0hJTERdO1xuICAgICAgICAvLyB0cmFjaW5nIGZvciBMYW5nQ2hhaW4gaXMgZGVmaW5lZCBieSB0aGUgX3BhcmVudFJ1bklkIGFuZCBydW5NYXAgb2YgdGhlIHRyYWNlclxuICAgICAgICBpZiAoaXNSdW5uYWJsZUNvbmZpZ0xpa2UocHJlc2VudENvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbmZpZyA9IHsgLi4ucHJlc2VudENvbmZpZyB9O1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gaXNDYWxsYmFja01hbmFnZXJMaWtlKG5ld0NvbmZpZy5jYWxsYmFja3MpXG4gICAgICAgICAgICAgICAgPyBuZXdDb25maWcuY2FsbGJhY2tzLmNvcHk/LigpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBwYXJlbnQgcnVuIGlkXG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjYWxsYmFja3MsIHsgX3BhcmVudFJ1bklkOiBjaGlsZC5pZCB9KTtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBvcHVsYXRlIGlmIHdlJ3JlIGluIGEgbmV3ZXIgTEMuSlMgdmVyc2lvblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5oYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICA/LmZpbmQoaXNMYW5nQ2hhaW5UcmFjZXJMaWtlKVxuICAgICAgICAgICAgICAgICAgICA/LnVwZGF0ZUZyb21SdW5UcmVlPy4oY2hpbGQpO1xuICAgICAgICAgICAgICAgIG5ld0NvbmZpZy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZC5leHRyYVtMQ19DSElMRF0gPSBuZXdDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGFnYXRlIGNoaWxkX2V4ZWN1dGlvbl9vcmRlciB1cHdhcmRzXG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudC5pZCkpIHtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnQuaWQpO1xuICAgICAgICAgICAgY3VycmVudC5jaGlsZF9leGVjdXRpb25fb3JkZXIgPSBNYXRoLm1heChjdXJyZW50LmNoaWxkX2V4ZWN1dGlvbl9vcmRlciwgY2hpbGRfZXhlY3V0aW9uX29yZGVyKTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudF9ydW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZF9ydW5zLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIGFzeW5jIGVuZChvdXRwdXRzLCBlcnJvciwgZW5kVGltZSA9IERhdGUubm93KCksIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMub3V0cHV0cyA9IHRoaXMub3V0cHV0cyA/PyBvdXRwdXRzO1xuICAgICAgICB0aGlzLmVycm9yID0gdGhpcy5lcnJvciA/PyBlcnJvcjtcbiAgICAgICAgdGhpcy5lbmRfdGltZSA9IHRoaXMuZW5kX3RpbWUgPz8gZW5kVGltZTtcbiAgICAgICAgaWYgKG1ldGFkYXRhICYmIE9iamVjdC5rZXlzKG1ldGFkYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmV4dHJhID0gdGhpcy5leHRyYVxuICAgICAgICAgICAgICAgID8geyAuLi50aGlzLmV4dHJhLCBtZXRhZGF0YTogeyAuLi50aGlzLmV4dHJhLm1ldGFkYXRhLCAuLi5tZXRhZGF0YSB9IH1cbiAgICAgICAgICAgICAgICA6IHsgbWV0YWRhdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY29udmVydFRvQ3JlYXRlKHJ1biwgcnVudGltZUVudiwgZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgcnVuRXh0cmEgPSBydW4uZXh0cmEgPz8ge307XG4gICAgICAgIC8vIEF2b2lkIG92ZXJ3cml0aW5nIHRoZSBydW50aW1lIGVudmlyb25tZW50IGlmIGl0J3MgYWxyZWFkeSBzZXRcbiAgICAgICAgaWYgKHJ1bkV4dHJhPy5ydW50aW1lPy5saWJyYXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghcnVuRXh0cmEucnVudGltZSkge1xuICAgICAgICAgICAgICAgIHJ1bkV4dHJhLnJ1bnRpbWUgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW50aW1lRW52KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocnVudGltZUVudikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFydW5FeHRyYS5ydW50aW1lW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5FeHRyYS5ydW50aW1lW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRfcnVucztcbiAgICAgICAgbGV0IHBhcmVudF9ydW5faWQ7XG4gICAgICAgIGlmICghZXhjbHVkZUNoaWxkUnVucykge1xuICAgICAgICAgICAgY2hpbGRfcnVucyA9IHJ1bi5jaGlsZF9ydW5zLm1hcCgoY2hpbGRfcnVuKSA9PiB0aGlzLl9jb252ZXJ0VG9DcmVhdGUoY2hpbGRfcnVuLCBydW50aW1lRW52LCBleGNsdWRlQ2hpbGRSdW5zKSk7XG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50X3J1bl9pZCA9IHJ1bi5wYXJlbnRfcnVuPy5pZCA/PyBydW4ucGFyZW50X3J1bl9pZDtcbiAgICAgICAgICAgIGNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHJ1bi5pZCxcbiAgICAgICAgICAgIG5hbWU6IHJ1bi5uYW1lLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogcnVuLl9zZXJpYWxpemVkX3N0YXJ0X3RpbWUgPz8gcnVuLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICBlbmRfdGltZTogcnVuLmVuZF90aW1lLFxuICAgICAgICAgICAgcnVuX3R5cGU6IHJ1bi5ydW5fdHlwZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZV9leGFtcGxlX2lkOiBydW4ucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICBleHRyYTogcnVuRXh0cmEsXG4gICAgICAgICAgICBzZXJpYWxpemVkOiBydW4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIGVycm9yOiBydW4uZXJyb3IsXG4gICAgICAgICAgICBpbnB1dHM6IHJ1bi5pbnB1dHMsXG4gICAgICAgICAgICBvdXRwdXRzOiBydW4ub3V0cHV0cyxcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcnVuLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgIGNoaWxkX3J1bnM6IGNoaWxkX3J1bnMsXG4gICAgICAgICAgICBwYXJlbnRfcnVuX2lkOiBwYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIHRhZ3M6IHJ1bi50YWdzLFxuICAgICAgICAgICAgYXR0YWNobWVudHM6IHJ1bi5hdHRhY2htZW50cyxcbiAgICAgICAgICAgIGV2ZW50czogcnVuLmV2ZW50cyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3NsaWNlUGFyZW50SWQocGFyZW50SWQsIHJ1bikge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2xpY2UgdGhlIHBhcmVudCBpZCBmcm9tIGRvdHRlZCBvcmRlci5cbiAgICAgICAgICogQWRkaXRpb25hbGx5IGNoZWNrIGlmIHRoZSBjdXJyZW50IHJ1biBpcyBhIGNoaWxkIG9mIHRoZSBwYXJlbnQuIElmIHNvLCB1cGRhdGVcbiAgICAgICAgICogdGhlIHBhcmVudF9ydW5faWQgdG8gdW5kZWZpbmVkLCBhbmQgc2V0IHRoZSB0cmFjZSBpZCB0byB0aGUgbmV3IHJvb3QgaWQgYWZ0ZXJcbiAgICAgICAgICogcGFyZW50X2lkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJ1bi5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ3MgPSBydW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGxldCBzdGFydElkeCA9IG51bGw7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgcGFyZW50IElEIGluIHRoZSBkb3R0ZWQgb3JkZXJcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlZ3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZ0lkID0gc2Vnc1tpZHhdLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VnSWQgPT09IHBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SWR4ID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnRJZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUcmltIHNlZ21lbnRzIHRvIHN0YXJ0IGFmdGVyIHBhcmVudF9pZCAoZXhjbHVzaXZlKVxuICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRTZWdzID0gc2Vncy5zbGljZShzdGFydElkeCArIDEpO1xuICAgICAgICAgICAgICAgIC8vIFJlYnVpbGQgZG90dGVkX29yZGVyXG4gICAgICAgICAgICAgICAgcnVuLmRvdHRlZF9vcmRlciA9IHRyaW1tZWRTZWdzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0cmltbWVkU2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bi50cmFjZV9pZCA9IHRyaW1tZWRTZWdzWzBdLnNsaWNlKC1USU1FU1RBTVBfTEVOR1RIKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bi50cmFjZV9pZCA9IHJ1bi5pZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bi5wYXJlbnRfcnVuX2lkID09PSBwYXJlbnRJZCkge1xuICAgICAgICAgICAgLy8gV2UndmUgZm91bmQgdGhlIG5ldyByb290IG5vZGUuXG4gICAgICAgICAgICBydW4ucGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2V0UmVwbGljYVRyYWNlUm9vdChyZXBsaWNhS2V5LCB0cmFjZVJvb3RJZCkge1xuICAgICAgICAvLyBTZXQgdGhlIHJlcGxpY2EgdHJhY2Ugcm9vdCBpbiBjb250ZXh0IHZhcnMgb24gdGhpcyBydW4gYW5kIGFsbCBkZXNjZW5kYW50c1xuICAgICAgICBjb25zdCByZXBsaWNhVHJhY2VSb290cyA9IGdldENvbnRleHRWYXIodGhpcywgX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZKSA/PyB7fTtcbiAgICAgICAgcmVwbGljYVRyYWNlUm9vdHNbcmVwbGljYUtleV0gPSB0cmFjZVJvb3RJZDtcbiAgICAgICAgc2V0Q29udGV4dFZhcih0aGlzLCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVksIHJlcGxpY2FUcmFjZVJvb3RzKTtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgdXBkYXRlIGFsbCBkZXNjZW5kYW50cyB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gYXJvdW5kIHJ1biB0cmVlIGNyZWF0aW9uIHZzIHByb2Nlc3NpbmcgdGltZVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgY2hpbGQuX3NldFJlcGxpY2FUcmFjZVJvb3QocmVwbGljYUtleSwgdHJhY2VSb290SWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9yZW1hcEZvclByb2plY3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdE5hbWUsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMgPSB0cnVlLCByZXJvb3QgPSBmYWxzZSwgZGlzdHJpYnV0ZWRQYXJlbnRJZCwgYXBpVXJsLCBhcGlLZXksIHdvcmtzcGFjZUlkLCB9ID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBiYXNlUnVuID0gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHJ1bnRpbWVFbnYsIGV4Y2x1ZGVDaGlsZFJ1bnMpO1xuICAgICAgICAvLyBTa2lwIHJlbWFwcGluZyBpZiBwcm9qZWN0IG5hbWUgaXMgdGhlIHNhbWVcbiAgICAgICAgaWYgKHByb2plY3ROYW1lID09PSB0aGlzLnByb2plY3RfbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlUnVuLFxuICAgICAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGx5IHJlcm9vdCBsb2dpYyBiZWZvcmUgSUQgcmVtYXBwaW5nXG4gICAgICAgIGlmIChyZXJvb3QpIHtcbiAgICAgICAgICAgIGlmIChkaXN0cmlidXRlZFBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGRpc3RyaWJ1dGVkIHBhcmVudCBJRCwgc2xpY2UgYXQgdGhhdCBwb2ludFxuICAgICAgICAgICAgICAgIHRoaXMuX3NsaWNlUGFyZW50SWQoZGlzdHJpYnV0ZWRQYXJlbnRJZCwgYmFzZVJ1bik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBkaXN0cmlidXRlZCBwYXJlbnQgSUQsIHNpbXBseSBtYWtlIHRoaXMgcnVuIGEgcm9vdCBydW5cbiAgICAgICAgICAgICAgICAvLyBieSByZW1vdmluZyBwYXJlbnRfcnVuX2lkIGFuZCByZXNldHRpbmcgdHJhY2UgaW5mb1xuICAgICAgICAgICAgICAgIGJhc2VSdW4ucGFyZW50X3J1bl9pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHRoZSBjdXJyZW50IHJ1biBhcyB0aGUgdHJhY2Ugcm9vdFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUnVuLmRvdHRlZF9vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBkb3R0ZWQgb3JkZXIgdG8ganVzdCB0aGlzIHJ1blxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWdzID0gYmFzZVJ1bi5kb3R0ZWRfb3JkZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUnVuLmRvdHRlZF9vcmRlciA9IHNlZ3Nbc2Vncy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VSdW4udHJhY2VfaWQgPSBiYXNlUnVuLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RvcmUgdGhpcyBydW4ncyBvcmlnaW5hbCBJRCBpbiBjb250ZXh0IHZhcnMgc28gZGVzY2VuZGFudHMga25vdyB0aGUgbmV3IHRyYWNlIHJvb3RcbiAgICAgICAgICAgIC8vIFdlIHN0b3JlIHRoZSBvcmlnaW5hbCBJRCAoYmVmb3JlIHJlbWFwcGluZykgc28gaXQgY2FuIGJlIGZvdW5kIGluIGRvdHRlZF9vcmRlclxuICAgICAgICAgICAgY29uc3QgcmVwbGljYUtleSA9IGdldFJlcGxpY2FLZXkoe1xuICAgICAgICAgICAgICAgIHByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3NldFJlcGxpY2FUcmFjZVJvb3QocmVwbGljYUtleSwgYmFzZVJ1bi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gYW5jZXN0b3Igd2FzIHJlcm9vdGVkIGZvciB0aGlzIHJlcGxpY2EsIHVwZGF0ZSB0cmFjZV9pZCBhbmQgZG90dGVkX29yZGVyXG4gICAgICAgIC8vIHRvIHJlZmxlY3QgdGhlIG5ldyB0cmFjZSBoaWVyYXJjaHkuIFRoaXMgaXMgdHJhY2tlZCB2aWEgY29udGV4dCB2YXJpYWJsZXMuXG4gICAgICAgIGxldCBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZDtcbiAgICAgICAgaWYgKCFyZXJvb3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FUcmFjZVJvb3RzID0gZ2V0Q29udGV4dFZhcih0aGlzLCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVkpID8/IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVwbGljYUtleSA9IGdldFJlcGxpY2FLZXkoe1xuICAgICAgICAgICAgICAgIHByb2plY3ROYW1lLFxuICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFuY2VzdG9yUmVyb290ZWRUcmFjZUlkID0gcmVwbGljYVRyYWNlUm9vdHNbcmVwbGljYUtleV07XG4gICAgICAgICAgICBpZiAoYW5jZXN0b3JSZXJvb3RlZFRyYWNlSWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBbiBhbmNlc3RvciB3YXMgcmVyb290ZWQgZm9yIHRoaXMgcmVwbGljYSwgc28gc2V0IG91ciB0cmFjZV9pZFxuICAgICAgICAgICAgICAgIC8vIHRvIHRoZSBhbmNlc3RvcidzIG9yaWdpbmFsICh1bm1hcHBlZCkgSUQuIEl0IHdpbGwgYmUgcmVtYXBwZWQgYWxvbmcgd2l0aCBvdGhlciBJRHMuXG4gICAgICAgICAgICAgICAgYmFzZVJ1bi50cmFjZV9pZCA9IGFuY2VzdG9yUmVyb290ZWRUcmFjZUlkO1xuICAgICAgICAgICAgICAgIC8vIEFsc28gc2xpY2UgdGhlIGRvdHRlZF9vcmRlciB0byBzdGFydCBmcm9tIHRoZSBuZXcgdHJhY2Ugcm9vdFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBkZXNjZW5kYW50cyBvZiBhIHJlcm9vdGVkIGFuY2VzdG9yIGhhdmUgY29ycmVjdCBoaWVyYXJjaHlcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVJ1bi5kb3R0ZWRfb3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VncyA9IGJhc2VSdW4uZG90dGVkX29yZGVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvb3RJZHggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBuZXcgdHJhY2Ugcm9vdCdzIHNlZ21lbnQgaW4gZG90dGVkX29yZGVyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlZ3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VnSWQgPSBzZWdzW2lkeF0uc2xpY2UoLVRJTUVTVEFNUF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ0lkID09PSBhbmNlc3RvclJlcm9vdGVkVHJhY2VJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJZHggPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvb3RJZHggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgc2VnbWVudHMgZnJvbSBuZXcgdHJhY2Ugcm9vdCBvbndhcmRzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkU2VncyA9IHNlZ3Muc2xpY2Uocm9vdElkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlUnVuLmRvdHRlZF9vcmRlciA9IHRyaW1tZWRTZWdzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbWFwIElEcyBmb3IgdGhlIHJlcGxpY2EgdXNpbmcgdXVpZDUgKGRldGVybWluaXN0aWMpXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBjb25zaXN0ZW5jeSBhY3Jvc3MgcnVucyBpbiB0aGUgc2FtZSByZXBsaWNhXG4gICAgICAgIGNvbnN0IG9sZElkID0gYmFzZVJ1bi5pZDtcbiAgICAgICAgY29uc3QgbmV3SWQgPSB1dWlkdjUoYCR7b2xkSWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgLy8gUmVtYXAgdHJhY2VfaWRcbiAgICAgICAgbGV0IG5ld1RyYWNlSWQ7XG4gICAgICAgIGlmIChiYXNlUnVuLnRyYWNlX2lkKSB7XG4gICAgICAgICAgICBuZXdUcmFjZUlkID0gdXVpZHY1KGAke2Jhc2VSdW4udHJhY2VfaWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RyYWNlSWQgPSBuZXdJZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1hcCBwYXJlbnRfcnVuX2lkXG4gICAgICAgIGxldCBuZXdQYXJlbnRJZDtcbiAgICAgICAgaWYgKGJhc2VSdW4ucGFyZW50X3J1bl9pZCkge1xuICAgICAgICAgICAgbmV3UGFyZW50SWQgPSB1dWlkdjUoYCR7YmFzZVJ1bi5wYXJlbnRfcnVuX2lkfToke3Byb2plY3ROYW1lfWAsIFVVSURfTkFNRVNQQUNFX0ROUyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtYXAgZG90dGVkX29yZGVyIHNlZ21lbnRzXG4gICAgICAgIGxldCBuZXdEb3R0ZWRPcmRlcjtcbiAgICAgICAgaWYgKGJhc2VSdW4uZG90dGVkX29yZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBzZWdzID0gYmFzZVJ1bi5kb3R0ZWRfb3JkZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgY29uc3QgcmVtYXBwZWRTZWdzID0gc2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIFVVSUQgZnJvbSB0aGUgc2VnbWVudCAobGFzdCBUSU1FU1RBTVBfTEVOR1RIIGNoYXJhY3RlcnMpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnSWQgPSBzZWcuc2xpY2UoLVRJTUVTVEFNUF9MRU5HVEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFwcGVkSWQgPSB1dWlkdjUoYCR7c2VnSWR9OiR7cHJvamVjdE5hbWV9YCwgVVVJRF9OQU1FU1BBQ0VfRE5TKTtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBVVUlEIHBhcnQgd2hpbGUga2VlcGluZyB0aGUgdGltZXN0YW1wIHByZWZpeFxuICAgICAgICAgICAgICAgIHJldHVybiBzZWcuc2xpY2UoMCwgLVRJTUVTVEFNUF9MRU5HVEgpICsgcmVtYXBwZWRJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3RG90dGVkT3JkZXIgPSByZW1hcHBlZFNlZ3Muam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmJhc2VSdW4sXG4gICAgICAgICAgICBpZDogbmV3SWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogbmV3VHJhY2VJZCxcbiAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IG5ld1BhcmVudElkLFxuICAgICAgICAgICAgZG90dGVkX29yZGVyOiBuZXdEb3R0ZWRPcmRlcixcbiAgICAgICAgICAgIHNlc3Npb25fbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHBvc3RSdW4oZXhjbHVkZUNoaWxkUnVucyA9IHRydWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bnRpbWVFbnYgPSBnZXRSdW50aW1lRW52aXJvbm1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcGxpY2FzICYmIHRoaXMucmVwbGljYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBwcm9qZWN0TmFtZSwgYXBpS2V5LCBhcGlVcmwsIHdvcmtzcGFjZUlkLCByZXJvb3QgfSBvZiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsaWNhcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLl9yZW1hcEZvclByb2plY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IHByb2plY3ROYW1lID8/IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZUVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVDaGlsZFJ1bnM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0cmlidXRlZFBhcmVudElkOiB0aGlzLmRpc3RyaWJ1dGVkUGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jrc3BhY2VJZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50LmNyZWF0ZVJ1bihydW5DcmVhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBydW5DcmVhdGUgPSB0aGlzLl9jb252ZXJ0VG9DcmVhdGUodGhpcywgcnVudGltZUVudiwgZXhjbHVkZUNoaWxkUnVucyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQuY3JlYXRlUnVuKHJ1bkNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWV4Y2x1ZGVDaGlsZFJ1bnMpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShcIlBvc3Rpbmcgd2l0aCBleGNsdWRlQ2hpbGRSdW5zPWZhbHNlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkUnVuIG9mIHRoaXMuY2hpbGRfcnVucykge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjaGlsZFJ1bi5wb3N0UnVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoaWxkX3J1bnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBvc3RSdW4gZm9yIHJ1biAke3RoaXMuaWR9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXRjaFJ1bihvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcGxpY2FzICYmIHRoaXMucmVwbGljYXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB7IHByb2plY3ROYW1lLCBhcGlLZXksIGFwaVVybCwgd29ya3NwYWNlSWQsIHVwZGF0ZXMsIHJlcm9vdCwgfSBvZiB0aGlzLnJlcGxpY2FzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuRGF0YSA9IHRoaXMuX3JlbWFwRm9yUHJvamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiBwcm9qZWN0TmFtZSA/PyB0aGlzLnByb2plY3RfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZUVudjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlQ2hpbGRSdW5zOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICByZXJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RyaWJ1dGVkUGFyZW50SWQ6IHRoaXMuZGlzdHJpYnV0ZWRQYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYXBpVXJsLFxuICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBydW5EYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBydW5EYXRhLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJ1bl90eXBlOiBydW5EYXRhLnJ1bl90eXBlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydF90aW1lOiBydW5EYXRhLnN0YXJ0X3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dHM6IHJ1bkRhdGEub3V0cHV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJ1bkRhdGEuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHJ1bkRhdGEucGFyZW50X3J1bl9pZCxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbl9uYW1lOiBydW5EYXRhLnNlc3Npb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlX2V4YW1wbGVfaWQ6IHJ1bkRhdGEucmVmZXJlbmNlX2V4YW1wbGVfaWQsXG4gICAgICAgICAgICAgICAgICAgIGVuZF90aW1lOiBydW5EYXRhLmVuZF90aW1lLFxuICAgICAgICAgICAgICAgICAgICBkb3R0ZWRfb3JkZXI6IHJ1bkRhdGEuZG90dGVkX29yZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZV9pZDogcnVuRGF0YS50cmFjZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBydW5EYXRhLmV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogcnVuRGF0YS50YWdzLFxuICAgICAgICAgICAgICAgICAgICBleHRyYTogcnVuRGF0YS5leHRyYSxcbiAgICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IHRoaXMuYXR0YWNobWVudHMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnVwZGF0ZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBJbXBvcnRhbnQgdGhhdCBpbnB1dHMgaXMgbm90IGEga2V5IGluIHRoZSBydW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gaWYgZXhjbHVkZWQgYmVjYXVzZSBpdCB3aWxsIG92ZXJ3cml0ZSB0aGUgcnVuIGNyZWF0ZSBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyB0d28gb3BlcmF0aW9ucyBhcmUgbWVyZ2VkIGR1cmluZyBiYXRjaGluZ1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucz8uZXhjbHVkZUlucHV0cykge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVQYXlsb2FkLmlucHV0cyA9IHJ1bkRhdGEuaW5wdXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4ocnVuRGF0YS5pZCwgdXBkYXRlUGF5bG9hZCwge1xuICAgICAgICAgICAgICAgICAgICBhcGlLZXksXG4gICAgICAgICAgICAgICAgICAgIGFwaVVybCxcbiAgICAgICAgICAgICAgICAgICAgd29ya3NwYWNlSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1blVwZGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBydW5fdHlwZTogdGhpcy5ydW5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfdGltZTogdGhpcy5fc2VyaWFsaXplZF9zdGFydF90aW1lID8/IHRoaXMuc3RhcnRfdGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kX3RpbWU6IHRoaXMuZW5kX3RpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudF9ydW5faWQ6IHRoaXMucGFyZW50X3J1bj8uaWQgPz8gdGhpcy5wYXJlbnRfcnVuX2lkLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VfZXhhbXBsZV9pZDogdGhpcy5yZWZlcmVuY2VfZXhhbXBsZV9pZCxcbiAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHRoaXMuZXh0cmEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogdGhpcy5kb3R0ZWRfb3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIHRyYWNlX2lkOiB0aGlzLnRyYWNlX2lkLFxuICAgICAgICAgICAgICAgICAgICB0YWdzOiB0aGlzLnRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzOiB0aGlzLmF0dGFjaG1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uX25hbWU6IHRoaXMucHJvamVjdF9uYW1lLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0YW50IHRoYXQgaW5wdXRzIGlzIG5vdCBhIGtleSBpbiB0aGUgcnVuIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIGlmIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgd2lsbCBvdmVyd3JpdGUgdGhlIHJ1biBjcmVhdGUgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gdHdvIG9wZXJhdGlvbnMgYXJlIG1lcmdlZCBkdXJpbmcgYmF0Y2hpbmdcbiAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnM/LmV4Y2x1ZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuVXBkYXRlLmlucHV0cyA9IHRoaXMuaW5wdXRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNsaWVudC51cGRhdGVSdW4odGhpcy5pZCwgcnVuVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGluIHBhdGNoUnVuIGZvciBydW4gJHt0aGlzLmlkfWAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkX3J1bnMgPSBbXTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udmVydFRvQ3JlYXRlKHRoaXMsIHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZXZlbnQgdG8gdGhlIHJ1biB0cmVlLlxuICAgICAqIEBwYXJhbSBldmVudCAtIEEgc2luZ2xlIGV2ZW50IG9yIHN0cmluZyB0byBhZGRcbiAgICAgKi9cbiAgICBhZGRFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXZlbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIHRpbWU6IGV2ZW50LnRpbWUgPz8gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21SdW5uYWJsZUNvbmZpZyhwYXJlbnRDb25maWcsIHByb3BzKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgaGFuZGxlIHRoZSBjYWxsYmFjayBtYW5hZ2VyIGNhc2UgZm9yIG5vd1xuICAgICAgICBjb25zdCBjYWxsYmFja01hbmFnZXIgPSBwYXJlbnRDb25maWc/LmNhbGxiYWNrcztcbiAgICAgICAgbGV0IHBhcmVudFJ1bjtcbiAgICAgICAgbGV0IHByb2plY3ROYW1lO1xuICAgICAgICBsZXQgY2xpZW50O1xuICAgICAgICBsZXQgdHJhY2luZ0VuYWJsZWQgPSBpc1RyYWNpbmdFbmFibGVkKCk7XG4gICAgICAgIGlmIChjYWxsYmFja01hbmFnZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFJ1bklkID0gY2FsbGJhY2tNYW5hZ2VyPy5nZXRQYXJlbnRSdW5JZD8uKCkgPz8gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxhbmdDaGFpblRyYWNlciA9IGNhbGxiYWNrTWFuYWdlcj8uaGFuZGxlcnM/LmZpbmQoKGhhbmRsZXIpID0+IGhhbmRsZXI/Lm5hbWUgPT0gXCJsYW5nY2hhaW5fdHJhY2VyXCIpO1xuICAgICAgICAgICAgcGFyZW50UnVuID0gbGFuZ0NoYWluVHJhY2VyPy5nZXRSdW4/LihwYXJlbnRSdW5JZCk7XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA9IGxhbmdDaGFpblRyYWNlcj8ucHJvamVjdE5hbWU7XG4gICAgICAgICAgICBjbGllbnQgPSBsYW5nQ2hhaW5UcmFjZXI/LmNsaWVudDtcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkID0gdHJhY2luZ0VuYWJsZWQgfHwgISFsYW5nQ2hhaW5UcmFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnRSdW4pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVuVHJlZSh7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgICAgIHByb2plY3RfbmFtZTogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRSdW5UcmVlID0gbmV3IFJ1blRyZWUoe1xuICAgICAgICAgICAgbmFtZTogcGFyZW50UnVuLm5hbWUsXG4gICAgICAgICAgICBpZDogcGFyZW50UnVuLmlkLFxuICAgICAgICAgICAgdHJhY2VfaWQ6IHBhcmVudFJ1bi50cmFjZV9pZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcGFyZW50UnVuLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgIHRyYWNpbmdFbmFibGVkLFxuICAgICAgICAgICAgcHJvamVjdF9uYW1lOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgIHRhZ3M6IFtcbiAgICAgICAgICAgICAgICAuLi5uZXcgU2V0KChwYXJlbnRSdW4/LnRhZ3MgPz8gW10pLmNvbmNhdChwYXJlbnRDb25maWc/LnRhZ3MgPz8gW10pKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBleHRyYToge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcmVudFJ1bj8uZXh0cmE/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAuLi5wYXJlbnRDb25maWc/Lm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmVudFJ1blRyZWUuY3JlYXRlQ2hpbGQocHJvcHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbURvdHRlZE9yZGVyKGRvdHRlZE9yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb21IZWFkZXJzKHsgXCJsYW5nc21pdGgtdHJhY2VcIjogZG90dGVkT3JkZXIgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGVhZGVycyhoZWFkZXJzLCBpbmhlcml0QXJncykge1xuICAgICAgICBjb25zdCByYXdIZWFkZXJzID0gXCJnZXRcIiBpbiBoZWFkZXJzICYmIHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBcImxhbmdzbWl0aC10cmFjZVwiOiBoZWFkZXJzLmdldChcImxhbmdzbWl0aC10cmFjZVwiKSxcbiAgICAgICAgICAgICAgICBiYWdnYWdlOiBoZWFkZXJzLmdldChcImJhZ2dhZ2VcIiksXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IGhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGhlYWRlclRyYWNlID0gcmF3SGVhZGVyc1tcImxhbmdzbWl0aC10cmFjZVwiXTtcbiAgICAgICAgaWYgKCFoZWFkZXJUcmFjZSB8fCB0eXBlb2YgaGVhZGVyVHJhY2UgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYXJlbnREb3R0ZWRPcmRlciA9IGhlYWRlclRyYWNlLnRyaW0oKTtcbiAgICAgICAgY29uc3QgcGFyc2VkRG90dGVkT3JkZXIgPSBwYXJlbnREb3R0ZWRPcmRlci5zcGxpdChcIi5cIikubWFwKChwYXJ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbc3RyVGltZSwgdXVpZF0gPSBwYXJ0LnNwbGl0KFwiWlwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHN0clRpbWUsIHRpbWU6IERhdGUucGFyc2Uoc3RyVGltZSArIFwiWlwiKSwgdXVpZCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHJhY2VJZCA9IHBhcnNlZERvdHRlZE9yZGVyWzBdLnV1aWQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmluaGVyaXRBcmdzLFxuICAgICAgICAgICAgbmFtZTogaW5oZXJpdEFyZ3M/LltcIm5hbWVcIl0gPz8gXCJwYXJlbnRcIixcbiAgICAgICAgICAgIHJ1bl90eXBlOiBpbmhlcml0QXJncz8uW1wicnVuX3R5cGVcIl0gPz8gXCJjaGFpblwiLFxuICAgICAgICAgICAgc3RhcnRfdGltZTogaW5oZXJpdEFyZ3M/LltcInN0YXJ0X3RpbWVcIl0gPz8gRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGlkOiBwYXJzZWREb3R0ZWRPcmRlci5hdCgtMSk/LnV1aWQsXG4gICAgICAgICAgICB0cmFjZV9pZDogdHJhY2VJZCxcbiAgICAgICAgICAgIGRvdHRlZF9vcmRlcjogcGFyZW50RG90dGVkT3JkZXIsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyYXdIZWFkZXJzW1wiYmFnZ2FnZVwiXSAmJiB0eXBlb2YgcmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhZ2dhZ2UgPSBCYWdnYWdlLmZyb21IZWFkZXIocmF3SGVhZGVyc1tcImJhZ2dhZ2VcIl0pO1xuICAgICAgICAgICAgY29uZmlnLm1ldGFkYXRhID0gYmFnZ2FnZS5tZXRhZGF0YTtcbiAgICAgICAgICAgIGNvbmZpZy50YWdzID0gYmFnZ2FnZS50YWdzO1xuICAgICAgICAgICAgY29uZmlnLnByb2plY3RfbmFtZSA9IGJhZ2dhZ2UucHJvamVjdF9uYW1lO1xuICAgICAgICAgICAgY29uZmlnLnJlcGxpY2FzID0gYmFnZ2FnZS5yZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydW5UcmVlID0gbmV3IFJ1blRyZWUoY29uZmlnKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkaXN0cmlidXRlZCBwYXJlbnQgSUQgdG8gdGhpcyBydW4ncyBJRCBmb3IgcmVyb290aW5nXG4gICAgICAgIHJ1blRyZWUuZGlzdHJpYnV0ZWRQYXJlbnRJZCA9IHJ1blRyZWUuaWQ7XG4gICAgICAgIHJldHVybiBydW5UcmVlO1xuICAgIH1cbiAgICB0b0hlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBcImxhbmdzbWl0aC10cmFjZVwiOiB0aGlzLmRvdHRlZF9vcmRlcixcbiAgICAgICAgICAgIGJhZ2dhZ2U6IG5ldyBCYWdnYWdlKHRoaXMuZXh0cmE/Lm1ldGFkYXRhLCB0aGlzLnRhZ3MsIHRoaXMucHJvamVjdF9uYW1lLCB0aGlzLnJlcGxpY2FzKS50b0hlYWRlcigpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1blRyZWUsIFwic2hhcmVkQ2xpZW50XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogbnVsbFxufSk7XG5leHBvcnQgZnVuY3Rpb24gaXNSdW5UcmVlKHgpIHtcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgeC5jcmVhdGVDaGlsZCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIHR5cGVvZiB4LnBvc3RSdW4gPT09IFwiZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBpc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB4Lm5hbWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgeC5uYW1lID09PSBcImxhbmdjaGFpbl90cmFjZXJcIik7XG59XG5mdW5jdGlvbiBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoeCkge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheSh4KSAmJiB4LnNvbWUoKGNhbGxiYWNrKSA9PiBpc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2spKSk7XG59XG5mdW5jdGlvbiBpc0NhbGxiYWNrTWFuYWdlckxpa2UoeCkge1xuICAgIHJldHVybiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgeCAhPSBudWxsICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeC5oYW5kbGVycykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUnVubmFibGVDb25maWdMaWtlKHgpIHtcbiAgICAvLyBDaGVjayB0aGF0IGl0J3MgYW4gb2JqZWN0IHdpdGggYSBjYWxsYmFja3MgYXJnXG4gICAgLy8gdGhhdCBoYXMgZWl0aGVyIGEgQ2FsbGJhY2tNYW5hZ2VyTGlrZSBvYmplY3Qgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXIgd2l0aGluIGl0XG4gICAgLy8gb3IgYW4gYXJyYXkgd2l0aCBhIExhbmdDaGFpblRyYWNlckxpa2Ugb2JqZWN0IHdpdGhpbiBpdFxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHg/LmNhbGxiYWNrcztcbiAgICByZXR1cm4gKHggIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgY2FsbGJhY2tzID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIC8vIENhbGxiYWNrIG1hbmFnZXIgd2l0aCBhIGxhbmdjaGFpbiB0cmFjZXJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgKGNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZShjYWxsYmFja3M/LmhhbmRsZXJzKSB8fFxuICAgICAgICAgICAgLy8gT3IgaXQncyBhbiBhcnJheSB3aXRoIGEgTGFuZ0NoYWluVHJhY2VyTGlrZSBvYmplY3Qgd2l0aGluIGl0XG4gICAgICAgICAgICBjb250YWluc0xhbmdDaGFpblRyYWNlckxpa2UoY2FsbGJhY2tzKSkpO1xufVxuZnVuY3Rpb24gX2dldFdyaXRlUmVwbGljYXNGcm9tRW52KCkge1xuICAgIGNvbnN0IGVudlZhciA9IGdldEVudmlyb25tZW50VmFyaWFibGUoXCJMQU5HU01JVEhfUlVOU19FTkRQT0lOVFNcIik7XG4gICAgaWYgKCFlbnZWYXIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGVudlZhcik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcGxpY2FzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiIHx8IGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGl0ZW0gdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIG9iamVjdCwgZ290ICR7dHlwZW9mIGl0ZW19YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0uYXBpX3VybCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgYXBpX3VybCB0eXBlIGluIExBTkdTTUlUSF9SVU5TX0VORFBPSU5UUzogYCArXG4gICAgICAgICAgICAgICAgICAgICAgICBgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2YgaXRlbS5hcGlfdXJsfWApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVtLmFwaV9rZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGFwaV9rZXkgdHlwZSBpbiBMQU5HU01JVEhfUlVOU19FTkRQT0lOVFM6IGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIGl0ZW0uYXBpX2tleX1gKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcGxpY2FzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IGl0ZW0uYXBpX3VybC5yZXBsYWNlKC9cXC8kLywgXCJcIiksXG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogaXRlbS5hcGlfa2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcGxpY2FzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJzZWQgPT09IFwib2JqZWN0XCIgJiYgcGFyc2VkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfY2hlY2tFbmRwb2ludEVudlVuc2V0KHBhcnNlZCk7XG4gICAgICAgICAgICBjb25zdCByZXBsaWNhcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbdXJsLCBrZXldIG9mIE9iamVjdC5lbnRyaWVzKHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGljYXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlVcmw6IGNsZWFuVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIHZhbHVlIHR5cGUgaW4gTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIGZvciBVUkwgJHt1cmx9OiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXBsaWNhcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIOKAkyBtdXN0IGJlIHZhbGlkIEpTT04gYXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgICAgIGBvYmplY3RzIHdpdGggYXBpX3VybCBhbmQgYXBpX2tleSBwcm9wZXJ0aWVzLCBvciBvYmplY3QgbWFwcGluZyB1cmwtPmFwaUtleSwgZ290ICR7dHlwZW9mIHBhcnNlZH1gKTtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yKGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTIOKAkyBtdXN0IGJlIHZhbGlkIEpTT04gYXJyYXkgb2YgXCIgK1xuICAgICAgICAgICAgXCJvYmplY3RzIHdpdGggYXBpX3VybCBhbmQgYXBpX2tleSBwcm9wZXJ0aWVzLCBvciBvYmplY3QgbWFwcGluZyB1cmwtPmFwaUtleVwiKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9lbnN1cmVXcml0ZVJlcGxpY2FzKHJlcGxpY2FzKSB7XG4gICAgLy8gSWYgbnVsbCAtPiBmZXRjaCBmcm9tIGVudlxuICAgIGlmIChyZXBsaWNhcykge1xuICAgICAgICByZXR1cm4gcmVwbGljYXMubWFwKChyZXBsaWNhKSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsaWNhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lOiByZXBsaWNhWzBdLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVzOiByZXBsaWNhWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVwbGljYTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfZ2V0V3JpdGVSZXBsaWNhc0Zyb21FbnYoKTtcbn1cbmZ1bmN0aW9uIF9jaGVja0VuZHBvaW50RW52VW5zZXQocGFyc2VkKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoID4gMCAmJlxuICAgICAgICBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiRU5EUE9JTlRcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IoKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiQ2xpZW50IiwiaXNUcmFjaW5nRW5hYmxlZCIsImlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciIsIkNvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IiLCJfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIiwiX1JFUExJQ0FfVFJBQ0VfUk9PVFNfS0VZIiwiZ2V0Q29udGV4dFZhciIsInNldENvbnRleHRWYXIiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0UnVudGltZUVudmlyb25tZW50IiwiZ2V0RGVmYXVsdFByb2plY3ROYW1lIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsIndhcm5PbmNlIiwidXVpZDdGcm9tVGltZSIsInY1IiwidXVpZHY1IiwiVElNRVNUQU1QX0xFTkdUSCIsIlVVSURfTkFNRVNQQUNFX0ROUyIsImdldFJlcGxpY2FLZXkiLCJyZXBsaWNhIiwic29ydGVkS2V5cyIsIk9iamVjdCIsImtleXMiLCJzb3J0Iiwia2V5RGF0YSIsIm1hcCIsImtleSIsImpvaW4iLCJzdHJpcE5vbkFscGhhbnVtZXJpYyIsImlucHV0IiwicmVwbGFjZSIsImdldE1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyIsImVwb2NoIiwiZXhlY3V0aW9uT3JkZXIiLCJwYWRkZWRPcmRlciIsInRvRml4ZWQiLCJzbGljZSIsInBhZFN0YXJ0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29udmVydFRvRG90dGVkT3JkZXJGb3JtYXQiLCJydW5JZCIsIm1pY3Jvc2Vjb25kUHJlY2lzaW9uRGF0ZXN0cmluZyIsImRvdHRlZE9yZGVyIiwiQmFnZ2FnZSIsImNvbnN0cnVjdG9yIiwibWV0YWRhdGEiLCJ0YWdzIiwicHJvamVjdF9uYW1lIiwicmVwbGljYXMiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiZnJvbUhlYWRlciIsIml0ZW1zIiwic3BsaXQiLCJpdGVtIiwidXJpVmFsdWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJKU09OIiwicGFyc2UiLCJ0b0hlYWRlciIsImxlbmd0aCIsInB1c2giLCJlbmNvZGVVUklDb21wb25lbnQiLCJzdHJpbmdpZnkiLCJSdW5UcmVlIiwib3JpZ2luYWxDb25maWciLCJpc1J1blRyZWUiLCJhc3NpZ24iLCJkZWZhdWx0Q29uZmlnIiwiZ2V0RGVmYXVsdENvbmZpZyIsImNvbmZpZyIsImNsaWVudCIsImdldFNoYXJlZENsaWVudCIsImRlZHVwZWRNZXRhZGF0YSIsImV4dHJhIiwiaWQiLCJleGVjdXRpb25fb3JkZXIiLCJjaGlsZF9leGVjdXRpb25fb3JkZXIiLCJkb3R0ZWRfb3JkZXIiLCJfc2VyaWFsaXplZF9zdGFydF90aW1lIiwic3RhcnRfdGltZSIsInRyYWNlX2lkIiwicGFyZW50X3J1biIsIl9lbnN1cmVXcml0ZVJlcGxpY2FzIiwibm93IiwicnVuX3R5cGUiLCJjaGlsZF9ydW5zIiwiYXBpX3VybCIsImFwaV9rZXkiLCJjYWxsZXJfb3B0aW9ucyIsInNlcmlhbGl6ZWQiLCJpbnB1dHMiLCJzaGFyZWRDbGllbnQiLCJjcmVhdGVDaGlsZCIsImluaGVyaXRlZFJlcGxpY2FzIiwicmVyb290IiwicmVzdCIsImNoaWxkUmVwbGljYXMiLCJjaGlsZCIsInRyYWNpbmdFbmFibGVkIiwiTENfQ0hJTEQiLCJTeW1ib2wiLCJmb3IiLCJwcmVzZW50Q29uZmlnIiwiaXNSdW5uYWJsZUNvbmZpZ0xpa2UiLCJuZXdDb25maWciLCJjYWxsYmFja3MiLCJpc0NhbGxiYWNrTWFuYWdlckxpa2UiLCJjb3B5IiwidW5kZWZpbmVkIiwiX3BhcmVudFJ1bklkIiwiaGFuZGxlcnMiLCJmaW5kIiwiaXNMYW5nQ2hhaW5UcmFjZXJMaWtlIiwidXBkYXRlRnJvbVJ1blRyZWUiLCJ2aXNpdGVkIiwiU2V0IiwiY3VycmVudCIsImhhcyIsImFkZCIsIk1hdGgiLCJtYXgiLCJlbmQiLCJvdXRwdXRzIiwiZXJyb3IiLCJlbmRUaW1lIiwiZW5kX3RpbWUiLCJfY29udmVydFRvQ3JlYXRlIiwicnVuIiwicnVudGltZUVudiIsImV4Y2x1ZGVDaGlsZFJ1bnMiLCJydW5FeHRyYSIsInJ1bnRpbWUiLCJsaWJyYXJ5IiwiayIsInYiLCJlbnRyaWVzIiwicGFyZW50X3J1bl9pZCIsImNoaWxkX3J1biIsIm5hbWUiLCJyZWZlcmVuY2VfZXhhbXBsZV9pZCIsInNlc3Npb25fbmFtZSIsImF0dGFjaG1lbnRzIiwiZXZlbnRzIiwiX3NsaWNlUGFyZW50SWQiLCJwYXJlbnRJZCIsInNlZ3MiLCJzdGFydElkeCIsImlkeCIsInNlZ0lkIiwidHJpbW1lZFNlZ3MiLCJfc2V0UmVwbGljYVRyYWNlUm9vdCIsInJlcGxpY2FLZXkiLCJ0cmFjZVJvb3RJZCIsInJlcGxpY2FUcmFjZVJvb3RzIiwiX3JlbWFwRm9yUHJvamVjdCIsInBhcmFtcyIsInByb2plY3ROYW1lIiwiZGlzdHJpYnV0ZWRQYXJlbnRJZCIsImFwaVVybCIsImFwaUtleSIsIndvcmtzcGFjZUlkIiwiYmFzZVJ1biIsImFuY2VzdG9yUmVyb290ZWRUcmFjZUlkIiwicm9vdElkeCIsIm9sZElkIiwibmV3SWQiLCJuZXdUcmFjZUlkIiwibmV3UGFyZW50SWQiLCJuZXdEb3R0ZWRPcmRlciIsInJlbWFwcGVkU2VncyIsInNlZyIsInJlbWFwcGVkSWQiLCJwb3N0UnVuIiwicnVuQ3JlYXRlIiwiY3JlYXRlUnVuIiwiY2hpbGRSdW4iLCJjb25zb2xlIiwicGF0Y2hSdW4iLCJvcHRpb25zIiwidXBkYXRlcyIsInJ1bkRhdGEiLCJ1cGRhdGVQYXlsb2FkIiwiZXhjbHVkZUlucHV0cyIsInVwZGF0ZVJ1biIsInJ1blVwZGF0ZSIsInRvSlNPTiIsImFkZEV2ZW50IiwiZXZlbnQiLCJ0aW1lIiwibWVzc2FnZSIsImZyb21SdW5uYWJsZUNvbmZpZyIsInBhcmVudENvbmZpZyIsInByb3BzIiwiY2FsbGJhY2tNYW5hZ2VyIiwicGFyZW50UnVuIiwicGFyZW50UnVuSWQiLCJnZXRQYXJlbnRSdW5JZCIsImxhbmdDaGFpblRyYWNlciIsImhhbmRsZXIiLCJnZXRSdW4iLCJwYXJlbnRSdW5UcmVlIiwiY29uY2F0IiwiZnJvbURvdHRlZE9yZGVyIiwiZnJvbUhlYWRlcnMiLCJoZWFkZXJzIiwiaW5oZXJpdEFyZ3MiLCJyYXdIZWFkZXJzIiwiZ2V0IiwiYmFnZ2FnZSIsImhlYWRlclRyYWNlIiwicGFyZW50RG90dGVkT3JkZXIiLCJ0cmltIiwicGFyc2VkRG90dGVkT3JkZXIiLCJwYXJ0Iiwic3RyVGltZSIsInV1aWQiLCJ0cmFjZUlkIiwiYXQiLCJydW5UcmVlIiwidG9IZWFkZXJzIiwicmVzdWx0Iiwic2V0IiwieCIsImNvbnRhaW5zTGFuZ0NoYWluVHJhY2VyTGlrZSIsIkFycmF5IiwiaXNBcnJheSIsInNvbWUiLCJjYWxsYmFjayIsIl9nZXRXcml0ZVJlcGxpY2FzRnJvbUVudiIsImVudlZhciIsInBhcnNlZCIsIndhcm4iLCJfY2hlY2tFbmRwb2ludEVudlVuc2V0IiwidXJsIiwiY2xlYW5VcmwiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _LC_CHILD_RUN_END_PROMISES_KEY: () => (/* binding */ _LC_CHILD_RUN_END_PROMISES_KEY),\n/* harmony export */   _LC_CONTEXT_VARIABLES_KEY: () => (/* binding */ _LC_CONTEXT_VARIABLES_KEY),\n/* harmony export */   _REPLICA_TRACE_ROOTS_KEY: () => (/* binding */ _REPLICA_TRACE_ROOTS_KEY)\n/* harmony export */ });\nconst _LC_CONTEXT_VARIABLES_KEY = Symbol.for(\"lc:context_variables\");\nconst _LC_CHILD_RUN_END_PROMISES_KEY = Symbol.for(\"lc:child_run_end_promises\");\nconst _REPLICA_TRACE_ROOTS_KEY = Symbol.for(\"langsmith:replica_trace_roots\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sTUFBTUEsNEJBQTRCQyxPQUFPQyxHQUFHLENBQUMsd0JBQXdCO0FBQ3JFLE1BQU1DLGlDQUFpQ0YsT0FBT0MsR0FBRyxDQUFDLDZCQUE2QjtBQUMvRSxNQUFNRSwyQkFBMkJILE9BQU9DLEdBQUcsQ0FBQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9jb25zdGFudHMuanM/MWRhNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSA9IFN5bWJvbC5mb3IoXCJsYzpjb250ZXh0X3ZhcmlhYmxlc1wiKTtcbmV4cG9ydCBjb25zdCBfTENfQ0hJTERfUlVOX0VORF9QUk9NSVNFU19LRVkgPSBTeW1ib2wuZm9yKFwibGM6Y2hpbGRfcnVuX2VuZF9wcm9taXNlc1wiKTtcbmV4cG9ydCBjb25zdCBfUkVQTElDQV9UUkFDRV9ST09UU19LRVkgPSBTeW1ib2wuZm9yKFwibGFuZ3NtaXRoOnJlcGxpY2FfdHJhY2Vfcm9vdHNcIik7XG4iXSwibmFtZXMiOlsiX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSIsIlN5bWJvbCIsImZvciIsIl9MQ19DSElMRF9SVU5fRU5EX1BST01JU0VTX0tFWSIsIl9SRVBMSUNBX1RSQUNFX1JPT1RTX0tFWSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/fetch.js":
/*!*********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/fetch.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getFetchImplementation: () => (/* binding */ _getFetchImplementation),\n/* harmony export */   _globalFetchImplementationIsNodeFetch: () => (/* binding */ _globalFetchImplementationIsNodeFetch),\n/* harmony export */   clearFetchImplementation: () => (/* binding */ clearFetchImplementation),\n/* harmony export */   overrideFetchImplementation: () => (/* binding */ overrideFetchImplementation)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\n// Wrap the default fetch call due to issues with illegal invocations\n// in some environments:\n// https://stackoverflow.com/questions/69876859/why-does-bind-fix-failed-to-execute-fetch-on-window-illegal-invocation-err\n// @ts-expect-error Broad typing to support a range of fetch implementations\nconst DEFAULT_FETCH_IMPLEMENTATION = (...args)=>fetch(...args);\nconst LANGSMITH_FETCH_IMPLEMENTATION_KEY = Symbol.for(\"ls:fetch_implementation\");\n/**\n * Overrides the fetch implementation used for LangSmith calls.\n * You should use this if you need to use an implementation of fetch\n * other than the default global (e.g. for dealing with proxies).\n * @param fetch The new fetch functino to use.\n */ const overrideFetchImplementation = (fetch1)=>{\n    globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] = fetch1;\n};\nconst clearFetchImplementation = ()=>{\n    delete globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n};\nconst _globalFetchImplementationIsNodeFetch = ()=>{\n    const fetchImpl = globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY];\n    if (!fetchImpl) return false;\n    // Check if the implementation has node-fetch specific properties\n    return typeof fetchImpl === \"function\" && \"Headers\" in fetchImpl && \"Request\" in fetchImpl && \"Response\" in fetchImpl;\n};\n/**\n * @internal\n */ const _getFetchImplementation = (debug)=>{\n    return async (...args)=>{\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            const [url, options] = args;\n            console.log(` ${options?.method || \"GET\"} ${url}`);\n        }\n        const res = await (globalThis[LANGSMITH_FETCH_IMPLEMENTATION_KEY] ?? DEFAULT_FETCH_IMPLEMENTATION)(...args);\n        if (debug || (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"DEBUG\") === \"true\") {\n            console.log(` ${res.status} ${res.statusText} ${res.url}`);\n        }\n        return res;\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFrRTtBQUNsRSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLDBIQUEwSDtBQUMxSCw0RUFBNEU7QUFDNUUsTUFBTUMsK0JBQStCLENBQUMsR0FBR0MsT0FBU0MsU0FBU0Q7QUFDM0QsTUFBTUUscUNBQXFDQyxPQUFPQyxHQUFHLENBQUM7QUFDdEQ7Ozs7O0NBS0MsR0FDTSxNQUFNQyw4QkFBOEIsQ0FBQ0o7SUFDeENLLFVBQVUsQ0FBQ0osbUNBQW1DLEdBQUdEO0FBQ3JELEVBQUU7QUFDSyxNQUFNTSwyQkFBMkI7SUFDcEMsT0FBT0QsVUFBVSxDQUFDSixtQ0FBbUM7QUFDekQsRUFBRTtBQUNLLE1BQU1NLHdDQUF3QztJQUNqRCxNQUFNQyxZQUFZSCxVQUFVLENBQUNKLG1DQUFtQztJQUNoRSxJQUFJLENBQUNPLFdBQ0QsT0FBTztJQUNYLGlFQUFpRTtJQUNqRSxPQUFRLE9BQU9BLGNBQWMsY0FDekIsYUFBYUEsYUFDYixhQUFhQSxhQUNiLGNBQWNBO0FBQ3RCLEVBQUU7QUFDRjs7Q0FFQyxHQUNNLE1BQU1DLDBCQUEwQixDQUFDQztJQUNwQyxPQUFPLE9BQU8sR0FBR1g7UUFDYixJQUFJVyxTQUFTYiw4RUFBK0JBLENBQUMsYUFBYSxRQUFRO1lBQzlELE1BQU0sQ0FBQ2MsS0FBS0MsUUFBUSxHQUFHYjtZQUN2QmMsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFRixTQUFTRyxVQUFVLE1BQU0sQ0FBQyxFQUFFSixJQUFJLENBQUM7UUFDdEQ7UUFDQSxNQUFNSyxNQUFNLE1BQU0sQ0FBQ1gsVUFBVSxDQUFDSixtQ0FBbUMsSUFDN0RILDRCQUEyQixLQUFNQztRQUNyQyxJQUFJVyxTQUFTYiw4RUFBK0JBLENBQUMsYUFBYSxRQUFRO1lBQzlEZ0IsUUFBUUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFRSxJQUFJQyxNQUFNLENBQUMsQ0FBQyxFQUFFRCxJQUFJRSxVQUFVLENBQUMsQ0FBQyxFQUFFRixJQUFJTCxHQUFHLENBQUMsQ0FBQztRQUM5RDtRQUNBLE9BQU9LO0lBQ1g7QUFDSixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvZmV0Y2guanM/NzYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uL3V0aWxzL2Vudi5qc1wiO1xuLy8gV3JhcCB0aGUgZGVmYXVsdCBmZXRjaCBjYWxsIGR1ZSB0byBpc3N1ZXMgd2l0aCBpbGxlZ2FsIGludm9jYXRpb25zXG4vLyBpbiBzb21lIGVudmlyb25tZW50czpcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY5ODc2ODU5L3doeS1kb2VzLWJpbmQtZml4LWZhaWxlZC10by1leGVjdXRlLWZldGNoLW9uLXdpbmRvdy1pbGxlZ2FsLWludm9jYXRpb24tZXJyXG4vLyBAdHMtZXhwZWN0LWVycm9yIEJyb2FkIHR5cGluZyB0byBzdXBwb3J0IGEgcmFuZ2Ugb2YgZmV0Y2ggaW1wbGVtZW50YXRpb25zXG5jb25zdCBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OID0gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xuY29uc3QgTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpmZXRjaF9pbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogT3ZlcnJpZGVzIHRoZSBmZXRjaCBpbXBsZW1lbnRhdGlvbiB1c2VkIGZvciBMYW5nU21pdGggY2FsbHMuXG4gKiBZb3Ugc2hvdWxkIHVzZSB0aGlzIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiBmZXRjaFxuICogb3RoZXIgdGhhbiB0aGUgZGVmYXVsdCBnbG9iYWwgKGUuZy4gZm9yIGRlYWxpbmcgd2l0aCBwcm94aWVzKS5cbiAqIEBwYXJhbSBmZXRjaCBUaGUgbmV3IGZldGNoIGZ1bmN0aW5vIHRvIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IG92ZXJyaWRlRmV0Y2hJbXBsZW1lbnRhdGlvbiA9IChmZXRjaCkgPT4ge1xuICAgIGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV0gPSBmZXRjaDtcbn07XG5leHBvcnQgY29uc3QgY2xlYXJGZXRjaEltcGxlbWVudGF0aW9uID0gKCkgPT4ge1xuICAgIGRlbGV0ZSBnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldO1xufTtcbmV4cG9ydCBjb25zdCBfZ2xvYmFsRmV0Y2hJbXBsZW1lbnRhdGlvbklzTm9kZUZldGNoID0gKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoSW1wbCA9IGdsb2JhbFRoaXNbTEFOR1NNSVRIX0ZFVENIX0lNUExFTUVOVEFUSU9OX0tFWV07XG4gICAgaWYgKCFmZXRjaEltcGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB0aGUgaW1wbGVtZW50YXRpb24gaGFzIG5vZGUtZmV0Y2ggc3BlY2lmaWMgcHJvcGVydGllc1xuICAgIHJldHVybiAodHlwZW9mIGZldGNoSW1wbCA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIFwiSGVhZGVyc1wiIGluIGZldGNoSW1wbCAmJlxuICAgICAgICBcIlJlcXVlc3RcIiBpbiBmZXRjaEltcGwgJiZcbiAgICAgICAgXCJSZXNwb25zZVwiIGluIGZldGNoSW1wbCk7XG59O1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IF9nZXRGZXRjaEltcGxlbWVudGF0aW9uID0gKGRlYnVnKSA9PiB7XG4gICAgcmV0dXJuIGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChkZWJ1ZyB8fCBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKFwiREVCVUdcIikgPT09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICBjb25zdCBbdXJsLCBvcHRpb25zXSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4oaSICR7b3B0aW9ucz8ubWV0aG9kIHx8IFwiR0VUXCJ9ICR7dXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IChnbG9iYWxUaGlzW0xBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVldID8/XG4gICAgICAgICAgICBERUZBVUxUX0ZFVENIX0lNUExFTUVOVEFUSU9OKSguLi5hcmdzKTtcbiAgICAgICAgaWYgKGRlYnVnIHx8IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJERUJVR1wiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDihpAgJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAke3Jlcy51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufTtcbiJdLCJuYW1lcyI6WyJnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIiwiREVGQVVMVF9GRVRDSF9JTVBMRU1FTlRBVElPTiIsImFyZ3MiLCJmZXRjaCIsIkxBTkdTTUlUSF9GRVRDSF9JTVBMRU1FTlRBVElPTl9LRVkiLCJTeW1ib2wiLCJmb3IiLCJvdmVycmlkZUZldGNoSW1wbGVtZW50YXRpb24iLCJnbG9iYWxUaGlzIiwiY2xlYXJGZXRjaEltcGxlbWVudGF0aW9uIiwiX2dsb2JhbEZldGNoSW1wbGVtZW50YXRpb25Jc05vZGVGZXRjaCIsImZldGNoSW1wbCIsIl9nZXRGZXRjaEltcGxlbWVudGF0aW9uIiwiZGVidWciLCJ1cmwiLCJvcHRpb25zIiwiY29uc29sZSIsImxvZyIsIm1ldGhvZCIsInJlcyIsInN0YXR1cyIsInN0YXR1c1RleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/otel.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/otel.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OTELProviderSingleton: () => (/* binding */ OTELProviderSingleton),\n/* harmony export */   getDefaultOTLPTracerComponents: () => (/* binding */ getDefaultOTLPTracerComponents),\n/* harmony export */   getOTELContext: () => (/* binding */ getOTELContext),\n/* harmony export */   getOTELTrace: () => (/* binding */ getOTELTrace),\n/* harmony export */   setDefaultOTLPTracerComponents: () => (/* binding */ setDefaultOTLPTracerComponents),\n/* harmony export */   setOTELInstances: () => (/* binding */ setOTELInstances)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n// Should not import any OTEL packages to avoid pulling in optional deps.\n\nclass MockTracer {\n    constructor(){\n        Object.defineProperty(this, \"hasWarned\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n    }\n    startActiveSpan(_name, ...args) {\n        if (!this.hasWarned && (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getOtelEnabled)()) {\n            console.warn(\"You have enabled OTEL export via the `OTEL_ENABLED` or `LANGSMITH_OTEL_ENABLED` environment variable, but have not initialized the required OTEL instances. \" + 'Please add:\\n```\\nimport { initializeOTEL } from \"langsmith/experimental/otel/setup\";\\ninitializeOTEL();\\n```\\nat the beginning of your code.');\n            this.hasWarned = true;\n        }\n        // Handle different overloads:\n        // startActiveSpan(name, fn)\n        // startActiveSpan(name, options, fn)\n        // startActiveSpan(name, options, context, fn)\n        let fn;\n        if (args.length === 1 && typeof args[0] === \"function\") {\n            fn = args[0];\n        } else if (args.length === 2 && typeof args[1] === \"function\") {\n            fn = args[1];\n        } else if (args.length === 3 && typeof args[2] === \"function\") {\n            fn = args[2];\n        }\n        if (typeof fn === \"function\") {\n            return fn();\n        }\n        return undefined;\n    }\n}\nclass MockOTELTrace {\n    constructor(){\n        Object.defineProperty(this, \"mockTracer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new MockTracer()\n        });\n    }\n    getTracer(_name, _version) {\n        return this.mockTracer;\n    }\n    getActiveSpan() {\n        return undefined;\n    }\n    setSpan(context, _span) {\n        return context;\n    }\n    getSpan(_context) {\n        return undefined;\n    }\n    setSpanContext(context, _spanContext) {\n        return context;\n    }\n    getTracerProvider() {\n        return undefined;\n    }\n    setGlobalTracerProvider(_tracerProvider) {\n        return false;\n    }\n}\nclass MockOTELContext {\n    active() {\n        return {};\n    }\n    with(_context, fn) {\n        return fn();\n    }\n}\nconst OTEL_TRACE_KEY = Symbol.for(\"ls:otel_trace\");\nconst OTEL_CONTEXT_KEY = Symbol.for(\"ls:otel_context\");\nconst OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY = Symbol.for(\"ls:otel_get_default_otlp_tracer_provider\");\nconst mockOTELTrace = new MockOTELTrace();\nconst mockOTELContext = new MockOTELContext();\nclass OTELProvider {\n    getTraceInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_TRACE_KEY] ?? mockOTELTrace;\n    }\n    getContextInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[OTEL_CONTEXT_KEY] ?? mockOTELContext;\n    }\n    initializeGlobalInstances(otel) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_TRACE_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_TRACE_KEY] = otel.trace;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[OTEL_CONTEXT_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[OTEL_CONTEXT_KEY] = otel.context;\n        }\n    }\n    setDefaultOTLPTracerComponents(components) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] = components;\n    }\n    getDefaultOTLPTracerComponents() {\n        return globalThis[OTEL_GET_DEFAULT_OTLP_TRACER_PROVIDER_KEY] ?? undefined;\n    }\n}\nconst OTELProviderSingleton = new OTELProvider();\n/**\n * Get the current OTEL trace instance.\n * Returns a mock implementation if OTEL is not available.\n */ function getOTELTrace() {\n    return OTELProviderSingleton.getTraceInstance();\n}\n/**\n * Get the current OTEL context instance.\n * Returns a mock implementation if OTEL is not available.\n */ function getOTELContext() {\n    return OTELProviderSingleton.getContextInstance();\n}\n/**\n * Initialize the global OTEL instances.\n * Should be called once when OTEL packages are available.\n */ function setOTELInstances(otel) {\n    OTELProviderSingleton.initializeGlobalInstances(otel);\n}\n/**\n * Set a getter function for the default OTLP tracer provider.\n * This allows lazy initialization of the tracer provider.\n */ function setDefaultOTLPTracerComponents(components) {\n    OTELProviderSingleton.setDefaultOTLPTracerComponents(components);\n}\n/**\n * Get the default OTLP tracer provider instance.\n * Returns undefined if not set.\n */ function getDefaultOTLPTracerComponents() {\n    return OTELProviderSingleton.getDefaultOTLPTracerComponents();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy9vdGVsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5RUFBeUU7QUFDeEI7QUFDakQsTUFBTUM7SUFDRkMsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGFBQWE7WUFDckNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU87UUFDWDtJQUNKO0lBQ0FDLGdCQUFnQkMsS0FBSyxFQUFFLEdBQUdDLElBQUksRUFBRTtRQUM1QixJQUFJLENBQUMsSUFBSSxDQUFDQyxTQUFTLElBQUlaLDZEQUFjQSxJQUFJO1lBQ3JDYSxRQUFRQyxJQUFJLENBQUMsaUtBQ1Q7WUFDSixJQUFJLENBQUNGLFNBQVMsR0FBRztRQUNyQjtRQUNBLDhCQUE4QjtRQUM5Qiw0QkFBNEI7UUFDNUIscUNBQXFDO1FBQ3JDLDhDQUE4QztRQUM5QyxJQUFJRztRQUNKLElBQUlKLEtBQUtLLE1BQU0sS0FBSyxLQUFLLE9BQU9MLElBQUksQ0FBQyxFQUFFLEtBQUssWUFBWTtZQUNwREksS0FBS0osSUFBSSxDQUFDLEVBQUU7UUFDaEIsT0FDSyxJQUFJQSxLQUFLSyxNQUFNLEtBQUssS0FBSyxPQUFPTCxJQUFJLENBQUMsRUFBRSxLQUFLLFlBQVk7WUFDekRJLEtBQUtKLElBQUksQ0FBQyxFQUFFO1FBQ2hCLE9BQ0ssSUFBSUEsS0FBS0ssTUFBTSxLQUFLLEtBQUssT0FBT0wsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUFZO1lBQ3pESSxLQUFLSixJQUFJLENBQUMsRUFBRTtRQUNoQjtRQUNBLElBQUksT0FBT0ksT0FBTyxZQUFZO1lBQzFCLE9BQU9BO1FBQ1g7UUFDQSxPQUFPRTtJQUNYO0FBQ0o7QUFDQSxNQUFNQztJQUNGaEIsYUFBYztRQUNWQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGNBQWM7WUFDdENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sSUFBSVA7UUFDZjtJQUNKO0lBQ0FrQixVQUFVVCxLQUFLLEVBQUVVLFFBQVEsRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ0MsVUFBVTtJQUMxQjtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPTDtJQUNYO0lBQ0FNLFFBQVFDLE9BQU8sRUFBRUMsS0FBSyxFQUFFO1FBQ3BCLE9BQU9EO0lBQ1g7SUFDQUUsUUFBUUMsUUFBUSxFQUFFO1FBQ2QsT0FBT1Y7SUFDWDtJQUNBVyxlQUFlSixPQUFPLEVBQUVLLFlBQVksRUFBRTtRQUNsQyxPQUFPTDtJQUNYO0lBQ0FNLG9CQUFvQjtRQUNoQixPQUFPYjtJQUNYO0lBQ0FjLHdCQUF3QkMsZUFBZSxFQUFFO1FBQ3JDLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTUM7SUFDRkMsU0FBUztRQUNMLE9BQU8sQ0FBQztJQUNaO0lBQ0FDLEtBQUtSLFFBQVEsRUFBRVosRUFBRSxFQUFFO1FBQ2YsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTXFCLGlCQUFpQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ2xDLE1BQU1DLG1CQUFtQkYsT0FBT0MsR0FBRyxDQUFDO0FBQ3BDLE1BQU1FLDRDQUE0Q0gsT0FBT0MsR0FBRyxDQUFDO0FBQzdELE1BQU1HLGdCQUFnQixJQUFJdkI7QUFDMUIsTUFBTXdCLGtCQUFrQixJQUFJVDtBQUM1QixNQUFNVTtJQUNGQyxtQkFBbUI7UUFDZiw4REFBOEQ7UUFDOUQsT0FBT0MsVUFBVSxDQUFDVCxlQUFlLElBQUlLO0lBQ3pDO0lBQ0FLLHFCQUFxQjtRQUNqQiw4REFBOEQ7UUFDOUQsT0FBT0QsVUFBVSxDQUFDTixpQkFBaUIsSUFBSUc7SUFDM0M7SUFDQUssMEJBQTBCQyxJQUFJLEVBQUU7UUFDNUIsOERBQThEO1FBQzlELElBQUlILFVBQVUsQ0FBQ1QsZUFBZSxLQUFLbkIsV0FBVztZQUMxQyw4REFBOEQ7WUFDOUQ0QixVQUFVLENBQUNULGVBQWUsR0FBR1ksS0FBS0MsS0FBSztRQUMzQztRQUNBLDhEQUE4RDtRQUM5RCxJQUFJSixVQUFVLENBQUNOLGlCQUFpQixLQUFLdEIsV0FBVztZQUM1Qyw4REFBOEQ7WUFDOUQ0QixVQUFVLENBQUNOLGlCQUFpQixHQUFHUyxLQUFLeEIsT0FBTztRQUMvQztJQUNKO0lBQ0EwQiwrQkFBK0JDLFVBQVUsRUFBRTtRQUN2Qyw4REFBOEQ7UUFDOUROLFVBQVUsQ0FBQ0wsMENBQTBDLEdBQUdXO0lBQzVEO0lBQ0FDLGlDQUFpQztRQUM3QixPQUFRUCxVQUFVLENBQUNMLDBDQUEwQyxJQUN6RHZCO0lBQ1I7QUFDSjtBQUNPLE1BQU1vQyx3QkFBd0IsSUFBSVYsZUFBZTtBQUN4RDs7O0NBR0MsR0FDTSxTQUFTVztJQUNaLE9BQU9ELHNCQUFzQlQsZ0JBQWdCO0FBQ2pEO0FBQ0E7OztDQUdDLEdBQ00sU0FBU1c7SUFDWixPQUFPRixzQkFBc0JQLGtCQUFrQjtBQUNuRDtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNVLGlCQUFpQlIsSUFBSTtJQUNqQ0ssc0JBQXNCTix5QkFBeUIsQ0FBQ0M7QUFDcEQ7QUFDQTs7O0NBR0MsR0FDTSxTQUFTRSwrQkFBK0JDLFVBQVU7SUFDckRFLHNCQUFzQkgsOEJBQThCLENBQUNDO0FBQ3pEO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0M7SUFDWixPQUFPQyxzQkFBc0JELDhCQUE4QjtBQUMvRCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC9zaW5nbGV0b25zL290ZWwuanM/YmVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTaG91bGQgbm90IGltcG9ydCBhbnkgT1RFTCBwYWNrYWdlcyB0byBhdm9pZCBwdWxsaW5nIGluIG9wdGlvbmFsIGRlcHMuXG5pbXBvcnQgeyBnZXRPdGVsRW5hYmxlZCB9IGZyb20gXCIuLi91dGlscy9lbnYuanNcIjtcbmNsYXNzIE1vY2tUcmFjZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJoYXNXYXJuZWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydEFjdGl2ZVNwYW4oX25hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1dhcm5lZCAmJiBnZXRPdGVsRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJZb3UgaGF2ZSBlbmFibGVkIE9URUwgZXhwb3J0IHZpYSB0aGUgYE9URUxfRU5BQkxFRGAgb3IgYExBTkdTTUlUSF9PVEVMX0VOQUJMRURgIGVudmlyb25tZW50IHZhcmlhYmxlLCBidXQgaGF2ZSBub3QgaW5pdGlhbGl6ZWQgdGhlIHJlcXVpcmVkIE9URUwgaW5zdGFuY2VzLiBcIiArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSBhZGQ6XFxuYGBgXFxuaW1wb3J0IHsgaW5pdGlhbGl6ZU9URUwgfSBmcm9tIFwibGFuZ3NtaXRoL2V4cGVyaW1lbnRhbC9vdGVsL3NldHVwXCI7XFxuaW5pdGlhbGl6ZU9URUwoKTtcXG5gYGBcXG5hdCB0aGUgYmVnaW5uaW5nIG9mIHlvdXIgY29kZS4nKTtcbiAgICAgICAgICAgIHRoaXMuaGFzV2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IG92ZXJsb2FkczpcbiAgICAgICAgLy8gc3RhcnRBY3RpdmVTcGFuKG5hbWUsIGZuKVxuICAgICAgICAvLyBzdGFydEFjdGl2ZVNwYW4obmFtZSwgb3B0aW9ucywgZm4pXG4gICAgICAgIC8vIHN0YXJ0QWN0aXZlU3BhbihuYW1lLCBvcHRpb25zLCBjb250ZXh0LCBmbilcbiAgICAgICAgbGV0IGZuO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm4gPSBhcmdzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyICYmIHR5cGVvZiBhcmdzWzFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZuID0gYXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMyAmJiB0eXBlb2YgYXJnc1syXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBmbiA9IGFyZ3NbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmNsYXNzIE1vY2tPVEVMVHJhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtb2NrVHJhY2VyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgTW9ja1RyYWNlcigpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUcmFjZXIoX25hbWUsIF92ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vY2tUcmFjZXI7XG4gICAgfVxuICAgIGdldEFjdGl2ZVNwYW4oKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldFNwYW4oY29udGV4dCwgX3NwYW4pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGdldFNwYW4oX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0U3BhbkNvbnRleHQoY29udGV4dCwgX3NwYW5Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBnZXRUcmFjZXJQcm92aWRlcigpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0R2xvYmFsVHJhY2VyUHJvdmlkZXIoX3RyYWNlclByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBNb2NrT1RFTENvbnRleHQge1xuICAgIGFjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB3aXRoKF9jb250ZXh0LCBmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG59XG5jb25zdCBPVEVMX1RSQUNFX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX3RyYWNlXCIpO1xuY29uc3QgT1RFTF9DT05URVhUX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX2NvbnRleHRcIik7XG5jb25zdCBPVEVMX0dFVF9ERUZBVUxUX09UTFBfVFJBQ0VSX1BST1ZJREVSX0tFWSA9IFN5bWJvbC5mb3IoXCJsczpvdGVsX2dldF9kZWZhdWx0X290bHBfdHJhY2VyX3Byb3ZpZGVyXCIpO1xuY29uc3QgbW9ja09URUxUcmFjZSA9IG5ldyBNb2NrT1RFTFRyYWNlKCk7XG5jb25zdCBtb2NrT1RFTENvbnRleHQgPSBuZXcgTW9ja09URUxDb250ZXh0KCk7XG5jbGFzcyBPVEVMUHJvdmlkZXIge1xuICAgIGdldFRyYWNlSW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW09URUxfVFJBQ0VfS0VZXSA/PyBtb2NrT1RFTFRyYWNlO1xuICAgIH1cbiAgICBnZXRDb250ZXh0SW5zdGFuY2UoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHJldHVybiBnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID8/IG1vY2tPVEVMQ29udGV4dDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlcyhvdGVsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW09URUxfVFJBQ0VfS0VZXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgZ2xvYmFsVGhpc1tPVEVMX1RSQUNFX0tFWV0gPSBvdGVsLnRyYWNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGlmIChnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW09URUxfQ09OVEVYVF9LRVldID0gb3RlbC5jb250ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyhjb21wb25lbnRzKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGdsb2JhbFRoaXNbT1RFTF9HRVRfREVGQVVMVF9PVExQX1RSQUNFUl9QUk9WSURFUl9LRVldID0gY29tcG9uZW50cztcbiAgICB9XG4gICAgZ2V0RGVmYXVsdE9UTFBUcmFjZXJDb21wb25lbnRzKCkge1xuICAgICAgICByZXR1cm4gKGdsb2JhbFRoaXNbT1RFTF9HRVRfREVGQVVMVF9PVExQX1RSQUNFUl9QUk9WSURFUl9LRVldID8/XG4gICAgICAgICAgICB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBPVEVMUHJvdmlkZXJTaW5nbGV0b24gPSBuZXcgT1RFTFByb3ZpZGVyKCk7XG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBPVEVMIHRyYWNlIGluc3RhbmNlLlxuICogUmV0dXJucyBhIG1vY2sgaW1wbGVtZW50YXRpb24gaWYgT1RFTCBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T1RFTFRyYWNlKCkge1xuICAgIHJldHVybiBPVEVMUHJvdmlkZXJTaW5nbGV0b24uZ2V0VHJhY2VJbnN0YW5jZSgpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgT1RFTCBjb250ZXh0IGluc3RhbmNlLlxuICogUmV0dXJucyBhIG1vY2sgaW1wbGVtZW50YXRpb24gaWYgT1RFTCBpcyBub3QgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T1RFTENvbnRleHQoKSB7XG4gICAgcmV0dXJuIE9URUxQcm92aWRlclNpbmdsZXRvbi5nZXRDb250ZXh0SW5zdGFuY2UoKTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgZ2xvYmFsIE9URUwgaW5zdGFuY2VzLlxuICogU2hvdWxkIGJlIGNhbGxlZCBvbmNlIHdoZW4gT1RFTCBwYWNrYWdlcyBhcmUgYXZhaWxhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0T1RFTEluc3RhbmNlcyhvdGVsKSB7XG4gICAgT1RFTFByb3ZpZGVyU2luZ2xldG9uLmluaXRpYWxpemVHbG9iYWxJbnN0YW5jZXMob3RlbCk7XG59XG4vKipcbiAqIFNldCBhIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIGRlZmF1bHQgT1RMUCB0cmFjZXIgcHJvdmlkZXIuXG4gKiBUaGlzIGFsbG93cyBsYXp5IGluaXRpYWxpemF0aW9uIG9mIHRoZSB0cmFjZXIgcHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoY29tcG9uZW50cykge1xuICAgIE9URUxQcm92aWRlclNpbmdsZXRvbi5zZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoY29tcG9uZW50cyk7XG59XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBPVExQIHRyYWNlciBwcm92aWRlciBpbnN0YW5jZS5cbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKSB7XG4gICAgcmV0dXJuIE9URUxQcm92aWRlclNpbmdsZXRvbi5nZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMoKTtcbn1cbiJdLCJuYW1lcyI6WyJnZXRPdGVsRW5hYmxlZCIsIk1vY2tUcmFjZXIiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJzdGFydEFjdGl2ZVNwYW4iLCJfbmFtZSIsImFyZ3MiLCJoYXNXYXJuZWQiLCJjb25zb2xlIiwid2FybiIsImZuIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiTW9ja09URUxUcmFjZSIsImdldFRyYWNlciIsIl92ZXJzaW9uIiwibW9ja1RyYWNlciIsImdldEFjdGl2ZVNwYW4iLCJzZXRTcGFuIiwiY29udGV4dCIsIl9zcGFuIiwiZ2V0U3BhbiIsIl9jb250ZXh0Iiwic2V0U3BhbkNvbnRleHQiLCJfc3BhbkNvbnRleHQiLCJnZXRUcmFjZXJQcm92aWRlciIsInNldEdsb2JhbFRyYWNlclByb3ZpZGVyIiwiX3RyYWNlclByb3ZpZGVyIiwiTW9ja09URUxDb250ZXh0IiwiYWN0aXZlIiwid2l0aCIsIk9URUxfVFJBQ0VfS0VZIiwiU3ltYm9sIiwiZm9yIiwiT1RFTF9DT05URVhUX0tFWSIsIk9URUxfR0VUX0RFRkFVTFRfT1RMUF9UUkFDRVJfUFJPVklERVJfS0VZIiwibW9ja09URUxUcmFjZSIsIm1vY2tPVEVMQ29udGV4dCIsIk9URUxQcm92aWRlciIsImdldFRyYWNlSW5zdGFuY2UiLCJnbG9iYWxUaGlzIiwiZ2V0Q29udGV4dEluc3RhbmNlIiwiaW5pdGlhbGl6ZUdsb2JhbEluc3RhbmNlcyIsIm90ZWwiLCJ0cmFjZSIsInNldERlZmF1bHRPVExQVHJhY2VyQ29tcG9uZW50cyIsImNvbXBvbmVudHMiLCJnZXREZWZhdWx0T1RMUFRyYWNlckNvbXBvbmVudHMiLCJPVEVMUHJvdmlkZXJTaW5nbGV0b24iLCJnZXRPVEVMVHJhY2UiLCJnZXRPVEVMQ29udGV4dCIsInNldE9URUxJbnN0YW5jZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/otel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/singletons/traceable.js":
/*!*************************************************************!*\
  !*** ./node_modules/langsmith/dist/singletons/traceable.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* binding */ AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* binding */ ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* binding */ getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* binding */ isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* binding */ withRunTree)\n/* harmony export */ });\nclass MockAsyncLocalStorage {\n    getStore() {\n        return undefined;\n    }\n    run(_, callback) {\n        return callback();\n    }\n}\nconst TRACING_ALS_KEY = Symbol.for(\"ls:tracing_async_local_storage\");\nconst mockAsyncLocalStorage = new MockAsyncLocalStorage();\nclass AsyncLocalStorageProvider {\n    getInstance() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return globalThis[TRACING_ALS_KEY] ?? mockAsyncLocalStorage;\n    }\n    initializeGlobalInstance(instance) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (globalThis[TRACING_ALS_KEY] === undefined) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            globalThis[TRACING_ALS_KEY] = instance;\n        }\n    }\n}\nconst AsyncLocalStorageProviderSingleton = new AsyncLocalStorageProvider();\nfunction getCurrentRunTree(permitAbsentRunTree = false) {\n    const runTree = AsyncLocalStorageProviderSingleton.getInstance().getStore();\n    if (!permitAbsentRunTree && runTree === undefined) {\n        throw new Error(\"Could not get the current run tree.\\n\\nPlease make sure you are calling this method within a traceable function and that tracing is enabled.\");\n    }\n    return runTree;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction withRunTree(runTree, fn) {\n    const storage = AsyncLocalStorageProviderSingleton.getInstance();\n    return new Promise((resolve, reject)=>{\n        storage.run(runTree, ()=>void Promise.resolve(fn()).then(resolve).catch(reject));\n    });\n}\nconst ROOT = Symbol.for(\"langsmith:traceable:root\");\nfunction isTraceableFunction(x) {\n    return typeof x === \"function\" && \"langsmith:traceable\" in x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3Qvc2luZ2xldG9ucy90cmFjZWFibGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxNQUFNQTtJQUNGQyxXQUFXO1FBQ1AsT0FBT0M7SUFDWDtJQUNBQyxJQUFJQyxDQUFDLEVBQUVDLFFBQVEsRUFBRTtRQUNiLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLGtCQUFrQkMsT0FBT0MsR0FBRyxDQUFDO0FBQ25DLE1BQU1DLHdCQUF3QixJQUFJVDtBQUNsQyxNQUFNVTtJQUNGQyxjQUFjO1FBQ1YsOERBQThEO1FBQzlELE9BQU9DLFVBQVUsQ0FBQ04sZ0JBQWdCLElBQUlHO0lBQzFDO0lBQ0FJLHlCQUF5QkMsUUFBUSxFQUFFO1FBQy9CLDhEQUE4RDtRQUM5RCxJQUFJRixVQUFVLENBQUNOLGdCQUFnQixLQUFLSixXQUFXO1lBQzNDLDhEQUE4RDtZQUM5RFUsVUFBVSxDQUFDTixnQkFBZ0IsR0FBR1E7UUFDbEM7SUFDSjtBQUNKO0FBQ08sTUFBTUMscUNBQXFDLElBQUlMLDRCQUE0QjtBQUMzRSxTQUFTTSxrQkFBa0JDLHNCQUFzQixLQUFLO0lBQ3pELE1BQU1DLFVBQVVILG1DQUFtQ0osV0FBVyxHQUFHVixRQUFRO0lBQ3pFLElBQUksQ0FBQ2dCLHVCQUF1QkMsWUFBWWhCLFdBQVc7UUFDL0MsTUFBTSxJQUFJaUIsTUFBTTtJQUNwQjtJQUNBLE9BQU9EO0FBQ1g7QUFDQSw4REFBOEQ7QUFDdkQsU0FBU0UsWUFBWUYsT0FBTyxFQUFFRyxFQUFFO0lBQ25DLE1BQU1DLFVBQVVQLG1DQUFtQ0osV0FBVztJQUM5RCxPQUFPLElBQUlZLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDekJILFFBQVFuQixHQUFHLENBQUNlLFNBQVMsSUFBTSxLQUFLSyxRQUFRQyxPQUFPLENBQUNILE1BQU1LLElBQUksQ0FBQ0YsU0FBU0csS0FBSyxDQUFDRjtJQUM5RTtBQUNKO0FBQ08sTUFBTUcsT0FBT3JCLE9BQU9DLEdBQUcsQ0FBQyw0QkFBNEI7QUFDcEQsU0FBU3FCLG9CQUFvQkMsQ0FBQztJQUdqQyxPQUFPLE9BQU9BLE1BQU0sY0FBYyx5QkFBeUJBO0FBQy9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzPzcyMjMiXSwic291cmNlc0NvbnRlbnQiOlsiY2xhc3MgTW9ja0FzeW5jTG9jYWxTdG9yYWdlIHtcbiAgICBnZXRTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcnVuKF8sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cbn1cbmNvbnN0IFRSQUNJTkdfQUxTX0tFWSA9IFN5bWJvbC5mb3IoXCJsczp0cmFjaW5nX2FzeW5jX2xvY2FsX3N0b3JhZ2VcIik7XG5jb25zdCBtb2NrQXN5bmNMb2NhbFN0b3JhZ2UgPSBuZXcgTW9ja0FzeW5jTG9jYWxTdG9yYWdlKCk7XG5jbGFzcyBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyIHtcbiAgICBnZXRJbnN0YW5jZSgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXNbVFJBQ0lOR19BTFNfS0VZXSA/PyBtb2NrQXN5bmNMb2NhbFN0b3JhZ2U7XG4gICAgfVxuICAgIGluaXRpYWxpemVHbG9iYWxJbnN0YW5jZShpbnN0YW5jZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBpZiAoZ2xvYmFsVGhpc1tUUkFDSU5HX0FMU19LRVldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBnbG9iYWxUaGlzW1RSQUNJTkdfQUxTX0tFWV0gPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBBc3luY0xvY2FsU3RvcmFnZVByb3ZpZGVyU2luZ2xldG9uID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50UnVuVHJlZShwZXJtaXRBYnNlbnRSdW5UcmVlID0gZmFsc2UpIHtcbiAgICBjb25zdCBydW5UcmVlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpLmdldFN0b3JlKCk7XG4gICAgaWYgKCFwZXJtaXRBYnNlbnRSdW5UcmVlICYmIHJ1blRyZWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IHRoZSBjdXJyZW50IHJ1biB0cmVlLlxcblxcblBsZWFzZSBtYWtlIHN1cmUgeW91IGFyZSBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGhpbiBhIHRyYWNlYWJsZSBmdW5jdGlvbiBhbmQgdGhhdCB0cmFjaW5nIGlzIGVuYWJsZWQuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcnVuVHJlZTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gd2l0aFJ1blRyZWUocnVuVHJlZSwgZm4pIHtcbiAgICBjb25zdCBzdG9yYWdlID0gQXN5bmNMb2NhbFN0b3JhZ2VQcm92aWRlclNpbmdsZXRvbi5nZXRJbnN0YW5jZSgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHN0b3JhZ2UucnVuKHJ1blRyZWUsICgpID0+IHZvaWQgUHJvbWlzZS5yZXNvbHZlKGZuKCkpLnRoZW4ocmVzb2x2ZSkuY2F0Y2gocmVqZWN0KSk7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgUk9PVCA9IFN5bWJvbC5mb3IoXCJsYW5nc21pdGg6dHJhY2VhYmxlOnJvb3RcIik7XG5leHBvcnQgZnVuY3Rpb24gaXNUcmFjZWFibGVGdW5jdGlvbih4XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgJiYgXCJsYW5nc21pdGg6dHJhY2VhYmxlXCIgaW4geDtcbn1cbiJdLCJuYW1lcyI6WyJNb2NrQXN5bmNMb2NhbFN0b3JhZ2UiLCJnZXRTdG9yZSIsInVuZGVmaW5lZCIsInJ1biIsIl8iLCJjYWxsYmFjayIsIlRSQUNJTkdfQUxTX0tFWSIsIlN5bWJvbCIsImZvciIsIm1vY2tBc3luY0xvY2FsU3RvcmFnZSIsIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXIiLCJnZXRJbnN0YW5jZSIsImdsb2JhbFRoaXMiLCJpbml0aWFsaXplR2xvYmFsSW5zdGFuY2UiLCJpbnN0YW5jZSIsIkFzeW5jTG9jYWxTdG9yYWdlUHJvdmlkZXJTaW5nbGV0b24iLCJnZXRDdXJyZW50UnVuVHJlZSIsInBlcm1pdEFic2VudFJ1blRyZWUiLCJydW5UcmVlIiwiRXJyb3IiLCJ3aXRoUnVuVHJlZSIsImZuIiwic3RvcmFnZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGhlbiIsImNhdGNoIiwiUk9PVCIsImlzVHJhY2VhYmxlRnVuY3Rpb24iLCJ4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/_uuid.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/_uuid.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertUuid: () => (/* binding */ assertUuid),\n/* harmony export */   getUuidVersion: () => (/* binding */ getUuidVersion),\n/* harmony export */   uuid7FromTime: () => (/* binding */ uuid7FromTime),\n/* harmony export */   warnIfNotUuidV7: () => (/* binding */ warnIfNotUuidV7)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _warn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./warn.js */ \"(rsc)/./node_modules/langsmith/dist/utils/warn.js\");\n// Relaxed UUID validation regex (allows any valid UUID format including nil UUIDs)\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\n\n\nlet UUID7_WARNING_EMITTED = false;\nfunction assertUuid(str, which) {\n    // Use relaxed regex validation instead of strict uuid.validate()\n    // This allows edge cases like nil UUIDs or test UUIDs that might not pass strict validation\n    if (!UUID_REGEX.test(str)) {\n        const msg = which !== undefined ? `Invalid UUID for ${which}: ${str}` : `Invalid UUID: ${str}`;\n        throw new Error(msg);\n    }\n    return str;\n}\n/**\n * Generate a UUID v7 from a timestamp.\n *\n * @param timestamp - The timestamp in milliseconds\n * @returns A UUID v7 string\n */ function uuid7FromTime(timestamp) {\n    const msecs = typeof timestamp === \"string\" ? Date.parse(timestamp) : timestamp;\n    // Work around uuid@10 behavior where providing only { msecs }\n    // may not set the internal timestamp used for stringification.\n    // Providing a seq ensures the implementation updates its internal state\n    // and encodes the provided milliseconds into the UUID bytes.\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        msecs,\n        seq: 0\n    });\n}\n/**\n * Get the version of a UUID string.\n * @param uuidStr - The UUID string to check\n * @returns The version number (1-7) or null if invalid\n */ function getUuidVersion(uuidStr) {\n    if (!UUID_REGEX.test(uuidStr)) {\n        return null;\n    }\n    // Version is in bits 48-51\n    // Format: xxxxxxxx-xxxx-Vxxx-xxxx-xxxxxxxxxxxx\n    const versionChar = uuidStr[14];\n    return parseInt(versionChar, 16);\n}\n/**\n * Warn if a UUID is not version 7.\n *\n * @param uuidStr - The UUID string to check\n * @param idType - The type of ID (e.g., \"run_id\", \"trace_id\") for the warning message\n */ function warnIfNotUuidV7(uuidStr, _idType) {\n    const version = getUuidVersion(uuidStr);\n    if (version !== null && version !== 7 && !UUID7_WARNING_EMITTED) {\n        UUID7_WARNING_EMITTED = true;\n        (0,_warn_js__WEBPACK_IMPORTED_MODULE_0__.warnOnce)(`LangSmith now uses UUID v7 for run and trace identifiers. ` + `This warning appears when passing custom IDs. ` + `Please use: import { uuidv7 } from 'langsmith'; const id = uuidv7(); ` + `Future versions will require UUID v7.`);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvX3V1aWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUZBQW1GO0FBQ25GLE1BQU1BLGFBQWE7QUFDaUI7QUFDQztBQUNyQyxJQUFJSSx3QkFBd0I7QUFDckIsU0FBU0MsV0FBV0MsR0FBRyxFQUFFQyxLQUFLO0lBQ2pDLGlFQUFpRTtJQUNqRSw0RkFBNEY7SUFDNUYsSUFBSSxDQUFDUCxXQUFXUSxJQUFJLENBQUNGLE1BQU07UUFDdkIsTUFBTUcsTUFBTUYsVUFBVUcsWUFDaEIsQ0FBQyxpQkFBaUIsRUFBRUgsTUFBTSxFQUFFLEVBQUVELElBQUksQ0FBQyxHQUNuQyxDQUFDLGNBQWMsRUFBRUEsSUFBSSxDQUFDO1FBQzVCLE1BQU0sSUFBSUssTUFBTUY7SUFDcEI7SUFDQSxPQUFPSDtBQUNYO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTTSxjQUFjQyxTQUFTO0lBQ25DLE1BQU1DLFFBQVEsT0FBT0QsY0FBYyxXQUFXRSxLQUFLQyxLQUFLLENBQUNILGFBQWFBO0lBQ3RFLDhEQUE4RDtJQUM5RCwrREFBK0Q7SUFDL0Qsd0VBQXdFO0lBQ3hFLDZEQUE2RDtJQUM3RCxPQUFPWCxnREFBTUEsQ0FBQztRQUFFWTtRQUFPRyxLQUFLO0lBQUU7QUFDbEM7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0MsZUFBZUMsT0FBTztJQUNsQyxJQUFJLENBQUNuQixXQUFXUSxJQUFJLENBQUNXLFVBQVU7UUFDM0IsT0FBTztJQUNYO0lBQ0EsMkJBQTJCO0lBQzNCLCtDQUErQztJQUMvQyxNQUFNQyxjQUFjRCxPQUFPLENBQUMsR0FBRztJQUMvQixPQUFPRSxTQUFTRCxhQUFhO0FBQ2pDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTRSxnQkFBZ0JILE9BQU8sRUFBRUksT0FBTztJQUM1QyxNQUFNQyxVQUFVTixlQUFlQztJQUMvQixJQUFJSyxZQUFZLFFBQVFBLFlBQVksS0FBSyxDQUFDcEIsdUJBQXVCO1FBQzdEQSx3QkFBd0I7UUFDeEJELGtEQUFRQSxDQUFDLENBQUMsMERBQTBELENBQUMsR0FDakUsQ0FBQyw4Q0FBOEMsQ0FBQyxHQUNoRCxDQUFDLHFFQUFxRSxDQUFDLEdBQ3ZFLENBQUMscUNBQXFDLENBQUM7SUFDL0M7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9fdXVpZC5qcz9jNmI5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJlbGF4ZWQgVVVJRCB2YWxpZGF0aW9uIHJlZ2V4IChhbGxvd3MgYW55IHZhbGlkIFVVSUQgZm9ybWF0IGluY2x1ZGluZyBuaWwgVVVJRHMpXG5jb25zdCBVVUlEX1JFR0VYID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kL2k7XG5pbXBvcnQgeyB2NyBhcyB1dWlkdjcgfSBmcm9tIFwidXVpZFwiO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tIFwiLi93YXJuLmpzXCI7XG5sZXQgVVVJRDdfV0FSTklOR19FTUlUVEVEID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VXVpZChzdHIsIHdoaWNoKSB7XG4gICAgLy8gVXNlIHJlbGF4ZWQgcmVnZXggdmFsaWRhdGlvbiBpbnN0ZWFkIG9mIHN0cmljdCB1dWlkLnZhbGlkYXRlKClcbiAgICAvLyBUaGlzIGFsbG93cyBlZGdlIGNhc2VzIGxpa2UgbmlsIFVVSURzIG9yIHRlc3QgVVVJRHMgdGhhdCBtaWdodCBub3QgcGFzcyBzdHJpY3QgdmFsaWRhdGlvblxuICAgIGlmICghVVVJRF9SRUdFWC50ZXN0KHN0cikpIHtcbiAgICAgICAgY29uc3QgbXNnID0gd2hpY2ggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBgSW52YWxpZCBVVUlEIGZvciAke3doaWNofTogJHtzdHJ9YFxuICAgICAgICAgICAgOiBgSW52YWxpZCBVVUlEOiAke3N0cn1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICogR2VuZXJhdGUgYSBVVUlEIHY3IGZyb20gYSB0aW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIHRpbWVzdGFtcCAtIFRoZSB0aW1lc3RhbXAgaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJucyBBIFVVSUQgdjcgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dWlkN0Zyb21UaW1lKHRpbWVzdGFtcCkge1xuICAgIGNvbnN0IG1zZWNzID0gdHlwZW9mIHRpbWVzdGFtcCA9PT0gXCJzdHJpbmdcIiA/IERhdGUucGFyc2UodGltZXN0YW1wKSA6IHRpbWVzdGFtcDtcbiAgICAvLyBXb3JrIGFyb3VuZCB1dWlkQDEwIGJlaGF2aW9yIHdoZXJlIHByb3ZpZGluZyBvbmx5IHsgbXNlY3MgfVxuICAgIC8vIG1heSBub3Qgc2V0IHRoZSBpbnRlcm5hbCB0aW1lc3RhbXAgdXNlZCBmb3Igc3RyaW5naWZpY2F0aW9uLlxuICAgIC8vIFByb3ZpZGluZyBhIHNlcSBlbnN1cmVzIHRoZSBpbXBsZW1lbnRhdGlvbiB1cGRhdGVzIGl0cyBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIGFuZCBlbmNvZGVzIHRoZSBwcm92aWRlZCBtaWxsaXNlY29uZHMgaW50byB0aGUgVVVJRCBieXRlcy5cbiAgICByZXR1cm4gdXVpZHY3KHsgbXNlY3MsIHNlcTogMCB9KTtcbn1cbi8qKlxuICogR2V0IHRoZSB2ZXJzaW9uIG9mIGEgVVVJRCBzdHJpbmcuXG4gKiBAcGFyYW0gdXVpZFN0ciAtIFRoZSBVVUlEIHN0cmluZyB0byBjaGVja1xuICogQHJldHVybnMgVGhlIHZlcnNpb24gbnVtYmVyICgxLTcpIG9yIG51bGwgaWYgaW52YWxpZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXVpZFZlcnNpb24odXVpZFN0cikge1xuICAgIGlmICghVVVJRF9SRUdFWC50ZXN0KHV1aWRTdHIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBWZXJzaW9uIGlzIGluIGJpdHMgNDgtNTFcbiAgICAvLyBGb3JtYXQ6IHh4eHh4eHh4LXh4eHgtVnh4eC14eHh4LXh4eHh4eHh4eHh4eFxuICAgIGNvbnN0IHZlcnNpb25DaGFyID0gdXVpZFN0clsxNF07XG4gICAgcmV0dXJuIHBhcnNlSW50KHZlcnNpb25DaGFyLCAxNik7XG59XG4vKipcbiAqIFdhcm4gaWYgYSBVVUlEIGlzIG5vdCB2ZXJzaW9uIDcuXG4gKlxuICogQHBhcmFtIHV1aWRTdHIgLSBUaGUgVVVJRCBzdHJpbmcgdG8gY2hlY2tcbiAqIEBwYXJhbSBpZFR5cGUgLSBUaGUgdHlwZSBvZiBJRCAoZS5nLiwgXCJydW5faWRcIiwgXCJ0cmFjZV9pZFwiKSBmb3IgdGhlIHdhcm5pbmcgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2FybklmTm90VXVpZFY3KHV1aWRTdHIsIF9pZFR5cGUpIHtcbiAgICBjb25zdCB2ZXJzaW9uID0gZ2V0VXVpZFZlcnNpb24odXVpZFN0cik7XG4gICAgaWYgKHZlcnNpb24gIT09IG51bGwgJiYgdmVyc2lvbiAhPT0gNyAmJiAhVVVJRDdfV0FSTklOR19FTUlUVEVEKSB7XG4gICAgICAgIFVVSUQ3X1dBUk5JTkdfRU1JVFRFRCA9IHRydWU7XG4gICAgICAgIHdhcm5PbmNlKGBMYW5nU21pdGggbm93IHVzZXMgVVVJRCB2NyBmb3IgcnVuIGFuZCB0cmFjZSBpZGVudGlmaWVycy4gYCArXG4gICAgICAgICAgICBgVGhpcyB3YXJuaW5nIGFwcGVhcnMgd2hlbiBwYXNzaW5nIGN1c3RvbSBJRHMuIGAgK1xuICAgICAgICAgICAgYFBsZWFzZSB1c2U6IGltcG9ydCB7IHV1aWR2NyB9IGZyb20gJ2xhbmdzbWl0aCc7IGNvbnN0IGlkID0gdXVpZHY3KCk7IGAgK1xuICAgICAgICAgICAgYEZ1dHVyZSB2ZXJzaW9ucyB3aWxsIHJlcXVpcmUgVVVJRCB2Ny5gKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOlsiVVVJRF9SRUdFWCIsInY3IiwidXVpZHY3Iiwid2Fybk9uY2UiLCJVVUlEN19XQVJOSU5HX0VNSVRURUQiLCJhc3NlcnRVdWlkIiwic3RyIiwid2hpY2giLCJ0ZXN0IiwibXNnIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJ1dWlkN0Zyb21UaW1lIiwidGltZXN0YW1wIiwibXNlY3MiLCJEYXRlIiwicGFyc2UiLCJzZXEiLCJnZXRVdWlkVmVyc2lvbiIsInV1aWRTdHIiLCJ2ZXJzaW9uQ2hhciIsInBhcnNlSW50Iiwid2FybklmTm90VXVpZFY3IiwiX2lkVHlwZSIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/async_caller.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/async_caller.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncCaller: () => (/* binding */ AsyncCaller)\n/* harmony export */ });\n/* harmony import */ var _utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/p-retry/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/p-retry/index.js\");\n/* harmony import */ var p_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-queue */ \"(rsc)/./node_modules/p-queue/dist/index.js\");\n\n\nconst STATUS_RETRYABLE = [\n    408,\n    425,\n    429,\n    500,\n    502,\n    503,\n    504\n];\n/**\n * A class that can be used to make async calls with concurrency and retry logic.\n *\n * This is useful for making calls to any kind of \"expensive\" external resource,\n * be it because it's rate-limited, subject to network issues, etc.\n *\n * Concurrent calls are limited by the `maxConcurrency` parameter, which defaults\n * to `Infinity`. This means that by default, all calls will be made in parallel.\n *\n * Retries are limited by the `maxRetries` parameter, which defaults to 6. This\n * means that by default, each call will be retried up to 6 times, with an\n * exponential backoff between each attempt.\n */ class AsyncCaller {\n    constructor(params){\n        Object.defineProperty(this, \"maxConcurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxRetries\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxQueueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"onFailedResponseHook\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"queueSizeBytes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        this.maxConcurrency = params.maxConcurrency ?? Infinity;\n        this.maxRetries = params.maxRetries ?? 6;\n        this.maxQueueSizeBytes = params.maxQueueSizeBytes;\n        if ( true) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n                concurrency: this.maxConcurrency\n            });\n        } else {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.queue = new p_queue__WEBPACK_IMPORTED_MODULE_1__({\n                concurrency: this.maxConcurrency\n            });\n        }\n        this.onFailedResponseHook = params?.onFailedResponseHook;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    call(callable, ...args) {\n        return this.callWithOptions({}, callable, ...args);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callWithOptions(options, callable, ...args) {\n        const sizeBytes = options.sizeBytes ?? 0;\n        // Check if adding this call would exceed the byte size limit\n        if (this.maxQueueSizeBytes !== undefined && sizeBytes > 0 && this.queueSizeBytes + sizeBytes > this.maxQueueSizeBytes) {\n            return Promise.reject(new Error(`Queue size limit (${this.maxQueueSizeBytes} bytes) exceeded. ` + `Current queue size: ${this.queueSizeBytes} bytes, attempted addition: ${sizeBytes} bytes.`));\n        }\n        // Add to queue size tracking\n        if (sizeBytes > 0) {\n            this.queueSizeBytes += sizeBytes;\n        }\n        const onFailedResponseHook = this.onFailedResponseHook;\n        let promise = this.queue.add(()=>(0,_utils_p_retry_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(()=>callable(...args).catch((error)=>{\n                    // eslint-disable-next-line no-instanceof/no-instanceof\n                    if (error instanceof Error) {\n                        throw error;\n                    } else {\n                        throw new Error(error);\n                    }\n                }), {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                async onFailedAttempt ({ error }) {\n                    if (error.message.startsWith(\"Cancel\") || error.message.startsWith(\"TimeoutError\") || error.name === \"TimeoutError\" || error.message.startsWith(\"AbortError\")) {\n                        throw error;\n                    }\n                    if (error?.code === \"ECONNABORTED\") {\n                        throw error;\n                    }\n                    const response = error?.response;\n                    if (onFailedResponseHook) {\n                        const handled = await onFailedResponseHook(response);\n                        if (handled) {\n                            return;\n                        }\n                    }\n                    const status = response?.status ?? error?.status;\n                    if (status) {\n                        if (!STATUS_RETRYABLE.includes(+status)) {\n                            throw error;\n                        }\n                    }\n                },\n                retries: this.maxRetries,\n                randomize: true\n            }), {\n            throwOnTimeout: true\n        });\n        // Decrement queue size when the call completes (success or failure)\n        if (sizeBytes > 0) {\n            promise = promise.finally(()=>{\n                this.queueSizeBytes -= sizeBytes;\n            });\n        }\n        // Handle signal cancellation\n        if (options.signal) {\n            return Promise.race([\n                promise,\n                new Promise((_, reject)=>{\n                    options.signal?.addEventListener(\"abort\", ()=>{\n                        reject(new Error(\"AbortError\"));\n                    });\n                })\n            ]);\n        }\n        return promise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQztBQUNmO0FBQ2hDLE1BQU1FLG1CQUFtQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0Q7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sTUFBTUM7SUFDVEMsWUFBWUMsTUFBTSxDQUFFO1FBQ2hCQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGtCQUFrQjtZQUMxQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYztZQUN0Q0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTyxLQUFLO1FBQ2hCO1FBQ0FMLE9BQU9DLGNBQWMsQ0FBQyxJQUFJLEVBQUUscUJBQXFCO1lBQzdDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxTQUFTO1lBQ2pDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQUwsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSx3QkFBd0I7WUFDaERDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU8sS0FBSztRQUNoQjtRQUNBTCxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLGtCQUFrQjtZQUMxQ0MsWUFBWTtZQUNaQyxjQUFjO1lBQ2RDLFVBQVU7WUFDVkMsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFDQyxjQUFjLEdBQUdQLE9BQU9PLGNBQWMsSUFBSUM7UUFDL0MsSUFBSSxDQUFDQyxVQUFVLEdBQUdULE9BQU9TLFVBQVUsSUFBSTtRQUN2QyxJQUFJLENBQUNDLGlCQUFpQixHQUFH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O1lBQ2hCLE9BQU9wQixRQUFRcUIsSUFBSSxDQUFDO2dCQUNoQmxCO2dCQUNBLElBQUlILFFBQVEsQ0FBQ3NCLEdBQUdyQjtvQkFDWkwsUUFBUXdCLE1BQU0sRUFBRUcsaUJBQWlCLFNBQVM7d0JBQ3RDdEIsT0FBTyxJQUFJQyxNQUFNO29CQUNyQjtnQkFDSjthQUNIO1FBQ0w7UUFDQSxPQUFPQztJQUNYO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvYXN5bmNfY2FsbGVyLmpzP2E4ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBSZXRyeSBmcm9tIFwiLi4vdXRpbHMvcC1yZXRyeS9pbmRleC5qc1wiO1xuaW1wb3J0IFBRdWV1ZU1vZCBmcm9tIFwicC1xdWV1ZVwiO1xuY29uc3QgU1RBVFVTX1JFVFJZQUJMRSA9IFtcbiAgICA0MDgsIC8vIFJlcXVlc3QgVGltZW91dFxuICAgIDQyNSwgLy8gVG9vIEVhcmx5XG4gICAgNDI5LCAvLyBUb28gTWFueSBSZXF1ZXN0c1xuICAgIDUwMCwgLy8gSW50ZXJuYWwgU2VydmVyIEVycm9yXG4gICAgNTAyLCAvLyBCYWQgR2F0ZXdheVxuICAgIDUwMywgLy8gU2VydmljZSBVbmF2YWlsYWJsZVxuICAgIDUwNCwgLy8gR2F0ZXdheSBUaW1lb3V0XG5dO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhc3luYyBjYWxscyB3aXRoIGNvbmN1cnJlbmN5IGFuZCByZXRyeSBsb2dpYy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgbWFraW5nIGNhbGxzIHRvIGFueSBraW5kIG9mIFwiZXhwZW5zaXZlXCIgZXh0ZXJuYWwgcmVzb3VyY2UsXG4gKiBiZSBpdCBiZWNhdXNlIGl0J3MgcmF0ZS1saW1pdGVkLCBzdWJqZWN0IHRvIG5ldHdvcmsgaXNzdWVzLCBldGMuXG4gKlxuICogQ29uY3VycmVudCBjYWxscyBhcmUgbGltaXRlZCBieSB0aGUgYG1heENvbmN1cnJlbmN5YCBwYXJhbWV0ZXIsIHdoaWNoIGRlZmF1bHRzXG4gKiB0byBgSW5maW5pdHlgLiBUaGlzIG1lYW5zIHRoYXQgYnkgZGVmYXVsdCwgYWxsIGNhbGxzIHdpbGwgYmUgbWFkZSBpbiBwYXJhbGxlbC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBsaW1pdGVkIGJ5IHRoZSBgbWF4UmV0cmllc2AgcGFyYW1ldGVyLCB3aGljaCBkZWZhdWx0cyB0byA2LiBUaGlzXG4gKiBtZWFucyB0aGF0IGJ5IGRlZmF1bHQsIGVhY2ggY2FsbCB3aWxsIGJlIHJldHJpZWQgdXAgdG8gNiB0aW1lcywgd2l0aCBhblxuICogZXhwb25lbnRpYWwgYmFja29mZiBiZXR3ZWVuIGVhY2ggYXR0ZW1wdC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQ2FsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4Q29uY3VycmVuY3lcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4UmV0cmllc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtYXhRdWV1ZVNpemVCeXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJvbkZhaWxlZFJlc3BvbnNlSG9va1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJxdWV1ZVNpemVCeXRlc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhDb25jdXJyZW5jeSA9IHBhcmFtcy5tYXhDb25jdXJyZW5jeSA/PyBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5tYXhSZXRyaWVzID0gcGFyYW1zLm1heFJldHJpZXMgPz8gNjtcbiAgICAgICAgdGhpcy5tYXhRdWV1ZVNpemVCeXRlcyA9IHBhcmFtcy5tYXhRdWV1ZVNpemVCeXRlcztcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIFBRdWV1ZU1vZCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBuZXcgUFF1ZXVlTW9kLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGNvbmN1cnJlbmN5OiB0aGlzLm1heENvbmN1cnJlbmN5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG5ldyBQUXVldWVNb2QoeyBjb25jdXJyZW5jeTogdGhpcy5tYXhDb25jdXJyZW5jeSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzcG9uc2VIb29rID0gcGFyYW1zPy5vbkZhaWxlZFJlc3BvbnNlSG9vaztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsKGNhbGxhYmxlLCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxXaXRoT3B0aW9ucyh7fSwgY2FsbGFibGUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxXaXRoT3B0aW9ucyhvcHRpb25zLCBjYWxsYWJsZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBzaXplQnl0ZXMgPSBvcHRpb25zLnNpemVCeXRlcyA/PyAwO1xuICAgICAgICAvLyBDaGVjayBpZiBhZGRpbmcgdGhpcyBjYWxsIHdvdWxkIGV4Y2VlZCB0aGUgYnl0ZSBzaXplIGxpbWl0XG4gICAgICAgIGlmICh0aGlzLm1heFF1ZXVlU2l6ZUJ5dGVzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHNpemVCeXRlcyA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMucXVldWVTaXplQnl0ZXMgKyBzaXplQnl0ZXMgPiB0aGlzLm1heFF1ZXVlU2l6ZUJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBRdWV1ZSBzaXplIGxpbWl0ICgke3RoaXMubWF4UXVldWVTaXplQnl0ZXN9IGJ5dGVzKSBleGNlZWRlZC4gYCArXG4gICAgICAgICAgICAgICAgYEN1cnJlbnQgcXVldWUgc2l6ZTogJHt0aGlzLnF1ZXVlU2l6ZUJ5dGVzfSBieXRlcywgYXR0ZW1wdGVkIGFkZGl0aW9uOiAke3NpemVCeXRlc30gYnl0ZXMuYCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0byBxdWV1ZSBzaXplIHRyYWNraW5nXG4gICAgICAgIGlmIChzaXplQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlU2l6ZUJ5dGVzICs9IHNpemVCeXRlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkZhaWxlZFJlc3BvbnNlSG9vayA9IHRoaXMub25GYWlsZWRSZXNwb25zZUhvb2s7XG4gICAgICAgIGxldCBwcm9taXNlID0gdGhpcy5xdWV1ZS5hZGQoKCkgPT4gcFJldHJ5KCgpID0+IGNhbGxhYmxlKC4uLmFyZ3MpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWluc3RhbmNlb2Yvbm8taW5zdGFuY2VvZlxuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgYXN5bmMgb25GYWlsZWRBdHRlbXB0KHsgZXJyb3IgfSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLnN0YXJ0c1dpdGgoXCJDYW5jZWxcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiVGltZW91dEVycm9yXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQWJvcnRFcnJvclwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yPy5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGVycm9yPy5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAob25GYWlsZWRSZXNwb25zZUhvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlZCA9IGF3YWl0IG9uRmFpbGVkUmVzcG9uc2VIb29rKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSByZXNwb25zZT8uc3RhdHVzID8/IGVycm9yPy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVNUQVRVU19SRVRSWUFCTEUuaW5jbHVkZXMoK3N0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHJpZXM6IHRoaXMubWF4UmV0cmllcyxcbiAgICAgICAgICAgIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgICAgICAgfSksIHsgdGhyb3dPblRpbWVvdXQ6IHRydWUgfSk7XG4gICAgICAgIC8vIERlY3JlbWVudCBxdWV1ZSBzaXplIHdoZW4gdGhlIGNhbGwgY29tcGxldGVzIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgIGlmIChzaXplQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlU2l6ZUJ5dGVzIC09IHNpemVCeXRlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzaWduYWwgY2FuY2VsbGF0aW9uXG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgcHJvbWlzZSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0RXJyb3JcIikpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwUmV0cnkiLCJQUXVldWVNb2QiLCJTVEFUVVNfUkVUUllBQkxFIiwiQXN5bmNDYWxsZXIiLCJjb25zdHJ1Y3RvciIsInBhcmFtcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJtYXhDb25jdXJyZW5jeSIsIkluZmluaXR5IiwibWF4UmV0cmllcyIsIm1heFF1ZXVlU2l6ZUJ5dGVzIiwicXVldWUiLCJkZWZhdWx0IiwiY29uY3VycmVuY3kiLCJvbkZhaWxlZFJlc3BvbnNlSG9vayIsImNhbGwiLCJjYWxsYWJsZSIsImFyZ3MiLCJjYWxsV2l0aE9wdGlvbnMiLCJvcHRpb25zIiwic2l6ZUJ5dGVzIiwidW5kZWZpbmVkIiwicXVldWVTaXplQnl0ZXMiLCJQcm9taXNlIiwicmVqZWN0IiwiRXJyb3IiLCJwcm9taXNlIiwiYWRkIiwiY2F0Y2giLCJlcnJvciIsIm9uRmFpbGVkQXR0ZW1wdCIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwibmFtZSIsImNvZGUiLCJyZXNwb25zZSIsImhhbmRsZWQiLCJzdGF0dXMiLCJpbmNsdWRlcyIsInJldHJpZXMiLCJyYW5kb21pemUiLCJ0aHJvd09uVGltZW91dCIsImZpbmFsbHkiLCJzaWduYWwiLCJyYWNlIiwiXyIsImFkZEV2ZW50TGlzdGVuZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/async_caller.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/context_vars.js":
/*!***********************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/context_vars.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getContextVar: () => (/* binding */ getContextVar),\n/* harmony export */   setContextVar: () => (/* binding */ setContextVar)\n/* harmony export */ });\n/* harmony import */ var _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../singletons/constants.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/constants.js\");\n\n/**\n * Get a context variable from a run tree instance\n */ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getContextVar(runTree, key) {\n    if (_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const contextVars = runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY];\n        return contextVars[key];\n    }\n    return undefined;\n}\n/**\n * Set a context variable on a run tree instance\n */ function setContextVar(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrunTree, key, value) {\n    const contextVars = _singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY in runTree ? runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY] : {};\n    contextVars[key] = value;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    runTree[_singletons_constants_js__WEBPACK_IMPORTED_MODULE_0__._LC_CONTEXT_VARIABLES_KEY] = contextVars;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvY29udGV4dF92YXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF1RTtBQUN2RTs7Q0FFQyxHQUNELDhEQUE4RDtBQUN2RCxTQUFTQyxjQUFjQyxPQUFPLEVBQUVDLEdBQUc7SUFDdEMsSUFBSUgsK0VBQXlCQSxJQUFJRSxTQUFTO1FBQ3RDLDhEQUE4RDtRQUM5RCxNQUFNRSxjQUFjRixPQUFPLENBQUNGLCtFQUF5QkEsQ0FBQztRQUN0RCxPQUFPSSxXQUFXLENBQUNELElBQUk7SUFDM0I7SUFDQSxPQUFPRTtBQUNYO0FBQ0E7O0NBRUMsR0FDTSxTQUFTQyxjQUNoQiw4REFBOEQ7QUFDOURKLE9BQU8sRUFBRUMsR0FBRyxFQUFFSSxLQUFLO0lBQ2YsTUFBTUgsY0FBY0osK0VBQXlCQSxJQUFJRSxVQUV6Q0EsT0FBTyxDQUFDRiwrRUFBeUJBLENBQUMsR0FDcEMsQ0FBQztJQUNQSSxXQUFXLENBQUNELElBQUksR0FBR0k7SUFDbkIsOERBQThEO0lBQzlETCxPQUFPLENBQUNGLCtFQUF5QkEsQ0FBQyxHQUFHSTtBQUN6QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9jb250ZXh0X3ZhcnMuanM/MGUxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIH0gZnJvbSBcIi4uL3NpbmdsZXRvbnMvY29uc3RhbnRzLmpzXCI7XG4vKipcbiAqIEdldCBhIGNvbnRleHQgdmFyaWFibGUgZnJvbSBhIHJ1biB0cmVlIGluc3RhbmNlXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udGV4dFZhcihydW5UcmVlLCBrZXkpIHtcbiAgICBpZiAoX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWSBpbiBydW5UcmVlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IGNvbnRleHRWYXJzID0gcnVuVHJlZVtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXTtcbiAgICAgICAgcmV0dXJuIGNvbnRleHRWYXJzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFNldCBhIGNvbnRleHQgdmFyaWFibGUgb24gYSBydW4gdHJlZSBpbnN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Q29udGV4dFZhcihcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5ydW5UcmVlLCBrZXksIHZhbHVlKSB7XG4gICAgY29uc3QgY29udGV4dFZhcnMgPSBfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIGluIHJ1blRyZWVcbiAgICAgICAgPyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgcnVuVHJlZVtfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZXVxuICAgICAgICA6IHt9O1xuICAgIGNvbnRleHRWYXJzW2tleV0gPSB2YWx1ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJ1blRyZWVbX0xDX0NPTlRFWFRfVkFSSUFCTEVTX0tFWV0gPSBjb250ZXh0VmFycztcbn1cbiJdLCJuYW1lcyI6WyJfTENfQ09OVEVYVF9WQVJJQUJMRVNfS0VZIiwiZ2V0Q29udGV4dFZhciIsInJ1blRyZWUiLCJrZXkiLCJjb250ZXh0VmFycyIsInVuZGVmaW5lZCIsInNldENvbnRleHRWYXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/context_vars.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/env.js":
/*!**************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/env.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getEnv: () => (/* binding */ getEnv),\n/* harmony export */   getEnvironmentVariable: () => (/* binding */ getEnvironmentVariable),\n/* harmony export */   getLangSmithEnvVarsMetadata: () => (/* binding */ getLangSmithEnvVarsMetadata),\n/* harmony export */   getLangSmithEnvironmentVariable: () => (/* binding */ getLangSmithEnvironmentVariable),\n/* harmony export */   getLangSmithEnvironmentVariables: () => (/* binding */ getLangSmithEnvironmentVariables),\n/* harmony export */   getOtelEnabled: () => (/* binding */ getOtelEnabled),\n/* harmony export */   getRuntimeEnvironment: () => (/* binding */ getRuntimeEnvironment),\n/* harmony export */   getShas: () => (/* binding */ getShas),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   isDeno: () => (/* binding */ isDeno),\n/* harmony export */   isJsDom: () => (/* binding */ isJsDom),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isWebWorker: () => (/* binding */ isWebWorker),\n/* harmony export */   setEnvironmentVariable: () => (/* binding */ setEnvironmentVariable)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n// Inlined from https://github.com/flexdinesh/browser-or-node\n\nlet globalEnv;\nconst isBrowser = ()=> false && 0;\nconst isWebWorker = ()=>typeof globalThis === \"object\" && globalThis.constructor && globalThis.constructor.name === \"DedicatedWorkerGlobalScope\";\nconst isJsDom = ()=> false || typeof navigator !== \"undefined\" && navigator.userAgent.includes(\"jsdom\");\n// Supabase Edge Function provides a `Deno` global object\n// without `version` property\nconst isDeno = ()=>typeof Deno !== \"undefined\";\n// Mark not-as-node if in Supabase Edge Function\nconst isNode = ()=>typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\" && !isDeno();\nconst getEnv = ()=>{\n    if (globalEnv) {\n        return globalEnv;\n    }\n    // @ts-expect-error Bun types are not imported due to conflicts with Node types\n    if (typeof Bun !== \"undefined\") {\n        globalEnv = \"bun\";\n    } else if (isBrowser()) {\n        globalEnv = \"browser\";\n    } else if (isNode()) {\n        globalEnv = \"node\";\n    } else if (isWebWorker()) {\n        globalEnv = \"webworker\";\n    } else if (isJsDom()) {\n        globalEnv = \"jsdom\";\n    } else if (isDeno()) {\n        globalEnv = \"deno\";\n    } else {\n        globalEnv = \"other\";\n    }\n    return globalEnv;\n};\nlet runtimeEnvironment;\nfunction getRuntimeEnvironment() {\n    if (runtimeEnvironment === undefined) {\n        const env = getEnv();\n        const releaseEnv = getShas();\n        runtimeEnvironment = {\n            library: \"langsmith\",\n            runtime: env,\n            sdk: \"langsmith-js\",\n            sdk_version: _index_js__WEBPACK_IMPORTED_MODULE_0__.__version__,\n            ...releaseEnv\n        };\n    }\n    return runtimeEnvironment;\n}\n/**\n * Retrieves the LangSmith-specific metadata from the current runtime environment.\n *\n * @returns {Record<string, string>}\n *  - A record of LangSmith-specific metadata environment variables.\n */ function getLangSmithEnvVarsMetadata() {\n    const allEnvVars = getLangSmithEnvironmentVariables();\n    const envVars = {};\n    const excluded = [\n        \"LANGCHAIN_API_KEY\",\n        \"LANGCHAIN_ENDPOINT\",\n        \"LANGCHAIN_TRACING_V2\",\n        \"LANGCHAIN_PROJECT\",\n        \"LANGCHAIN_SESSION\",\n        \"LANGSMITH_API_KEY\",\n        \"LANGSMITH_ENDPOINT\",\n        \"LANGSMITH_TRACING_V2\",\n        \"LANGSMITH_PROJECT\",\n        \"LANGSMITH_SESSION\"\n    ];\n    for (const [key, value] of Object.entries(allEnvVars)){\n        if (typeof value === \"string\" && !excluded.includes(key) && !key.toLowerCase().includes(\"key\") && !key.toLowerCase().includes(\"secret\") && !key.toLowerCase().includes(\"token\")) {\n            if (key === \"LANGCHAIN_REVISION_ID\") {\n                envVars[\"revision_id\"] = value;\n            } else {\n                envVars[key] = value;\n            }\n        }\n    }\n    return envVars;\n}\n/**\n * Retrieves only the LangChain/LangSmith-prefixed environment variables from the current runtime environment.\n * This is more efficient than copying all environment variables.\n *\n * @returns {Record<string, string>}\n *  - A record of LangChain/LangSmith environment variables.\n */ function getLangSmithEnvironmentVariables() {\n    const envVars = {};\n    try {\n        // Check for Node.js environment\n        // eslint-disable-next-line no-process-env\n        if (typeof process !== \"undefined\" && process.env) {\n            // eslint-disable-next-line no-process-env\n            for (const [key, value] of Object.entries(process.env)){\n                if ((key.startsWith(\"LANGCHAIN_\") || key.startsWith(\"LANGSMITH_\")) && value != null) {\n                    if ((key.toLowerCase().includes(\"key\") || key.toLowerCase().includes(\"secret\") || key.toLowerCase().includes(\"token\")) && typeof value === \"string\") {\n                        envVars[key] = value.slice(0, 2) + \"*\".repeat(value.length - 4) + value.slice(-2);\n                    } else {\n                        envVars[key] = value;\n                    }\n                }\n            }\n        }\n    } catch (e) {\n    // Catch any errors that might occur while trying to access environment variables\n    }\n    return envVars;\n}\nfunction getEnvironmentVariable(name) {\n    // Certain Deno setups will throw an error if you try to access environment variables\n    // https://github.com/hwchase17/langchainjs/issues/1412\n    try {\n        return typeof process !== \"undefined\" ? process.env?.[name] : undefined;\n    } catch (e) {\n        return undefined;\n    }\n}\nfunction getLangSmithEnvironmentVariable(name) {\n    return getEnvironmentVariable(`LANGSMITH_${name}`) || getEnvironmentVariable(`LANGCHAIN_${name}`);\n}\nfunction setEnvironmentVariable(name, value) {\n    if (typeof process !== \"undefined\") {\n        // eslint-disable-next-line no-process-env\n        process.env[name] = value;\n    }\n}\nlet cachedCommitSHAs;\n/**\n * Get the Git commit SHA from common environment variables\n * used by different CI/CD platforms.\n * @returns {string | undefined} The Git commit SHA or undefined if not found.\n */ function getShas() {\n    if (cachedCommitSHAs !== undefined) {\n        return cachedCommitSHAs;\n    }\n    const common_release_envs = [\n        \"VERCEL_GIT_COMMIT_SHA\",\n        \"NEXT_PUBLIC_VERCEL_GIT_COMMIT_SHA\",\n        \"COMMIT_REF\",\n        \"RENDER_GIT_COMMIT\",\n        \"CI_COMMIT_SHA\",\n        \"CIRCLE_SHA1\",\n        \"CF_PAGES_COMMIT_SHA\",\n        \"REACT_APP_GIT_SHA\",\n        \"SOURCE_VERSION\",\n        \"GITHUB_SHA\",\n        \"TRAVIS_COMMIT\",\n        \"GIT_COMMIT\",\n        \"BUILD_VCS_NUMBER\",\n        \"bamboo_planRepository_revision\",\n        \"Build.SourceVersion\",\n        \"BITBUCKET_COMMIT\",\n        \"DRONE_COMMIT_SHA\",\n        \"SEMAPHORE_GIT_SHA\",\n        \"BUILDKITE_COMMIT\"\n    ];\n    const shas = {};\n    for (const env of common_release_envs){\n        const envVar = getEnvironmentVariable(env);\n        if (envVar !== undefined) {\n            shas[env] = envVar;\n        }\n    }\n    cachedCommitSHAs = shas;\n    return shas;\n}\nfunction getOtelEnabled() {\n    return getEnvironmentVariable(\"OTEL_ENABLED\") === \"true\" || getLangSmithEnvironmentVariable(\"OTEL_ENABLED\") === \"true\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUE2RDtBQUNuQjtBQUMxQyxJQUFJQztBQUNHLE1BQU1DLFlBQVksSUFBTSxNQUE2QixJQUFJLENBQXNDLENBQUM7QUFDaEcsTUFBTUcsY0FBYyxJQUFNLE9BQU9DLGVBQWUsWUFDbkRBLFdBQVdDLFdBQVcsSUFDdEJELFdBQVdDLFdBQVcsQ0FBQ0MsSUFBSSxLQUFLLDZCQUE2QjtBQUMxRCxNQUFNQyxVQUFVLElBQU0sTUFBMEQsSUFDbEYsT0FBT0MsY0FBYyxlQUFlQSxVQUFVQyxTQUFTLENBQUNDLFFBQVEsQ0FBQyxTQUFVO0FBQ2hGLHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDdEIsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFNBQVMsWUFBWTtBQUN4RCxnREFBZ0Q7QUFDekMsTUFBTUMsU0FBUyxJQUFNLE9BQU9DLFlBQVksZUFDM0MsT0FBT0EsUUFBUUMsUUFBUSxLQUFLLGVBQzVCLE9BQU9ELFFBQVFDLFFBQVEsQ0FBQ0MsSUFBSSxLQUFLLGVBQ2pDLENBQUNMLFNBQVM7QUFDUCxNQUFNTSxTQUFTO0lBQ2xCLElBQUlsQixXQUFXO1FBQ1gsT0FBT0E7SUFDWDtJQUNBLCtFQUErRTtJQUMvRSxJQUFJLE9BQU9tQixRQUFRLGFBQWE7UUFDNUJuQixZQUFZO0lBQ2hCLE9BQ0ssSUFBSUMsYUFBYTtRQUNsQkQsWUFBWTtJQUNoQixPQUNLLElBQUljLFVBQVU7UUFDZmQsWUFBWTtJQUNoQixPQUNLLElBQUlJLGVBQWU7UUFDcEJKLFlBQVk7SUFDaEIsT0FDSyxJQUFJUSxXQUFXO1FBQ2hCUixZQUFZO0lBQ2hCLE9BQ0ssSUFBSVksVUFBVTtRQUNmWixZQUFZO0lBQ2hCLE9BQ0s7UUFDREEsWUFBWTtJQUNoQjtJQUNBLE9BQU9BO0FBQ1gsRUFBRTtBQUNGLElBQUlvQjtBQUNHLFNBQVNDO0lBQ1osSUFBSUQsdUJB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LHFCQUFxQjFCLFdBQVc7UUFDaEMsT0FBTzBCO0lBQ1g7SUFDQSxNQUFNQyxzQkFBc0I7UUFDeEI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDSDtJQUNELE1BQU1DLE9BQU8sQ0FBQztJQUNkLEtBQUssTUFBTTNCLE9BQU8wQixvQkFBcUI7UUFDbkMsTUFBTUUsU0FBU04sdUJBQXVCdEI7UUFDdEMsSUFBSTRCLFdBQVc3QixXQUFXO1lBQ3RCNEIsSUFBSSxDQUFDM0IsSUFBSSxHQUFHNEI7UUFDaEI7SUFDSjtJQUNBSCxtQkFBbUJFO0lBQ25CLE9BQU9BO0FBQ1g7QUFDTyxTQUFTRTtJQUNaLE9BQVFQLHVCQUF1QixvQkFBb0IsVUFDL0NDLGdDQUFnQyxvQkFBb0I7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZW52LmpzP2E3NDAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW5saW5lZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mbGV4ZGluZXNoL2Jyb3dzZXItb3Itbm9kZVxuaW1wb3J0IHsgX192ZXJzaW9uX18gfSBmcm9tIFwiLi4vaW5kZXguanNcIjtcbmxldCBnbG9iYWxFbnY7XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKCkgPT4gdHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIgJiZcbiAgICBnbG9iYWxUaGlzLmNvbnN0cnVjdG9yICYmXG4gICAgZ2xvYmFsVGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkRlZGljYXRlZFdvcmtlckdsb2JhbFNjb3BlXCI7XG5leHBvcnQgY29uc3QgaXNKc0RvbSA9ICgpID0+ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5uYW1lID09PSBcIm5vZGVqc1wiKSB8fFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJqc2RvbVwiKSk7XG4vLyBTdXBhYmFzZSBFZGdlIEZ1bmN0aW9uIHByb3ZpZGVzIGEgYERlbm9gIGdsb2JhbCBvYmplY3Rcbi8vIHdpdGhvdXQgYHZlcnNpb25gIHByb3BlcnR5XG5leHBvcnQgY29uc3QgaXNEZW5vID0gKCkgPT4gdHlwZW9mIERlbm8gIT09IFwidW5kZWZpbmVkXCI7XG4vLyBNYXJrIG5vdC1hcy1ub2RlIGlmIGluIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25cbmV4cG9ydCBjb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICFpc0Rlbm8oKTtcbmV4cG9ydCBjb25zdCBnZXRFbnYgPSAoKSA9PiB7XG4gICAgaWYgKGdsb2JhbEVudikge1xuICAgICAgICByZXR1cm4gZ2xvYmFsRW52O1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEJ1biB0eXBlcyBhcmUgbm90IGltcG9ydGVkIGR1ZSB0byBjb25mbGljdHMgd2l0aCBOb2RlIHR5cGVzXG4gICAgaWYgKHR5cGVvZiBCdW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJidW5cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJicm93c2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTm9kZSgpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwibm9kZVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1dlYldvcmtlcigpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwid2Vid29ya2VyXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzSnNEb20oKSkge1xuICAgICAgICBnbG9iYWxFbnYgPSBcImpzZG9tXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGVubygpKSB7XG4gICAgICAgIGdsb2JhbEVudiA9IFwiZGVub1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2xvYmFsRW52ID0gXCJvdGhlclwiO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsRW52O1xufTtcbmxldCBydW50aW1lRW52aXJvbm1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVudGltZUVudmlyb25tZW50KCkge1xuICAgIGlmIChydW50aW1lRW52aXJvbm1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnYgPSBnZXRFbnYoKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUVudiA9IGdldFNoYXMoKTtcbiAgICAgICAgcnVudGltZUVudmlyb25tZW50ID0ge1xuICAgICAgICAgICAgbGlicmFyeTogXCJsYW5nc21pdGhcIixcbiAgICAgICAgICAgIHJ1bnRpbWU6IGVudixcbiAgICAgICAgICAgIHNkazogXCJsYW5nc21pdGgtanNcIixcbiAgICAgICAgICAgIHNka192ZXJzaW9uOiBfX3ZlcnNpb25fXyxcbiAgICAgICAgICAgIC4uLnJlbGVhc2VFbnYsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBydW50aW1lRW52aXJvbm1lbnQ7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgTGFuZ1NtaXRoLXNwZWNpZmljIG1ldGFkYXRhIGZyb20gdGhlIGN1cnJlbnQgcnVudGltZSBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdTbWl0aC1zcGVjaWZpYyBtZXRhZGF0YSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEoKSB7XG4gICAgY29uc3QgYWxsRW52VmFycyA9IGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGVzKCk7XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIGNvbnN0IGV4Y2x1ZGVkID0gW1xuICAgICAgICBcIkxBTkdDSEFJTl9BUElfS0VZXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX0VORFBPSU5UXCIsXG4gICAgICAgIFwiTEFOR0NIQUlOX1RSQUNJTkdfVjJcIixcbiAgICAgICAgXCJMQU5HQ0hBSU5fUFJPSkVDVFwiLFxuICAgICAgICBcIkxBTkdDSEFJTl9TRVNTSU9OXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX0FQSV9LRVlcIixcbiAgICAgICAgXCJMQU5HU01JVEhfRU5EUE9JTlRcIixcbiAgICAgICAgXCJMQU5HU01JVEhfVFJBQ0lOR19WMlwiLFxuICAgICAgICBcIkxBTkdTTUlUSF9QUk9KRUNUXCIsXG4gICAgICAgIFwiTEFOR1NNSVRIX1NFU1NJT05cIixcbiAgICBdO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbEVudlZhcnMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICFleGNsdWRlZC5pbmNsdWRlcyhrZXkpICYmXG4gICAgICAgICAgICAha2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgJiZcbiAgICAgICAgICAgICFrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlY3JldFwiKSAmJlxuICAgICAgICAgICAgIWtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidG9rZW5cIikpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiTEFOR0NIQUlOX1JFVklTSU9OX0lEXCIpIHtcbiAgICAgICAgICAgICAgICBlbnZWYXJzW1wicmV2aXNpb25faWRcIl0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVudlZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgb25seSB0aGUgTGFuZ0NoYWluL0xhbmdTbWl0aC1wcmVmaXhlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZnJvbSB0aGUgY3VycmVudCBydW50aW1lIGVudmlyb25tZW50LlxuICogVGhpcyBpcyBtb3JlIGVmZmljaWVudCB0aGFuIGNvcHlpbmcgYWxsIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqICAtIEEgcmVjb3JkIG9mIExhbmdDaGFpbi9MYW5nU21pdGggZW52aXJvbm1lbnQgdmFyaWFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZXMoKSB7XG4gICAgY29uc3QgZW52VmFycyA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvY2Vzcy5lbnYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKChrZXkuc3RhcnRzV2l0aChcIkxBTkdDSEFJTl9cIikgfHwga2V5LnN0YXJ0c1dpdGgoXCJMQU5HU01JVEhfXCIpKSAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoa2V5LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJrZXlcIikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwic2VjcmV0XCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRva2VuXCIpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnZWYXJzW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnNsaWNlKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIqXCIucmVwZWF0KHZhbHVlLmxlbmd0aCAtIDQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoLTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW52VmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQ2F0Y2ggYW55IGVycm9ycyB0aGF0IG1pZ2h0IG9jY3VyIHdoaWxlIHRyeWluZyB0byBhY2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgfVxuICAgIHJldHVybiBlbnZWYXJzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudmlyb25tZW50VmFyaWFibGUobmFtZSkge1xuICAgIC8vIENlcnRhaW4gRGVubyBzZXR1cHMgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiB5b3UgdHJ5IHRvIGFjY2VzcyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaHdjaGFzZTE3L2xhbmdjaGFpbmpzL2lzc3Vlcy8xNDEyXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWVudlxuICAgICAgICAgICAgICAgIHByb2Nlc3MuZW52Py5bbmFtZV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlKG5hbWUpIHtcbiAgICByZXR1cm4gKGdldEVudmlyb25tZW50VmFyaWFibGUoYExBTkdTTUlUSF8ke25hbWV9YCkgfHxcbiAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShgTEFOR0NIQUlOXyR7bmFtZX1gKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2V0RW52aXJvbm1lbnRWYXJpYWJsZShuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1lbnZcbiAgICAgICAgcHJvY2Vzcy5lbnZbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59XG5sZXQgY2FjaGVkQ29tbWl0U0hBcztcbi8qKlxuICogR2V0IHRoZSBHaXQgY29tbWl0IFNIQSBmcm9tIGNvbW1vbiBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqIHVzZWQgYnkgZGlmZmVyZW50IENJL0NEIHBsYXRmb3Jtcy5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IFRoZSBHaXQgY29tbWl0IFNIQSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hhcygpIHtcbiAgICBpZiAoY2FjaGVkQ29tbWl0U0hBcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRDb21taXRTSEFzO1xuICAgIH1cbiAgICBjb25zdCBjb21tb25fcmVsZWFzZV9lbnZzID0gW1xuICAgICAgICBcIlZFUkNFTF9HSVRfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIk5FWFRfUFVCTElDX1ZFUkNFTF9HSVRfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIkNPTU1JVF9SRUZcIixcbiAgICAgICAgXCJSRU5ERVJfR0lUX0NPTU1JVFwiLFxuICAgICAgICBcIkNJX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJDSVJDTEVfU0hBMVwiLFxuICAgICAgICBcIkNGX1BBR0VTX0NPTU1JVF9TSEFcIixcbiAgICAgICAgXCJSRUFDVF9BUFBfR0lUX1NIQVwiLFxuICAgICAgICBcIlNPVVJDRV9WRVJTSU9OXCIsXG4gICAgICAgIFwiR0lUSFVCX1NIQVwiLFxuICAgICAgICBcIlRSQVZJU19DT01NSVRcIixcbiAgICAgICAgXCJHSVRfQ09NTUlUXCIsXG4gICAgICAgIFwiQlVJTERfVkNTX05VTUJFUlwiLFxuICAgICAgICBcImJhbWJvb19wbGFuUmVwb3NpdG9yeV9yZXZpc2lvblwiLFxuICAgICAgICBcIkJ1aWxkLlNvdXJjZVZlcnNpb25cIixcbiAgICAgICAgXCJCSVRCVUNLRVRfQ09NTUlUXCIsXG4gICAgICAgIFwiRFJPTkVfQ09NTUlUX1NIQVwiLFxuICAgICAgICBcIlNFTUFQSE9SRV9HSVRfU0hBXCIsXG4gICAgICAgIFwiQlVJTERLSVRFX0NPTU1JVFwiLFxuICAgIF07XG4gICAgY29uc3Qgc2hhcyA9IHt9O1xuICAgIGZvciAoY29uc3QgZW52IG9mIGNvbW1vbl9yZWxlYXNlX2VudnMpIHtcbiAgICAgICAgY29uc3QgZW52VmFyID0gZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShlbnYpO1xuICAgICAgICBpZiAoZW52VmFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNoYXNbZW52XSA9IGVudlZhcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZWRDb21taXRTSEFzID0gc2hhcztcbiAgICByZXR1cm4gc2hhcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRPdGVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gKGdldEVudmlyb25tZW50VmFyaWFibGUoXCJPVEVMX0VOQUJMRURcIikgPT09IFwidHJ1ZVwiIHx8XG4gICAgICAgIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUoXCJPVEVMX0VOQUJMRURcIikgPT09IFwidHJ1ZVwiKTtcbn1cbiJdLCJuYW1lcyI6WyJfX3ZlcnNpb25fXyIsImdsb2JhbEVudiIsImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwiaXNXZWJXb3JrZXIiLCJnbG9iYWxUaGlzIiwiY29uc3RydWN0b3IiLCJuYW1lIiwiaXNKc0RvbSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluY2x1ZGVzIiwiaXNEZW5vIiwiRGVubyIsImlzTm9kZSIsInByb2Nlc3MiLCJ2ZXJzaW9ucyIsIm5vZGUiLCJnZXRFbnYiLCJCdW4iLCJydW50aW1lRW52aXJvbm1lbnQiLCJnZXRSdW50aW1lRW52aXJvbm1lbnQiLCJ1bmRlZmluZWQiLCJlbnYiLCJyZWxlYXNlRW52IiwiZ2V0U2hhcyIsImxpYnJhcnkiLCJydW50aW1lIiwic2RrIiwic2RrX3ZlcnNpb24iLCJnZXRMYW5nU21pdGhFbnZWYXJzTWV0YWRhdGEiLCJhbGxFbnZWYXJzIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZXMiLCJlbnZWYXJzIiwiZXhjbHVkZWQiLCJrZXkiLCJ2YWx1ZSIsIk9iamVjdCIsImVudHJpZXMiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInJlcGVhdCIsImxlbmd0aCIsImUiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsInNldEVudmlyb25tZW50VmFyaWFibGUiLCJjYWNoZWRDb21taXRTSEFzIiwiY29tbW9uX3JlbGVhc2VfZW52cyIsInNoYXMiLCJlbnZWYXIiLCJnZXRPdGVsRW5hYmxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/error.js":
/*!****************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/error.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConflictingEndpointsError: () => (/* binding */ ConflictingEndpointsError),\n/* harmony export */   LangSmithConflictError: () => (/* binding */ LangSmithConflictError),\n/* harmony export */   LangSmithNotFoundError: () => (/* binding */ LangSmithNotFoundError),\n/* harmony export */   isConflictingEndpointsError: () => (/* binding */ isConflictingEndpointsError),\n/* harmony export */   isLangSmithNotFoundError: () => (/* binding */ isLangSmithNotFoundError),\n/* harmony export */   printErrorStackTrace: () => (/* binding */ printErrorStackTrace),\n/* harmony export */   raiseForStatus: () => (/* binding */ raiseForStatus)\n/* harmony export */ });\nfunction getErrorStackTrace(e) {\n    if (typeof e !== \"object\" || e == null) return undefined;\n    if (!(\"stack\" in e) || typeof e.stack !== \"string\") return undefined;\n    let stack = e.stack;\n    const prevLine = `${e}`;\n    if (stack.startsWith(prevLine)) {\n        stack = stack.slice(prevLine.length);\n    }\n    if (stack.startsWith(\"\\n\")) {\n        stack = stack.slice(1);\n    }\n    return stack;\n}\nfunction printErrorStackTrace(e) {\n    const stack = getErrorStackTrace(e);\n    if (stack == null) return;\n    console.error(stack);\n}\n/**\n * LangSmithConflictError\n *\n * Represents an error that occurs when there's a conflict during an operation,\n * typically corresponding to HTTP 409 status code responses.\n *\n * This error is thrown when an attempt to create or modify a resource conflicts\n * with the current state of the resource on the server. Common scenarios include:\n * - Attempting to create a resource that already exists\n * - Trying to update a resource that has been modified by another process\n * - Violating a uniqueness constraint in the data\n *\n * @extends Error\n *\n * @example\n * try {\n *   await createProject(\"existingProject\");\n * } catch (error) {\n *   if (error instanceof ConflictError) {\n *     console.log(\"A conflict occurred:\", error.message);\n *     // Handle the conflict, e.g., by suggesting a different project name\n *   } else {\n *     // Handle other types of errors\n *   }\n * }\n *\n * @property {string} name - Always set to 'ConflictError' for easy identification\n * @property {string} message - Detailed error message including server response\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\n */ class LangSmithConflictError extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithConflictError\";\n        this.status = 409;\n    }\n}\n/**\n * LangSmithNotFoundError\n *\n * Represents an error that occurs when a requested resource is not found,\n * typically corresponding to HTTP 404 status code responses.\n *\n * @extends Error\n */ class LangSmithNotFoundError extends Error {\n    constructor(message){\n        super(message);\n        Object.defineProperty(this, \"status\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = \"LangSmithNotFoundError\";\n        this.status = 404;\n    }\n}\nfunction isLangSmithNotFoundError(error) {\n    return error != null && typeof error === \"object\" && \"name\" in error && error?.name === \"LangSmithNotFoundError\";\n}\n/**\n * Throws an appropriate error based on the response status and body.\n *\n * @param response - The fetch Response object\n * @param context - Additional context to include in the error message (e.g., operation being performed)\n * @throws {LangSmithConflictError} When the response status is 409\n * @throws {Error} For all other non-ok responses\n */ async function raiseForStatus(response, context, consumeOnSuccess) {\n    let errorBody;\n    if (response.ok) {\n        // consume the response body to release the connection\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        if (consumeOnSuccess) {\n            errorBody = await response.text();\n        }\n        return;\n    }\n    if (response.status === 403) {\n        try {\n            const errorData = await response.json();\n            const errorCode = errorData?.error;\n            if (errorCode === \"org_scoped_key_requires_workspace\") {\n                errorBody = \"This API key is org-scoped and requires workspace specification. \" + \"Please provide 'workspaceId' parameter, \" + \"or set LANGSMITH_WORKSPACE_ID environment variable.\";\n            }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e) {\n            const errorWithStatus = new Error(`${response.status} ${response.statusText}`);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            errorWithStatus.status = response?.status;\n            throw errorWithStatus;\n        }\n    }\n    if (errorBody === undefined) {\n        try {\n            errorBody = await response.text();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e) {\n            errorBody = \"\";\n        }\n    }\n    const fullMessage = `Failed to ${context}. Received status [${response.status}]: ${response.statusText}. Message: ${errorBody}`;\n    if (response.status === 404) {\n        throw new LangSmithNotFoundError(fullMessage);\n    }\n    if (response.status === 409) {\n        throw new LangSmithConflictError(fullMessage);\n    }\n    const err = new Error(fullMessage);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    err.status = response.status;\n    throw err;\n}\nconst ERR_CONFLICTING_ENDPOINTS = \"ERR_CONFLICTING_ENDPOINTS\";\nclass ConflictingEndpointsError extends Error {\n    constructor(){\n        super(\"You cannot provide both LANGSMITH_ENDPOINT / LANGCHAIN_ENDPOINT \" + \"and LANGSMITH_RUNS_ENDPOINTS.\");\n        Object.defineProperty(this, \"code\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: ERR_CONFLICTING_ENDPOINTS\n        });\n        this.name = \"ConflictingEndpointsError\"; // helpful in logs\n    }\n}\nfunction isConflictingEndpointsError(err) {\n    return typeof err === \"object\" && err !== null && err.code === ERR_CONFLICTING_ENDPOINTS;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLFNBQVNBLG1CQUFtQkMsQ0FBQztJQUN6QixJQUFJLE9BQU9BLE1BQU0sWUFBWUEsS0FBSyxNQUM5QixPQUFPQztJQUNYLElBQUksQ0FBRSxZQUFXRCxDQUFBQSxLQUFNLE9BQU9BLEVBQUVFLEtBQUssS0FBSyxVQUN0QyxPQUFPRDtJQUNYLElBQUlDLFFBQVFGLEVBQUVFLEtBQUs7SUFDbkIsTUFBTUMsV0FBVyxDQUFDLEVBQUVILEVBQUUsQ0FBQztJQUN2QixJQUFJRSxNQUFNRSxVQUFVLENBQUNELFdBQVc7UUFDNUJELFFBQVFBLE1BQU1HLEtBQUssQ0FBQ0YsU0FBU0csTUFBTTtJQUN2QztJQUNBLElBQUlKLE1BQU1FLFVBQVUsQ0FBQyxPQUFPO1FBQ3hCRixRQUFRQSxNQUFNRyxLQUFLLENBQUM7SUFDeEI7SUFDQSxPQUFPSDtBQUNYO0FBQ08sU0FBU0sscUJBQXFCUCxDQUFDO0lBQ2xDLE1BQU1FLFFBQVFILG1CQUFtQkM7SUFDakMsSUFBSUUsU0FBUyxNQUNUO0lBQ0pNLFFBQVFDLEtBQUssQ0FBQ1A7QUFDbEI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ00sTUFBTVEsK0JBQStCQztJQUN4Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQSxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2xCO0FBQ0o7QUFDQTs7Ozs7OztDQU9DLEdBQ00sTUFBTUMsK0JBQStCWDtJQUN4Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTkMsT0FBT0MsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVO1lBQ2xDQyxZQUFZO1lBQ1pDLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxPQUFPLEtBQUs7UUFDaEI7UUFDQSxJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsTUFBTSxHQUFHO0lBQ2xCO0FBQ0o7QUFDTyxTQUFTRSx5QkFBeUJkLEtBQUs7SUFDMUMsT0FBUUEsU0FBUyxRQUNiLE9BQU9BLFVBQVUsWUFDakIsVUFBVUEsU0FDVkEsT0FBT1csU0FBUztBQUN4QjtBQUNBOzs7Ozs7O0NBT0MsR0FDTSxlQUFlSSxlQUFlQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsZ0JBQWdCO0lBQ3BFLElBQUlDO0lBQ0osSUFBSUgsU0FBU0ksRUFBRSxFQUFFO1FBQ2Isc0RBQXNEO1FBQ3RELHFEQUFxRDtRQUNyRCxJQUFJRixrQkFBa0I7WUFDbEJDLFlBQVksTUFBTUgsU0FBU0ssSUFBSTtRQUNuQztRQUNBO0lBQ0o7SUFDQSxJQUFJTCxTQUFTSixNQUFNLEtBQUssS0FBSztRQUN6QixJQUFJO1lBQ0EsTUFBTVUsWUFBWSxNQUFNTixTQUFTTyxJQUFJO1lBQ3JDLE1BQU1DLFlBQVlGLFdBQVd0QjtZQUM3QixJQUFJd0IsY0FBYyxxQ0FBcUM7Z0JBQ25ETCxZQUNJLHNFQUNJLDZDQUNBO1lBQ1o7UUFDQSw4REFBOEQ7UUFDbEUsRUFDQSxPQUFPNUIsR0FBRztZQUNOLE1BQU1rQyxrQkFBa0IsSUFBSXZCLE1BQU0sQ0FBQyxFQUFFYyxTQUFTSixNQUFNLENBQUMsQ0FBQyxFQUFFSSxTQUFTVSxVQUFVLENBQUMsQ0FBQztZQUM3RSw4REFBOEQ7WUFDOURELGdCQUFnQmIsTUFBTSxHQUFHSSxVQUFVSjtZQUNuQyxNQUFNYTtRQUNWO0lBQ0o7SUFDQSxJQUFJTixjQUFjM0IsV0FBVztRQUN6QixJQUFJO1lBQ0EyQixZQUFZLE1BQU1ILFNBQVNLLElBQUk7UUFDL0IsOERBQThEO1FBQ2xFLEVBQ0EsT0FBTzlCLEdBQUc7WUFDTjRCLFlBQVk7UUFDaEI7SUFDSjtJQUNBLE1BQU1RLGNBQWMsQ0FBQyxVQUFVLEVBQUVWLFFBQVEsbUJBQW1CLEVBQUVELFNBQVNKLE1BQU0sQ0FBQyxHQUFHLEVBQUVJLFNBQVNVLFVBQVUsQ0FBQyxXQUFXLEVBQUVQLFVBQVUsQ0FBQztJQUMvSCxJQUFJSCxTQUFTSixNQUFNLEtBQUssS0FBSztRQUN6QixNQUFNLElBQUlDLHVCQUF1QmM7SUFDckM7SUFDQSxJQUFJWCxTQUFTSixNQUFNLEtBQUssS0FBSztRQUN6QixNQUFNLElBQUlYLHVCQUF1QjBCO0lBQ3JDO0lBQ0EsTUFBTUMsTUFBTSxJQUFJMUIsTUFBTXlCO0lBQ3RCLDhEQUE4RDtJQUM5REMsSUFBSWhCLE1BQU0sR0FBR0ksU0FBU0osTUFBTTtJQUM1QixNQUFNZ0I7QUFDVjtBQUNBLE1BQU1DLDRCQUE0QjtBQUMzQixNQUFNQyxrQ0FBa0M1QjtJQUMzQ0MsYUFBYztRQUNWLEtBQUssQ0FBQyxxRUFDRjtRQUNKRSxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFFBQVE7WUFDaENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLE9BQU9tQjtRQUNYO1FBQ0EsSUFBSSxDQUFDbEIsSUFBSSxHQUFHLDZCQUE2QixrQkFBa0I7SUFDL0Q7QUFDSjtBQUNPLFNBQVNvQiw0QkFBNEJILEdBQUc7SUFDM0MsT0FBUSxPQUFPQSxRQUFRLFlBQ25CQSxRQUFRLFFBQ1JBLElBQUlJLElBQUksS0FBS0g7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZXJyb3IuanM/Njc4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBnZXRFcnJvclN0YWNrVHJhY2UoZSkge1xuICAgIGlmICh0eXBlb2YgZSAhPT0gXCJvYmplY3RcIiB8fCBlID09IG51bGwpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCEoXCJzdGFja1wiIGluIGUpIHx8IHR5cGVvZiBlLnN0YWNrICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGxldCBzdGFjayA9IGUuc3RhY2s7XG4gICAgY29uc3QgcHJldkxpbmUgPSBgJHtlfWA7XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgocHJldkxpbmUpKSB7XG4gICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UocHJldkxpbmUubGVuZ3RoKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrLnN0YXJ0c1dpdGgoXCJcXG5cIikpIHtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByaW50RXJyb3JTdGFja1RyYWNlKGUpIHtcbiAgICBjb25zdCBzdGFjayA9IGdldEVycm9yU3RhY2tUcmFjZShlKTtcbiAgICBpZiAoc3RhY2sgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUuZXJyb3Ioc3RhY2spO1xufVxuLyoqXG4gKiBMYW5nU21pdGhDb25mbGljdEVycm9yXG4gKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IG9jY3VycyB3aGVuIHRoZXJlJ3MgYSBjb25mbGljdCBkdXJpbmcgYW4gb3BlcmF0aW9uLFxuICogdHlwaWNhbGx5IGNvcnJlc3BvbmRpbmcgdG8gSFRUUCA0MDkgc3RhdHVzIGNvZGUgcmVzcG9uc2VzLlxuICpcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gYXR0ZW1wdCB0byBjcmVhdGUgb3IgbW9kaWZ5IGEgcmVzb3VyY2UgY29uZmxpY3RzXG4gKiB3aXRoIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSByZXNvdXJjZSBvbiB0aGUgc2VydmVyLiBDb21tb24gc2NlbmFyaW9zIGluY2x1ZGU6XG4gKiAtIEF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgcmVzb3VyY2UgdGhhdCBhbHJlYWR5IGV4aXN0c1xuICogLSBUcnlpbmcgdG8gdXBkYXRlIGEgcmVzb3VyY2UgdGhhdCBoYXMgYmVlbiBtb2RpZmllZCBieSBhbm90aGVyIHByb2Nlc3NcbiAqIC0gVmlvbGF0aW5nIGEgdW5pcXVlbmVzcyBjb25zdHJhaW50IGluIHRoZSBkYXRhXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgYXdhaXQgY3JlYXRlUHJvamVjdChcImV4aXN0aW5nUHJvamVjdFwiKTtcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbmZsaWN0RXJyb3IpIHtcbiAqICAgICBjb25zb2xlLmxvZyhcIkEgY29uZmxpY3Qgb2NjdXJyZWQ6XCIsIGVycm9yLm1lc3NhZ2UpO1xuICogICAgIC8vIEhhbmRsZSB0aGUgY29uZmxpY3QsIGUuZy4sIGJ5IHN1Z2dlc3RpbmcgYSBkaWZmZXJlbnQgcHJvamVjdCBuYW1lXG4gKiAgIH0gZWxzZSB7XG4gKiAgICAgLy8gSGFuZGxlIG90aGVyIHR5cGVzIG9mIGVycm9yc1xuICogICB9XG4gKiB9XG4gKlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBBbHdheXMgc2V0IHRvICdDb25mbGljdEVycm9yJyBmb3IgZWFzeSBpZGVudGlmaWNhdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBEZXRhaWxlZCBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyBzZXJ2ZXIgcmVzcG9uc2VcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwOVxuICovXG5leHBvcnQgY2xhc3MgTGFuZ1NtaXRoQ29uZmxpY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0dXNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJMYW5nU21pdGhDb25mbGljdEVycm9yXCI7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gNDA5O1xuICAgIH1cbn1cbi8qKlxuICogTGFuZ1NtaXRoTm90Rm91bmRFcnJvclxuICpcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBvY2N1cnMgd2hlbiBhIHJlcXVlc3RlZCByZXNvdXJjZSBpcyBub3QgZm91bmQsXG4gKiB0eXBpY2FsbHkgY29ycmVzcG9uZGluZyB0byBIVFRQIDQwNCBzdGF0dXMgY29kZSByZXNwb25zZXMuXG4gKlxuICogQGV4dGVuZHMgRXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIExhbmdTbWl0aE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhdHVzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTGFuZ1NtaXRoTm90Rm91bmRFcnJvclwiO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDQwNDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMYW5nU21pdGhOb3RGb3VuZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIChlcnJvciAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBcIm5hbWVcIiBpbiBlcnJvciAmJlxuICAgICAgICBlcnJvcj8ubmFtZSA9PT0gXCJMYW5nU21pdGhOb3RGb3VuZEVycm9yXCIpO1xufVxuLyoqXG4gKiBUaHJvd3MgYW4gYXBwcm9wcmlhdGUgZXJyb3IgYmFzZWQgb24gdGhlIHJlc3BvbnNlIHN0YXR1cyBhbmQgYm9keS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgZmV0Y2ggUmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCB0byBpbmNsdWRlIGluIHRoZSBlcnJvciBtZXNzYWdlIChlLmcuLCBvcGVyYXRpb24gYmVpbmcgcGVyZm9ybWVkKVxuICogQHRocm93cyB7TGFuZ1NtaXRoQ29uZmxpY3RFcnJvcn0gV2hlbiB0aGUgcmVzcG9uc2Ugc3RhdHVzIGlzIDQwOVxuICogQHRocm93cyB7RXJyb3J9IEZvciBhbGwgb3RoZXIgbm9uLW9rIHJlc3BvbnNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmFpc2VGb3JTdGF0dXMocmVzcG9uc2UsIGNvbnRleHQsIGNvbnN1bWVPblN1Y2Nlc3MpIHtcbiAgICBsZXQgZXJyb3JCb2R5O1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAvLyBjb25zdW1lIHRoZSByZXNwb25zZSBib2R5IHRvIHJlbGVhc2UgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gaHR0cHM6Ly91bmRpY2kubm9kZWpzLm9yZy8jLz9pZD1nYXJiYWdlLWNvbGxlY3Rpb25cbiAgICAgICAgaWYgKGNvbnN1bWVPblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3JEYXRhPy5lcnJvcjtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IFwib3JnX3Njb3BlZF9rZXlfcmVxdWlyZXNfd29ya3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICBlcnJvckJvZHkgPVxuICAgICAgICAgICAgICAgICAgICBcIlRoaXMgQVBJIGtleSBpcyBvcmctc2NvcGVkIGFuZCByZXF1aXJlcyB3b3Jrc3BhY2Ugc3BlY2lmaWNhdGlvbi4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJQbGVhc2UgcHJvdmlkZSAnd29ya3NwYWNlSWQnIHBhcmFtZXRlciwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJvciBzZXQgTEFOR1NNSVRIX1dPUktTUEFDRV9JRCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yV2l0aFN0YXR1cyA9IG5ldyBFcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBlcnJvcldpdGhTdGF0dXMuc3RhdHVzID0gcmVzcG9uc2U/LnN0YXR1cztcbiAgICAgICAgICAgIHRocm93IGVycm9yV2l0aFN0YXR1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3JCb2R5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yQm9keSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZnVsbE1lc3NhZ2UgPSBgRmFpbGVkIHRvICR7Y29udGV4dH0uIFJlY2VpdmVkIHN0YXR1cyBbJHtyZXNwb25zZS5zdGF0dXN9XTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fS4gTWVzc2FnZTogJHtlcnJvckJvZHl9YDtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IExhbmdTbWl0aE5vdEZvdW5kRXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHtcbiAgICAgICAgdGhyb3cgbmV3IExhbmdTbWl0aENvbmZsaWN0RXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoZnVsbE1lc3NhZ2UpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZXJyLnN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICB0aHJvdyBlcnI7XG59XG5jb25zdCBFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTID0gXCJFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTXCI7XG5leHBvcnQgY2xhc3MgQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoXCJZb3UgY2Fubm90IHByb3ZpZGUgYm90aCBMQU5HU01JVEhfRU5EUE9JTlQgLyBMQU5HQ0hBSU5fRU5EUE9JTlQgXCIgK1xuICAgICAgICAgICAgXCJhbmQgTEFOR1NNSVRIX1JVTlNfRU5EUE9JTlRTLlwiKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UU1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJDb25mbGljdGluZ0VuZHBvaW50c0Vycm9yXCI7IC8vIGhlbHBmdWwgaW4gbG9nc1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbmZsaWN0aW5nRW5kcG9pbnRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGVyciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnIuY29kZSA9PT0gRVJSX0NPTkZMSUNUSU5HX0VORFBPSU5UUyk7XG59XG4iXSwibmFtZXMiOlsiZ2V0RXJyb3JTdGFja1RyYWNlIiwiZSIsInVuZGVmaW5lZCIsInN0YWNrIiwicHJldkxpbmUiLCJzdGFydHNXaXRoIiwic2xpY2UiLCJsZW5ndGgiLCJwcmludEVycm9yU3RhY2tUcmFjZSIsImNvbnNvbGUiLCJlcnJvciIsIkxhbmdTbWl0aENvbmZsaWN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJuYW1lIiwic3RhdHVzIiwiTGFuZ1NtaXRoTm90Rm91bmRFcnJvciIsImlzTGFuZ1NtaXRoTm90Rm91bmRFcnJvciIsInJhaXNlRm9yU3RhdHVzIiwicmVzcG9uc2UiLCJjb250ZXh0IiwiY29uc3VtZU9uU3VjY2VzcyIsImVycm9yQm9keSIsIm9rIiwidGV4dCIsImVycm9yRGF0YSIsImpzb24iLCJlcnJvckNvZGUiLCJlcnJvcldpdGhTdGF0dXMiLCJzdGF0dXNUZXh0IiwiZnVsbE1lc3NhZ2UiLCJlcnIiLCJFUlJfQ09ORkxJQ1RJTkdfRU5EUE9JTlRTIiwiQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciIsImlzQ29uZmxpY3RpbmdFbmRwb2ludHNFcnJvciIsImNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var _utils_env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n/* eslint-disable */ // @ts-nocheck\n\nvar LIMIT_REPLACE_NODE = \"[...]\";\nvar CIRCULAR_REPLACE_NODE = {\n    result: \"[Circular]\"\n};\nvar arr = [];\nvar replacerStack = [];\nconst encoder = new TextEncoder();\nfunction defaultOptions() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\nfunction encodeString(str) {\n    return encoder.encode(str);\n}\n// Shared function to handle well-known types\nfunction serializeWellKnownTypes(val) {\n    if (val && typeof val === \"object\" && val !== null) {\n        if (val instanceof Map) {\n            return Object.fromEntries(val);\n        } else if (val instanceof Set) {\n            return Array.from(val);\n        } else if (val instanceof Date) {\n            return val.toISOString();\n        } else if (val instanceof RegExp) {\n            return val.toString();\n        } else if (val instanceof Error) {\n            return {\n                name: val.name,\n                message: val.message\n            };\n        }\n    } else if (typeof val === \"bigint\") {\n        return val.toString();\n    }\n    return val;\n}\n// Default replacer function to handle well-known types\nfunction createDefaultReplacer(userReplacer) {\n    return function(key, val) {\n        // Apply user replacer first if provided\n        if (userReplacer) {\n            const userResult = userReplacer.call(this, key, val);\n            // If user replacer returned undefined, fall back to our serialization\n            if (userResult !== undefined) {\n                return userResult;\n            }\n        }\n        // Fall back to our well-known type handling\n        return serializeWellKnownTypes(val);\n    };\n}\n// Regular stringify\nfunction serialize(obj, errorContext, replacer, spacer, options) {\n    try {\n        const str = JSON.stringify(obj, createDefaultReplacer(replacer), spacer);\n        return encodeString(str);\n    } catch (e) {\n        // Fall back to more complex stringify if circular reference\n        if (!e.message?.includes(\"Converting circular structure to JSON\")) {\n            console.warn(`[WARNING]: LangSmith received unserializable value.${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n            return encodeString(\"[Unserializable]\");\n        }\n        (0,_utils_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"SUPPRESS_CIRCULAR_JSON_WARNINGS\") !== \"true\" && console.warn(`[WARNING]: LangSmith received circular JSON. This will decrease tracer performance. ${errorContext ? `\\nContext: ${errorContext}` : \"\"}`);\n        if (typeof options === \"undefined\") {\n            options = defaultOptions();\n        }\n        decirc(obj, \"\", 0, [], undefined, 0, options);\n        let res;\n        try {\n            if (replacerStack.length === 0) {\n                res = JSON.stringify(obj, replacer, spacer);\n            } else {\n                res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);\n            }\n        } catch (_) {\n            return encodeString(\"[unable to serialize, circular reference is too complex to analyze]\");\n        } finally{\n            while(arr.length !== 0){\n                const part = arr.pop();\n                if (part.length === 4) {\n                    Object.defineProperty(part[0], part[1], part[3]);\n                } else {\n                    part[0][part[1]] = part[2];\n                }\n            }\n        }\n        return encodeString(res);\n    }\n}\nfunction setReplace(replace, val, k, parent) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);\n    if (propertyDescriptor.get !== undefined) {\n        if (propertyDescriptor.configurable) {\n            Object.defineProperty(parent, k, {\n                value: replace\n            });\n            arr.push([\n                parent,\n                k,\n                val,\n                propertyDescriptor\n            ]);\n        } else {\n            replacerStack.push([\n                val,\n                k,\n                replace\n            ]);\n        }\n    } else {\n        parent[k] = replace;\n        arr.push([\n            parent,\n            k,\n            val\n        ]);\n    }\n}\nfunction decirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                decirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            var keys = Object.keys(val);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                decirc(val[key], key, i, stack, val, depth, options);\n            }\n        }\n        stack.pop();\n    }\n}\n// Stable-stringify\nfunction compareFunction(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nfunction deterministicStringify(obj, replacer, spacer, options) {\n    if (typeof options === \"undefined\") {\n        options = defaultOptions();\n    }\n    var tmp = deterministicDecirc(obj, \"\", 0, [], undefined, 0, options) || obj;\n    var res;\n    try {\n        if (replacerStack.length === 0) {\n            res = JSON.stringify(tmp, replacer, spacer);\n        } else {\n            res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);\n        }\n    } catch (_) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        // Ensure that we restore the object as it was.\n        while(arr.length !== 0){\n            var part = arr.pop();\n            if (part.length === 4) {\n                Object.defineProperty(part[0], part[1], part[3]);\n            } else {\n                part[0][part[1]] = part[2];\n            }\n        }\n    }\n    return res;\n}\nfunction deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {\n    depth += 1;\n    var i;\n    if (typeof val === \"object\" && val !== null) {\n        for(i = 0; i < stack.length; i++){\n            if (stack[i] === val) {\n                setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);\n                return;\n            }\n        }\n        try {\n            if (typeof val.toJSON === \"function\") {\n                return;\n            }\n        } catch (_) {\n            return;\n        }\n        if (typeof options.depthLimit !== \"undefined\" && depth > options.depthLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        if (typeof options.edgesLimit !== \"undefined\" && edgeIndex + 1 > options.edgesLimit) {\n            setReplace(LIMIT_REPLACE_NODE, val, k, parent);\n            return;\n        }\n        stack.push(val);\n        // Optimize for Arrays. Big arrays could kill the performance otherwise!\n        if (Array.isArray(val)) {\n            for(i = 0; i < val.length; i++){\n                deterministicDecirc(val[i], i, i, stack, val, depth, options);\n            }\n        } else {\n            // Handle well-known types before Object.keys iteration\n            val = serializeWellKnownTypes(val);\n            // Create a temporary object in the required way\n            var tmp = {};\n            var keys = Object.keys(val).sort(compareFunction);\n            for(i = 0; i < keys.length; i++){\n                var key = keys[i];\n                deterministicDecirc(val[key], key, i, stack, val, depth, options);\n                tmp[key] = val[key];\n            }\n            if (typeof parent !== \"undefined\") {\n                arr.push([\n                    parent,\n                    k,\n                    val\n                ]);\n                parent[k] = tmp;\n            } else {\n                return tmp;\n            }\n        }\n        stack.pop();\n    }\n}\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues(replacer) {\n    replacer = typeof replacer !== \"undefined\" ? replacer : function(k, v) {\n        return v;\n    };\n    return function(key, val) {\n        if (replacerStack.length > 0) {\n            for(var i = 0; i < replacerStack.length; i++){\n                var part = replacerStack[i];\n                if (part[1] === key && part[0] === val) {\n                    val = part[2];\n                    replacerStack.splice(i, 1);\n                    break;\n                }\n            }\n        }\n        return replacer.call(this, key, val);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvZmFzdC1zYWZlLXN0cmluZ2lmeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGtCQUFrQixHQUNsQixjQUFjO0FBQ3VEO0FBQ3JFLElBQUlDLHFCQUFxQjtBQUN6QixJQUFJQyx3QkFBd0I7SUFBRUMsUUFBUTtBQUFhO0FBQ25ELElBQUlDLE1BQU0sRUFBRTtBQUNaLElBQUlDLGdCQUFnQixFQUFFO0FBQ3RCLE1BQU1DLFVBQVUsSUFBSUM7QUFDcEIsU0FBU0M7SUFDTCxPQUFPO1FBQ0hDLFlBQVlDLE9BQU9DLGdCQUFnQjtRQUNuQ0MsWUFBWUYsT0FBT0MsZ0JBQWdCO0lBQ3ZDO0FBQ0o7QUFDQSxTQUFTRSxhQUFhQyxHQUFHO0lBQ3JCLE9BQU9SLFFBQVFTLE1BQU0sQ0FBQ0Q7QUFDMUI7QUFDQSw2Q0FBNkM7QUFDN0MsU0FBU0Usd0JBQXdCQyxHQUFHO0lBQ2hDLElBQUlBLE9BQU8sT0FBT0EsUUFBUSxZQUFZQSxRQUFRLE1BQU07UUFDaEQsSUFBSUEsZUFBZUMsS0FBSztZQUNwQixPQUFPQyxPQUFPQyxXQUFXLENBQUNIO1FBQzlCLE9BQ0ssSUFBSUEsZUFBZUksS0FBSztZQUN6QixPQUFPQyxNQUFNQyxJQUFJLENBQUNOO1FBQ3RCLE9BQ0ssSUFBSUEsZUFBZU8sTUFBTTtZQUMxQixPQUFPUCxJQUFJUSxXQUFXO1FBQzFCLE9BQ0ssSUFBSVIsZUFBZVMsUUFBUTtZQUM1QixPQUFPVCxJQUFJVSxRQUFRO1FBQ3ZCLE9BQ0ssSUFBSVYsZUFBZVcsT0FBTztZQUMzQixPQUFPO2dCQUNIQyxNQUFNWixJQUFJWSxJQUFJO2dCQUNkQyxTQUFTYixJQUFJYSxPQUFPO1lBQ3hCO1FBQ0o7SUFDSixPQUNLLElBQUksT0FBT2IsUUFBUSxVQUFVO1FBQzlCLE9BQU9BLElBQUlVLFFBQVE7SUFDdkI7SUFDQSxPQUFPVjtBQUNYO0FBQ0EsdURBQXVEO0FBQ3ZELFNBQVNjLHNCQUFzQkMs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RTtvQkFDYmpELGNBQWM2RSxNQUFNLENBQUNaLEdBQUc7b0JBQ3hCO2dCQUNKO1lBQ0o7UUFDSjtRQUNBLE9BQU85QixTQUFTTCxJQUFJLENBQUMsSUFBSSxFQUFFRixLQUFLaEI7SUFDcEM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9mYXN0LXNhZmUtc3RyaW5naWZ5L2luZGV4LmpzPzgxZTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgeyBnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2Vudi5qc1wiO1xudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9IFwiWy4uLl1cIjtcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSB7IHJlc3VsdDogXCJbQ2lyY3VsYXJdXCIgfTtcbnZhciBhcnIgPSBbXTtcbnZhciByZXBsYWNlclN0YWNrID0gW107XG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgZWRnZXNMaW1pdDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzdHIpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbn1cbi8vIFNoYXJlZCBmdW5jdGlvbiB0byBoYW5kbGUgd2VsbC1rbm93biB0eXBlc1xuZnVuY3Rpb24gc2VyaWFsaXplV2VsbEtub3duVHlwZXModmFsKSB7XG4gICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWwubmFtZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWwubWVzc2FnZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICByZXR1cm4gdmFsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG4vLyBEZWZhdWx0IHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB3ZWxsLWtub3duIHR5cGVzXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0UmVwbGFjZXIodXNlclJlcGxhY2VyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAvLyBBcHBseSB1c2VyIHJlcGxhY2VyIGZpcnN0IGlmIHByb3ZpZGVkXG4gICAgICAgIGlmICh1c2VyUmVwbGFjZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJSZXN1bHQgPSB1c2VyUmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbCk7XG4gICAgICAgICAgICAvLyBJZiB1c2VyIHJlcGxhY2VyIHJldHVybmVkIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG91ciBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICBpZiAodXNlclJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIG91ciB3ZWxsLWtub3duIHR5cGUgaGFuZGxpbmdcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVdlbGxLbm93blR5cGVzKHZhbCk7XG4gICAgfTtcbn1cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgZXJyb3JDb250ZXh0LCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyID0gSlNPTi5zdHJpbmdpZnkob2JqLCBjcmVhdGVEZWZhdWx0UmVwbGFjZXIocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBtb3JlIGNvbXBsZXggc3RyaW5naWZ5IGlmIGNpcmN1bGFyIHJlZmVyZW5jZVxuICAgICAgICBpZiAoIWUubWVzc2FnZT8uaW5jbHVkZXMoXCJDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OXCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFtXQVJOSU5HXTogTGFuZ1NtaXRoIHJlY2VpdmVkIHVuc2VyaWFsaXphYmxlIHZhbHVlLiR7ZXJyb3JDb250ZXh0ID8gYFxcbkNvbnRleHQ6ICR7ZXJyb3JDb250ZXh0fWAgOiBcIlwifWApO1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVN0cmluZyhcIltVbnNlcmlhbGl6YWJsZV1cIik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlNVUFBSRVNTX0NJUkNVTEFSX0pTT05fV0FSTklOR1NcIikgIT09XG4gICAgICAgICAgICBcInRydWVcIiAmJlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbV0FSTklOR106IExhbmdTbWl0aCByZWNlaXZlZCBjaXJjdWxhciBKU09OLiBUaGlzIHdpbGwgZGVjcmVhc2UgdHJhY2VyIHBlcmZvcm1hbmNlLiAke2Vycm9yQ29udGV4dCA/IGBcXG5Db250ZXh0OiAke2Vycm9yQ29udGV4dH1gIDogXCJcIn1gKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNpcmMob2JqLCBcIlwiLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlU3RyaW5nKFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFydC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcnRbMF0sIHBhcnRbMV0sIHBhcnRbM10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcocmVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRSZXBsYWNlKHJlcGxhY2UsIHZhbCwgaywgcGFyZW50KSB7XG4gICAgdmFyIHByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBrKTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocGFyZW50LCBrLCB7IHZhbHVlOiByZXBsYWNlIH0pO1xuICAgICAgICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcGxhY2VyU3RhY2sucHVzaChbdmFsLCBrLCByZXBsYWNlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmVudFtrXSA9IHJlcGxhY2U7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY2lyYyh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBkZXB0aCArPSAxO1xuICAgIHZhciBpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tpXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGRlcHRoID4gb3B0aW9ucy5kZXB0aExpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5lZGdlc0xpbWl0ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0KSB7XG4gICAgICAgICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsKTtcbiAgICAgICAgLy8gT3B0aW1pemUgZm9yIEFycmF5cy4gQmlnIGFycmF5cyBjb3VsZCBraWxsIHRoZSBwZXJmb3JtYW5jZSBvdGhlcndpc2UhXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZWNpcmModmFsW2tleV0sIGtleSwgaSwgc3RhY2ssIHZhbCwgZGVwdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIFN0YWJsZS1zdHJpbmdpZnlcbmZ1bmN0aW9uIGNvbXBhcmVGdW5jdGlvbihhLCBiKSB7XG4gICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGRldGVybWluaXN0aWNTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2VyLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpO1xuICAgIH1cbiAgICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosIFwiXCIsIDAsIFtdLCB1bmRlZmluZWQsIDAsIG9wdGlvbnMpIHx8IG9iajtcbiAgICB2YXIgcmVzO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KHRtcCwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFwiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJlc3RvcmUgdGhlIG9iamVjdCBhcyBpdCB3YXMuXG4gICAgICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcGFydCA9IGFyci5wb3AoKTtcbiAgICAgICAgICAgIGlmIChwYXJ0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRbMF1bcGFydFsxXV0gPSBwYXJ0WzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbCwgaywgZWRnZUluZGV4LCBzdGFjaywgcGFyZW50LCBkZXB0aCwgb3B0aW9ucykge1xuICAgIGRlcHRoICs9IDE7XG4gICAgdmFyIGk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwib2JqZWN0XCIgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVwdGhMaW1pdCAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXQpIHtcbiAgICAgICAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWwpO1xuICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRldGVybWluaXN0aWNEZWNpcmModmFsW2ldLCBpLCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgd2VsbC1rbm93biB0eXBlcyBiZWZvcmUgT2JqZWN0LmtleXMgaXRlcmF0aW9uXG4gICAgICAgICAgICB2YWwgPSBzZXJpYWxpemVXZWxsS25vd25UeXBlcyh2YWwpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG9iamVjdCBpbiB0aGUgcmVxdWlyZWQgd2F5XG4gICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbCkuc29ydChjb21wYXJlRnVuY3Rpb24pO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBkZXRlcm1pbmlzdGljRGVjaXJjKHZhbFtrZXldLCBrZXksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB0bXBba2V5XSA9IHZhbFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRba10gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH1cbn1cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlcikge1xuICAgIHJlcGxhY2VyID1cbiAgICAgICAgdHlwZW9mIHJlcGxhY2VyICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICA/IHJlcGxhY2VyXG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBsYWNlclN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSByZXBsYWNlclN0YWNrW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0WzFdID09PSBrZXkgJiYgcGFydFswXSA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnRbMl07XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VyU3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWwpO1xuICAgIH07XG59XG4iXSwibmFtZXMiOlsiZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZSIsIkxJTUlUX1JFUExBQ0VfTk9ERSIsIkNJUkNVTEFSX1JFUExBQ0VfTk9ERSIsInJlc3VsdCIsImFyciIsInJlcGxhY2VyU3RhY2siLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJkZWZhdWx0T3B0aW9ucyIsImRlcHRoTGltaXQiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZWRnZXNMaW1pdCIsImVuY29kZVN0cmluZyIsInN0ciIsImVuY29kZSIsInNlcmlhbGl6ZVdlbGxLbm93blR5cGVzIiwidmFsIiwiTWFwIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJTZXQiLCJBcnJheSIsImZyb20iLCJEYXRlIiwidG9JU09TdHJpbmciLCJSZWdFeHAiLCJ0b1N0cmluZyIsIkVycm9yIiwibmFtZSIsIm1lc3NhZ2UiLCJjcmVhdGVEZWZhdWx0UmVwbGFjZXIiLCJ1c2VyUmVwbGFjZXIiLCJrZXkiLCJ1c2VyUmVzdWx0IiwiY2FsbCIsInVuZGVmaW5lZCIsInNlcmlhbGl6ZSIsIm9iaiIsImVycm9yQ29udGV4dCIsInJlcGxhY2VyIiwic3BhY2VyIiwib3B0aW9ucyIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImRlY2lyYyIsInJlcyIsImxlbmd0aCIsInJlcGxhY2VHZXR0ZXJWYWx1ZXMiLCJfIiwicGFydCIsInBvcCIsImRlZmluZVByb3BlcnR5Iiwic2V0UmVwbGFjZSIsInJlcGxhY2UiLCJrIiwicGFyZW50IiwicHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJwdXNoIiwiZWRnZUluZGV4Iiwic3RhY2siLCJkZXB0aCIsImkiLCJpc0FycmF5Iiwia2V5cyIsImNvbXBhcmVGdW5jdGlvbiIsImEiLCJiIiwiZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeSIsInRtcCIsImRldGVybWluaXN0aWNEZWNpcmMiLCJ0b0pTT04iLCJzb3J0IiwidiIsInNwbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/fast-safe-stringify/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/is-network-error/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/is-network-error/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isNetworkError)\n/* harmony export */ });\n/* eslint-disable */ // @ts-nocheck\n// is-network-error vendored to avoid import issues\n// Source: https://github.com/sindresorhus/is-network-error\nconst objectToString = Object.prototype.toString;\nconst isError = (value)=>objectToString.call(value) === \"[object Error]\";\nconst errorMessages = new Set([\n    \"network error\",\n    \"Failed to fetch\",\n    \"NetworkError when attempting to fetch resource.\",\n    \"The Internet connection appears to be offline.\",\n    \"Network request failed\",\n    \"fetch failed\",\n    \"terminated\",\n    \" A network error occurred.\",\n    \"Network connection lost\"\n]);\nfunction isNetworkError(error) {\n    const isValid = error && isError(error) && error.name === \"TypeError\" && typeof error.message === \"string\";\n    if (!isValid) {\n        return false;\n    }\n    const { message, stack } = error;\n    // Safari 17+ has generic message but no stack for network errors\n    if (message === \"Load failed\") {\n        return stack === undefined || // Sentry adds its own stack trace to the fetch error, so also check for that\n        \"__sentry_captured__\" in error;\n    }\n    // Deno network errors start with specific text\n    if (message.startsWith(\"error sending request for url\")) {\n        return true;\n    }\n    // Standard network error messages\n    return errorMessages.has(message);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvaXMtbmV0d29yay1lcnJvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsa0JBQWtCLEdBQ2xCLGNBQWM7QUFDZCxtREFBbUQ7QUFDbkQsMkRBQTJEO0FBQzNELE1BQU1BLGlCQUFpQkMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRO0FBQ2hELE1BQU1DLFVBQVUsQ0FBQ0MsUUFBVUwsZUFBZU0sSUFBSSxDQUFDRCxXQUFXO0FBQzFELE1BQU1FLGdCQUFnQixJQUFJQyxJQUFJO0lBQzFCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ2MsU0FBU0MsZUFBZUMsS0FBSztJQUN4QyxNQUFNQyxVQUFVRCxTQUNaTixRQUFRTSxVQUNSQSxNQUFNRSxJQUFJLEtBQUssZUFDZixPQUFPRixNQUFNRyxPQUFPLEtBQUs7SUFDN0IsSUFBSSxDQUFDRixTQUFTO1FBQ1YsT0FBTztJQUNYO0lBQ0EsTUFBTSxFQUFFRSxPQUFPLEVBQUVDLEtBQUssRUFBRSxHQUFHSjtJQUMzQixpRUFBaUU7SUFDakUsSUFBSUcsWUFBWSxlQUFlO1FBQzNCLE9BQVFDLFVBQVVDLGFBQ2QsNkVBQTZFO1FBQzdFLHlCQUF5Qkw7SUFDakM7SUFDQSwrQ0FBK0M7SUFDL0MsSUFBSUcsUUFBUUcsVUFBVSxDQUFDLGtDQUFrQztRQUNyRCxPQUFPO0lBQ1g7SUFDQSxrQ0FBa0M7SUFDbEMsT0FBT1QsY0FBY1UsR0FBRyxDQUFDSjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9pcy1uZXR3b3JrLWVycm9yL2luZGV4LmpzP2YzMGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgKi9cbi8vIEB0cy1ub2NoZWNrXG4vLyBpcy1uZXR3b3JrLWVycm9yIHZlbmRvcmVkIHRvIGF2b2lkIGltcG9ydCBpc3N1ZXNcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1uZXR3b3JrLWVycm9yXG5jb25zdCBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBpc0Vycm9yID0gKHZhbHVlKSA9PiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gXCJbb2JqZWN0IEVycm9yXVwiO1xuY29uc3QgZXJyb3JNZXNzYWdlcyA9IG5ldyBTZXQoW1xuICAgIFwibmV0d29yayBlcnJvclwiLCAvLyBDaHJvbWVcbiAgICBcIkZhaWxlZCB0byBmZXRjaFwiLCAvLyBDaHJvbWVcbiAgICBcIk5ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuXCIsIC8vIEZpcmVmb3hcbiAgICBcIlRoZSBJbnRlcm5ldCBjb25uZWN0aW9uIGFwcGVhcnMgdG8gYmUgb2ZmbGluZS5cIiwgLy8gU2FmYXJpIDE2XG4gICAgXCJOZXR3b3JrIHJlcXVlc3QgZmFpbGVkXCIsIC8vIGBjcm9zcy1mZXRjaGBcbiAgICBcImZldGNoIGZhaWxlZFwiLCAvLyBVbmRpY2kgKE5vZGUuanMpXG4gICAgXCJ0ZXJtaW5hdGVkXCIsIC8vIFVuZGljaSAoTm9kZS5qcylcbiAgICBcIiBBIG5ldHdvcmsgZXJyb3Igb2NjdXJyZWQuXCIsIC8vIEJ1biAoV2ViS2l0KVxuICAgIFwiTmV0d29yayBjb25uZWN0aW9uIGxvc3RcIiwgLy8gQ2xvdWRmbGFyZSBXb3JrZXJzIChmZXRjaClcbl0pO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBpc1ZhbGlkID0gZXJyb3IgJiZcbiAgICAgICAgaXNFcnJvcihlcnJvcikgJiZcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gXCJUeXBlRXJyb3JcIiAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gXCJzdHJpbmdcIjtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IG1lc3NhZ2UsIHN0YWNrIH0gPSBlcnJvcjtcbiAgICAvLyBTYWZhcmkgMTcrIGhhcyBnZW5lcmljIG1lc3NhZ2UgYnV0IG5vIHN0YWNrIGZvciBuZXR3b3JrIGVycm9yc1xuICAgIGlmIChtZXNzYWdlID09PSBcIkxvYWQgZmFpbGVkXCIpIHtcbiAgICAgICAgcmV0dXJuIChzdGFjayA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAvLyBTZW50cnkgYWRkcyBpdHMgb3duIHN0YWNrIHRyYWNlIHRvIHRoZSBmZXRjaCBlcnJvciwgc28gYWxzbyBjaGVjayBmb3IgdGhhdFxuICAgICAgICAgICAgXCJfX3NlbnRyeV9jYXB0dXJlZF9fXCIgaW4gZXJyb3IpO1xuICAgIH1cbiAgICAvLyBEZW5vIG5ldHdvcmsgZXJyb3JzIHN0YXJ0IHdpdGggc3BlY2lmaWMgdGV4dFxuICAgIGlmIChtZXNzYWdlLnN0YXJ0c1dpdGgoXCJlcnJvciBzZW5kaW5nIHJlcXVlc3QgZm9yIHVybFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gU3RhbmRhcmQgbmV0d29yayBlcnJvciBtZXNzYWdlc1xuICAgIHJldHVybiBlcnJvck1lc3NhZ2VzLmhhcyhtZXNzYWdlKTtcbn1cbiJdLCJuYW1lcyI6WyJvYmplY3RUb1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiaXNFcnJvciIsInZhbHVlIiwiY2FsbCIsImVycm9yTWVzc2FnZXMiLCJTZXQiLCJpc05ldHdvcmtFcnJvciIsImVycm9yIiwiaXNWYWxpZCIsIm5hbWUiLCJtZXNzYWdlIiwic3RhY2siLCJ1bmRlZmluZWQiLCJzdGFydHNXaXRoIiwiaGFzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/is-network-error/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/messages.js":
/*!*******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/messages.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertLangChainMessageToExample: () => (/* binding */ convertLangChainMessageToExample),\n/* harmony export */   isLangChainMessage: () => (/* binding */ isLangChainMessage)\n/* harmony export */ });\nfunction isLangChainMessage(// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmessage) {\n    return typeof message?._getType === \"function\";\n}\nfunction convertLangChainMessageToExample(message) {\n    const converted = {\n        type: message._getType(),\n        data: {\n            content: message.content\n        }\n    };\n    // Check for presence of keys in additional_kwargs\n    if (message?.additional_kwargs && Object.keys(message.additional_kwargs).length > 0) {\n        converted.data.additional_kwargs = {\n            ...message.additional_kwargs\n        };\n    }\n    return converted;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvbWVzc2FnZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBTyxTQUFTQSxtQkFDaEIsOERBQThEO0FBQzlEQyxPQUFPO0lBQ0gsT0FBTyxPQUFPQSxTQUFTQyxhQUFhO0FBQ3hDO0FBQ08sU0FBU0MsaUNBQWlDRixPQUFPO0lBQ3BELE1BQU1HLFlBQVk7UUFDZEMsTUFBTUosUUFBUUMsUUFBUTtRQUN0QkksTUFBTTtZQUFFQyxTQUFTTixRQUFRTSxPQUFPO1FBQUM7SUFDckM7SUFDQSxrREFBa0Q7SUFDbEQsSUFBSU4sU0FBU08scUJBQ1RDLE9BQU9DLElBQUksQ0FBQ1QsUUFBUU8saUJBQWlCLEVBQUVHLE1BQU0sR0FBRyxHQUFHO1FBQ25EUCxVQUFVRSxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1lBQUUsR0FBR1AsUUFBUU8saUJBQWlCO1FBQUM7SUFDdEU7SUFDQSxPQUFPSjtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9kaXN0L3V0aWxzL21lc3NhZ2VzLmpzPzQ3M2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzTGFuZ0NoYWluTWVzc2FnZShcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlPy5fZ2V0VHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nQ2hhaW5NZXNzYWdlVG9FeGFtcGxlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCBjb252ZXJ0ZWQgPSB7XG4gICAgICAgIHR5cGU6IG1lc3NhZ2UuX2dldFR5cGUoKSxcbiAgICAgICAgZGF0YTogeyBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfSxcbiAgICB9O1xuICAgIC8vIENoZWNrIGZvciBwcmVzZW5jZSBvZiBrZXlzIGluIGFkZGl0aW9uYWxfa3dhcmdzXG4gICAgaWYgKG1lc3NhZ2U/LmFkZGl0aW9uYWxfa3dhcmdzICYmXG4gICAgICAgIE9iamVjdC5rZXlzKG1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29udmVydGVkLmRhdGEuYWRkaXRpb25hbF9rd2FyZ3MgPSB7IC4uLm1lc3NhZ2UuYWRkaXRpb25hbF9rd2FyZ3MgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cbiJdLCJuYW1lcyI6WyJpc0xhbmdDaGFpbk1lc3NhZ2UiLCJtZXNzYWdlIiwiX2dldFR5cGUiLCJjb252ZXJ0TGFuZ0NoYWluTWVzc2FnZVRvRXhhbXBsZSIsImNvbnZlcnRlZCIsInR5cGUiLCJkYXRhIiwiY29udGVudCIsImFkZGl0aW9uYWxfa3dhcmdzIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/p-retry/index.js":
/*!************************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/p-retry/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortError: () => (/* binding */ AbortError),\n/* harmony export */   \"default\": () => (/* binding */ pRetry),\n/* harmony export */   makeRetriable: () => (/* binding */ makeRetriable)\n/* harmony export */ });\n/* harmony import */ var _is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../is-network-error/index.js */ \"(rsc)/./node_modules/langsmith/dist/utils/is-network-error/index.js\");\n/* eslint-disable */ // @ts-nocheck\n// p-retry code vendored to avoid import issues\n// Source: https://github.com/sindresorhus/p-retry\n\nfunction validateRetries(retries) {\n    if (typeof retries === \"number\") {\n        if (retries < 0) {\n            throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n        }\n        if (Number.isNaN(retries)) {\n            throw new TypeError(\"Expected `retries` to be a valid number or Infinity, got NaN.\");\n        }\n    } else if (retries !== undefined) {\n        throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n    }\n}\nfunction validateNumberOption(name, value, { min = 0, allowInfinity = false } = {}) {\n    if (value === undefined) {\n        return;\n    }\n    if (typeof value !== \"number\" || Number.isNaN(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a number${allowInfinity ? \" or Infinity\" : \"\"}.`);\n    }\n    if (!allowInfinity && !Number.isFinite(value)) {\n        throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n    }\n    if (value < min) {\n        throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n    }\n}\nclass AbortError extends Error {\n    constructor(message){\n        super();\n        if (message instanceof Error) {\n            this.originalError = message;\n            ({ message } = message);\n        } else {\n            this.originalError = new Error(message);\n            this.originalError.stack = this.stack;\n        }\n        this.name = \"AbortError\";\n        this.message = message;\n    }\n}\nfunction calculateDelay(retriesConsumed, options) {\n    const attempt = Math.max(1, retriesConsumed + 1);\n    const random = options.randomize ? Math.random() + 1 : 1;\n    let timeout = Math.round(random * options.minTimeout * options.factor ** (attempt - 1));\n    timeout = Math.min(timeout, options.maxTimeout);\n    return timeout;\n}\nfunction calculateRemainingTime(start, max) {\n    if (!Number.isFinite(max)) {\n        return max;\n    }\n    return max - (performance.now() - start);\n}\nasync function onAttemptFailure({ error, attemptNumber, retriesConsumed, startTime, options }) {\n    const normalizedError = error instanceof Error ? error : new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n    if (normalizedError instanceof AbortError) {\n        throw normalizedError.originalError;\n    }\n    const retriesLeft = Number.isFinite(options.retries) ? Math.max(0, options.retries - retriesConsumed) : options.retries;\n    const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n    const context = Object.freeze({\n        error: normalizedError,\n        attemptNumber,\n        retriesLeft,\n        retriesConsumed\n    });\n    await options.onFailedAttempt(context);\n    if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n        throw normalizedError;\n    }\n    const consumeRetry = await options.shouldConsumeRetry(context);\n    const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n    if (remainingTime <= 0 || retriesLeft <= 0) {\n        throw normalizedError;\n    }\n    if (normalizedError instanceof TypeError && !(0,_is_network_error_index_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(normalizedError)) {\n        if (consumeRetry) {\n            throw normalizedError;\n        }\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    if (!await options.shouldRetry(context)) {\n        throw normalizedError;\n    }\n    if (!consumeRetry) {\n        options.signal?.throwIfAborted();\n        return false;\n    }\n    const delayTime = calculateDelay(retriesConsumed, options);\n    const finalDelay = Math.min(delayTime, remainingTime);\n    if (finalDelay > 0) {\n        await new Promise((resolve, reject)=>{\n            const onAbort = ()=>{\n                clearTimeout(timeoutToken);\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                reject(options.signal.reason);\n            };\n            const timeoutToken = setTimeout(()=>{\n                options.signal?.removeEventListener(\"abort\", onAbort);\n                resolve();\n            }, finalDelay);\n            if (options.unref) {\n                timeoutToken.unref?.();\n            }\n            options.signal?.addEventListener(\"abort\", onAbort, {\n                once: true\n            });\n        });\n    }\n    options.signal?.throwIfAborted();\n    return true;\n}\nasync function pRetry(input, options = {}) {\n    options = {\n        ...options\n    };\n    validateRetries(options.retries);\n    if (Object.hasOwn(options, \"forever\")) {\n        throw new Error(\"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\");\n    }\n    options.retries ??= 10;\n    options.factor ??= 2;\n    options.minTimeout ??= 1000;\n    options.maxTimeout ??= Number.POSITIVE_INFINITY;\n    options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n    options.randomize ??= false;\n    options.onFailedAttempt ??= ()=>{};\n    options.shouldRetry ??= ()=>true;\n    options.shouldConsumeRetry ??= ()=>true;\n    // Validate numeric options and normalize edge cases\n    validateNumberOption(\"factor\", options.factor, {\n        min: 0,\n        allowInfinity: false\n    });\n    validateNumberOption(\"minTimeout\", options.minTimeout, {\n        min: 0,\n        allowInfinity: false\n    });\n    validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n        min: 0,\n        allowInfinity: true\n    });\n    validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n        min: 0,\n        allowInfinity: true\n    });\n    // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n    if (!(options.factor > 0)) {\n        options.factor = 1;\n    }\n    options.signal?.throwIfAborted();\n    let attemptNumber = 0;\n    let retriesConsumed = 0;\n    const startTime = performance.now();\n    while(Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true){\n        attemptNumber++;\n        try {\n            options.signal?.throwIfAborted();\n            const result = await input(attemptNumber);\n            options.signal?.throwIfAborted();\n            return result;\n        } catch (error) {\n            if (await onAttemptFailure({\n                error,\n                attemptNumber,\n                retriesConsumed,\n                startTime,\n                options\n            })) {\n                retriesConsumed++;\n            }\n        }\n    }\n    // Should not reach here, but in case it does, throw an error\n    throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\nfunction makeRetriable(function_, options) {\n    return function(...arguments_) {\n        return pRetry(()=>function_.apply(this, arguments_), options);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcC1yZXRyeS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsa0JBQWtCLEdBQ2xCLGNBQWM7QUFDZCwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ1E7QUFDMUQsU0FBU0MsZ0JBQWdCQyxPQUFPO0lBQzVCLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQzdCLElBQUlBLFVBQVUsR0FBRztZQUNiLE1BQU0sSUFBSUMsVUFBVTtRQUN4QjtRQUNBLElBQUlDLE9BQU9DLEtBQUssQ0FBQ0gsVUFBVTtZQUN2QixNQUFNLElBQUlDLFVBQVU7UUFDeEI7SUFDSixPQUNLLElBQUlELFlBQVlJLFdBQVc7UUFDNUIsTUFBTSxJQUFJSCxVQUFVO0lBQ3hCO0FBQ0o7QUFDQSxTQUFTSSxxQkFBcUJDLElBQUksRUFBRUMsS0FBSyxFQUFFLEVBQUVDLE1BQU0sQ0FBQyxFQUFFQyxnQkFBZ0IsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzlFLElBQUlGLFVBQVVILFdBQVc7UUFDckI7SUFDSjtJQUNBLElBQUksT0FBT0csVUFBVSxZQUFZTCxPQUFPQyxLQUFLLENBQUNJLFFBQVE7UUFDbEQsTUFBTSxJQUFJTixVQUFVLENBQUMsV0FBVyxFQUFFSyxLQUFLLGlCQUFpQixFQUFFRyxnQkFBZ0IsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0lBQ3BHO0lBQ0EsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQ1AsT0FBT1EsUUFBUSxDQUFDSCxRQUFRO1FBQzNDLE1BQU0sSUFBSU4sVUFBVSxDQUFDLFdBQVcsRUFBRUssS0FBSyx5QkFBeUIsQ0FBQztJQUNyRTtJQUNBLElBQUlDLFFBQVFDLEtBQUs7UUFDYixNQUFNLElBQUlQLFVBQVUsQ0FBQyxXQUFXLEVBQUVLLEtBQUssZ0JBQWdCLEVBQUVFLElBQUksQ0FBQyxDQUFDO0lBQ25FO0FBQ0o7QUFDTyxNQUFNRyxtQkFBbUJDO0lBQzVCQyxZQUFZQyxPQUFPLENBQUU7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TEMsZUFBZTtJQUNuQjtJQUNBSixxQkFBcUIsY0FBY2MsUUFBUVUsVUFBVSxFQUFFO1FBQ25EckIsS0FBSztRQUNMQyxlQUFlO0lBQ25CO0lBQ0FKLHFCQUFxQixnQkFBZ0JjLFFBQVFxQixZQUFZLEVBQUU7UUFDdkRoQyxLQUFLO1FBQ0xDLGVBQWU7SUFDbkI7SUFDQSw0RUFBNEU7SUFDNUUsSUFBSSxDQUFFVSxDQUFBQSxRQUFRUyxNQUFNLEdBQUcsSUFBSTtRQUN2QlQsUUFBUVMsTUFBTSxHQUFHO0lBQ3JCO0lBQ0FULFFBQVE4QixNQUFNLEVBQUVDO0lBQ2hCLElBQUlkLGdCQUFnQjtJQUNwQixJQUFJbEIsa0JBQWtCO0lBQ3RCLE1BQU1tQixZQUFZTCxZQUFZQyxHQUFHO0lBQ2pDLE1BQU8vQixPQUFPUSxRQUFRLENBQUNTLFFBQVFuQixPQUFPLElBQUlrQixtQkFBbUJDLFFBQVFuQixPQUFPLEdBQUcsS0FBTTtRQUNqRm9DO1FBQ0EsSUFBSTtZQUNBakIsUUFBUThCLE1BQU0sRUFBRUM7WUFDaEIsTUFBTW1CLFNBQVMsTUFBTUYsTUFBTS9CO1lBQzNCakIsUUFBUThCLE1BQU0sRUFBRUM7WUFDaEIsT0FBT21CO1FBQ1gsRUFDQSxPQUFPbEMsT0FBTztZQUNWLElBQUksTUFBTUQsaUJBQWlCO2dCQUN2QkM7Z0JBQ0FDO2dCQUNBbEI7Z0JBQ0FtQjtnQkFDQWxCO1lBQ0osSUFBSTtnQkFDQUQ7WUFDSjtRQUNKO0lBQ0o7SUFDQSw2REFBNkQ7SUFDN0QsTUFBTSxJQUFJTixNQUFNO0FBQ3BCO0FBQ08sU0FBUzBELGNBQWNDLFNBQVMsRUFBRXBELE9BQU87SUFDNUMsT0FBTyxTQUFVLEdBQUdxRCxVQUFVO1FBQzFCLE9BQU9OLE9BQU8sSUFBTUssVUFBVUUsS0FBSyxDQUFDLElBQUksRUFBRUQsYUFBYXJEO0lBQzNEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcC1yZXRyeS9pbmRleC5qcz82YzQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBAdHMtbm9jaGVja1xuLy8gcC1yZXRyeSBjb2RlIHZlbmRvcmVkIHRvIGF2b2lkIGltcG9ydCBpc3N1ZXNcbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9wLXJldHJ5XG5pbXBvcnQgaXNOZXR3b3JrRXJyb3IgZnJvbSBcIi4uL2lzLW5ldHdvcmstZXJyb3IvaW5kZXguanNcIjtcbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cmllcyhyZXRyaWVzKSB7XG4gICAgaWYgKHR5cGVvZiByZXRyaWVzID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChyZXRyaWVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGByZXRyaWVzYCB0byBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4ocmV0cmllcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBgcmV0cmllc2AgdG8gYmUgYSB2YWxpZCBudW1iZXIgb3IgSW5maW5pdHksIGdvdCBOYU4uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHJldHJpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYHJldHJpZXNgIHRvIGJlIGEgbnVtYmVyIG9yIEluZmluaXR5LlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlck9wdGlvbihuYW1lLCB2YWx1ZSwgeyBtaW4gPSAwLCBhbGxvd0luZmluaXR5ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm51bWJlclwiIHx8IE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgJHtuYW1lfVxcYCB0byBiZSBhIG51bWJlciR7YWxsb3dJbmZpbml0eSA/IFwiIG9yIEluZmluaXR5XCIgOiBcIlwifS5gKTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd0luZmluaXR5ICYmICFOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFxcYCR7bmFtZX1cXGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLmApO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgJHtuYW1lfVxcYCB0byBiZSBcXHUyMjY1ICR7bWlufS5gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChtZXNzYWdlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAoeyBtZXNzYWdlIH0gPSBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxFcnJvci5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsYXkocmV0cmllc0NvbnN1bWVkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYXR0ZW1wdCA9IE1hdGgubWF4KDEsIHJldHJpZXNDb25zdW1lZCArIDEpO1xuICAgIGNvbnN0IHJhbmRvbSA9IG9wdGlvbnMucmFuZG9taXplID8gTWF0aC5yYW5kb20oKSArIDEgOiAxO1xuICAgIGxldCB0aW1lb3V0ID0gTWF0aC5yb3VuZChyYW5kb20gKiBvcHRpb25zLm1pblRpbWVvdXQgKiBvcHRpb25zLmZhY3RvciAqKiAoYXR0ZW1wdCAtIDEpKTtcbiAgICB0aW1lb3V0ID0gTWF0aC5taW4odGltZW91dCwgb3B0aW9ucy5tYXhUaW1lb3V0KTtcbiAgICByZXR1cm4gdGltZW91dDtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlbWFpbmluZ1RpbWUoc3RhcnQsIG1heCkge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1heCkpIHtcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcmV0dXJuIG1heCAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG9uQXR0ZW1wdEZhaWx1cmUoeyBlcnJvciwgYXR0ZW1wdE51bWJlciwgcmV0cmllc0NvbnN1bWVkLCBzdGFydFRpbWUsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCBub3JtYWxpemVkRXJyb3IgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgID8gZXJyb3JcbiAgICAgICAgOiBuZXcgVHlwZUVycm9yKGBOb24tZXJyb3Igd2FzIHRocm93bjogXCIke2Vycm9yfVwiLiBZb3Ugc2hvdWxkIG9ubHkgdGhyb3cgZXJyb3JzLmApO1xuICAgIGlmIChub3JtYWxpemVkRXJyb3IgaW5zdGFuY2VvZiBBYm9ydEVycm9yKSB7XG4gICAgICAgIHRocm93IG5vcm1hbGl6ZWRFcnJvci5vcmlnaW5hbEVycm9yO1xuICAgIH1cbiAgICBjb25zdCByZXRyaWVzTGVmdCA9IE51bWJlci5pc0Zpbml0ZShvcHRpb25zLnJldHJpZXMpXG4gICAgICAgID8gTWF0aC5tYXgoMCwgb3B0aW9ucy5yZXRyaWVzIC0gcmV0cmllc0NvbnN1bWVkKVxuICAgICAgICA6IG9wdGlvbnMucmV0cmllcztcbiAgICBjb25zdCBtYXhSZXRyeVRpbWUgPSBvcHRpb25zLm1heFJldHJ5VGltZSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgY29uc3QgY29udGV4dCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBlcnJvcjogbm9ybWFsaXplZEVycm9yLFxuICAgICAgICBhdHRlbXB0TnVtYmVyLFxuICAgICAgICByZXRyaWVzTGVmdCxcbiAgICAgICAgcmV0cmllc0NvbnN1bWVkLFxuICAgIH0pO1xuICAgIGF3YWl0IG9wdGlvbnMub25GYWlsZWRBdHRlbXB0KGNvbnRleHQpO1xuICAgIGlmIChjYWxjdWxhdGVSZW1haW5pbmdUaW1lKHN0YXJ0VGltZSwgbWF4UmV0cnlUaW1lKSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5vcm1hbGl6ZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY29uc3VtZVJldHJ5ID0gYXdhaXQgb3B0aW9ucy5zaG91bGRDb25zdW1lUmV0cnkoY29udGV4dCk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IGNhbGN1bGF0ZVJlbWFpbmluZ1RpbWUoc3RhcnRUaW1lLCBtYXhSZXRyeVRpbWUpO1xuICAgIGlmIChyZW1haW5pbmdUaW1lIDw9IDAgfHwgcmV0cmllc0xlZnQgPD0gMCkge1xuICAgICAgICB0aHJvdyBub3JtYWxpemVkRXJyb3I7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkRXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiZcbiAgICAgICAgIWlzTmV0d29ya0Vycm9yKG5vcm1hbGl6ZWRFcnJvcikpIHtcbiAgICAgICAgaWYgKGNvbnN1bWVSZXRyeSkge1xuICAgICAgICAgICAgdGhyb3cgbm9ybWFsaXplZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghKGF3YWl0IG9wdGlvbnMuc2hvdWxkUmV0cnkoY29udGV4dCkpKSB7XG4gICAgICAgIHRocm93IG5vcm1hbGl6ZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKCFjb25zdW1lUmV0cnkpIHtcbiAgICAgICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZGVsYXlUaW1lID0gY2FsY3VsYXRlRGVsYXkocmV0cmllc0NvbnN1bWVkLCBvcHRpb25zKTtcbiAgICBjb25zdCBmaW5hbERlbGF5ID0gTWF0aC5taW4oZGVsYXlUaW1lLCByZW1haW5pbmdUaW1lKTtcbiAgICBpZiAoZmluYWxEZWxheSA+IDApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25BYm9ydCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFRva2VuKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgICAgICAgICAgICAgIHJlamVjdChvcHRpb25zLnNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRUb2tlbiA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25BYm9ydCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSwgZmluYWxEZWxheSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51bnJlZikge1xuICAgICAgICAgICAgICAgIHRpbWVvdXRUb2tlbi51bnJlZj8uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcFJldHJ5KGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0geyAuLi5vcHRpb25zIH07XG4gICAgdmFsaWRhdGVSZXRyaWVzKG9wdGlvbnMucmV0cmllcyk7XG4gICAgaWYgKE9iamVjdC5oYXNPd24ob3B0aW9ucywgXCJmb3JldmVyXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgZm9yZXZlcmAgb3B0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEZvciBtYW55IHVzZS1jYXNlcywgeW91IGNhbiBzZXQgYHJldHJpZXM6IEluZmluaXR5YCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgb3B0aW9ucy5yZXRyaWVzID8/PSAxMDtcbiAgICBvcHRpb25zLmZhY3RvciA/Pz0gMjtcbiAgICBvcHRpb25zLm1pblRpbWVvdXQgPz89IDEwMDA7XG4gICAgb3B0aW9ucy5tYXhUaW1lb3V0ID8/PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgb3B0aW9ucy5tYXhSZXRyeVRpbWUgPz89IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBvcHRpb25zLnJhbmRvbWl6ZSA/Pz0gZmFsc2U7XG4gICAgb3B0aW9ucy5vbkZhaWxlZEF0dGVtcHQgPz89ICgpID0+IHsgfTtcbiAgICBvcHRpb25zLnNob3VsZFJldHJ5ID8/PSAoKSA9PiB0cnVlO1xuICAgIG9wdGlvbnMuc2hvdWxkQ29uc3VtZVJldHJ5ID8/PSAoKSA9PiB0cnVlO1xuICAgIC8vIFZhbGlkYXRlIG51bWVyaWMgb3B0aW9ucyBhbmQgbm9ybWFsaXplIGVkZ2UgY2FzZXNcbiAgICB2YWxpZGF0ZU51bWJlck9wdGlvbihcImZhY3RvclwiLCBvcHRpb25zLmZhY3Rvciwge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93SW5maW5pdHk6IGZhbHNlLFxuICAgIH0pO1xuICAgIHZhbGlkYXRlTnVtYmVyT3B0aW9uKFwibWluVGltZW91dFwiLCBvcHRpb25zLm1pblRpbWVvdXQsIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBhbGxvd0luZmluaXR5OiBmYWxzZSxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZU51bWJlck9wdGlvbihcIm1heFRpbWVvdXRcIiwgb3B0aW9ucy5tYXhUaW1lb3V0LCB7XG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgYWxsb3dJbmZpbml0eTogdHJ1ZSxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZU51bWJlck9wdGlvbihcIm1heFJldHJ5VGltZVwiLCBvcHRpb25zLm1heFJldHJ5VGltZSwge1xuICAgICAgICBtaW46IDAsXG4gICAgICAgIGFsbG93SW5maW5pdHk6IHRydWUsXG4gICAgfSk7XG4gICAgLy8gVHJlYXQgbm9uLXBvc2l0aXZlIGZhY3RvciBhcyAxIHRvIGF2b2lkIHplcm8gYmFja29mZiBvciBuZWdhdGl2ZSBiZWhhdmlvclxuICAgIGlmICghKG9wdGlvbnMuZmFjdG9yID4gMCkpIHtcbiAgICAgICAgb3B0aW9ucy5mYWN0b3IgPSAxO1xuICAgIH1cbiAgICBvcHRpb25zLnNpZ25hbD8udGhyb3dJZkFib3J0ZWQoKTtcbiAgICBsZXQgYXR0ZW1wdE51bWJlciA9IDA7XG4gICAgbGV0IHJldHJpZXNDb25zdW1lZCA9IDA7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgd2hpbGUgKE51bWJlci5pc0Zpbml0ZShvcHRpb25zLnJldHJpZXMpID8gcmV0cmllc0NvbnN1bWVkIDw9IG9wdGlvbnMucmV0cmllcyA6IHRydWUpIHtcbiAgICAgICAgYXR0ZW1wdE51bWJlcisrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3B0aW9ucy5zaWduYWw/LnRocm93SWZBYm9ydGVkKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBpbnB1dChhdHRlbXB0TnVtYmVyKTtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsPy50aHJvd0lmQWJvcnRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChhd2FpdCBvbkF0dGVtcHRGYWlsdXJlKHtcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBhdHRlbXB0TnVtYmVyLFxuICAgICAgICAgICAgICAgIHJldHJpZXNDb25zdW1lZCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0cmllc0NvbnN1bWVkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlLCBidXQgaW4gY2FzZSBpdCBkb2VzLCB0aHJvdyBhbiBlcnJvclxuICAgIHRocm93IG5ldyBFcnJvcihcIlJldHJ5IGF0dGVtcHRzIGV4aGF1c3RlZCB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yLlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmV0cmlhYmxlKGZ1bmN0aW9uXywgb3B0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuICAgICAgICByZXR1cm4gcFJldHJ5KCgpID0+IGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmd1bWVudHNfKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbiJdLCJuYW1lcyI6WyJpc05ldHdvcmtFcnJvciIsInZhbGlkYXRlUmV0cmllcyIsInJldHJpZXMiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJpc05hTiIsInVuZGVmaW5lZCIsInZhbGlkYXRlTnVtYmVyT3B0aW9uIiwibmFtZSIsInZhbHVlIiwibWluIiwiYWxsb3dJbmZpbml0eSIsImlzRmluaXRlIiwiQWJvcnRFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwib3JpZ2luYWxFcnJvciIsInN0YWNrIiwiY2FsY3VsYXRlRGVsYXkiLCJyZXRyaWVzQ29uc3VtZWQiLCJvcHRpb25zIiwiYXR0ZW1wdCIsIk1hdGgiLCJtYXgiLCJyYW5kb20iLCJyYW5kb21pemUiLCJ0aW1lb3V0Iiwicm91bmQiLCJtaW5UaW1lb3V0IiwiZmFjdG9yIiwibWF4VGltZW91dCIsImNhbGN1bGF0ZVJlbWFpbmluZ1RpbWUiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93Iiwib25BdHRlbXB0RmFpbHVyZSIsImVycm9yIiwiYXR0ZW1wdE51bWJlciIsInN0YXJ0VGltZSIsIm5vcm1hbGl6ZWRFcnJvciIsInJldHJpZXNMZWZ0IiwibWF4UmV0cnlUaW1lIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJjb250ZXh0IiwiT2JqZWN0IiwiZnJlZXplIiwib25GYWlsZWRBdHRlbXB0IiwiY29uc3VtZVJldHJ5Iiwic2hvdWxkQ29uc3VtZVJldHJ5IiwicmVtYWluaW5nVGltZSIsInNpZ25hbCIsInRocm93SWZBYm9ydGVkIiwic2hvdWxkUmV0cnkiLCJkZWxheVRpbWUiLCJmaW5hbERlbGF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJvbkFib3J0IiwiY2xlYXJUaW1lb3V0IiwidGltZW91dFRva2VuIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYXNvbiIsInNldFRpbWVvdXQiLCJ1bnJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJvbmNlIiwicFJldHJ5IiwiaW5wdXQiLCJoYXNPd24iLCJyZXN1bHQiLCJtYWtlUmV0cmlhYmxlIiwiZnVuY3Rpb25fIiwiYXJndW1lbnRzXyIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/p-retry/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/project.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/project.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getDefaultProjectName: () => (/* binding */ getDefaultProjectName)\n/* harmony export */ });\n/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/langsmith/dist/utils/env.js\");\n\nconst getDefaultProjectName = ()=>{\n    return (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getLangSmithEnvironmentVariable)(\"PROJECT\") ?? (0,_env_js__WEBPACK_IMPORTED_MODULE_0__.getEnvironmentVariable)(\"LANGCHAIN_SESSION\") ?? // TODO: Deprecate\n    \"default\";\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvRjtBQUM3RSxNQUFNRSx3QkFBd0I7SUFDakMsT0FBUUQsd0VBQStCQSxDQUFDLGNBQ3BDRCwrREFBc0JBLENBQUMsd0JBQXdCLGtCQUFrQjtJQUNqRTtBQUNSLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvamVjdC5qcz81NzMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEVudmlyb25tZW50VmFyaWFibGUsIGdldExhbmdTbWl0aEVudmlyb25tZW50VmFyaWFibGUsIH0gZnJvbSBcIi4vZW52LmpzXCI7XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdFByb2plY3ROYW1lID0gKCkgPT4ge1xuICAgIHJldHVybiAoZ2V0TGFuZ1NtaXRoRW52aXJvbm1lbnRWYXJpYWJsZShcIlBST0pFQ1RcIikgPz9cbiAgICAgICAgZ2V0RW52aXJvbm1lbnRWYXJpYWJsZShcIkxBTkdDSEFJTl9TRVNTSU9OXCIpID8/IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgICAgICBcImRlZmF1bHRcIik7XG59O1xuIl0sIm5hbWVzIjpbImdldEVudmlyb25tZW50VmFyaWFibGUiLCJnZXRMYW5nU21pdGhFbnZpcm9ubWVudFZhcmlhYmxlIiwiZ2V0RGVmYXVsdFByb2plY3ROYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/project.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/prompts.js":
/*!******************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/prompts.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionGreaterOrEqual: () => (/* binding */ isVersionGreaterOrEqual),\n/* harmony export */   parsePromptIdentifier: () => (/* binding */ parsePromptIdentifier)\n/* harmony export */ });\n/* harmony import */ var semver__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! semver */ \"(rsc)/./node_modules/semver/index.js\");\n\nfunction isVersionGreaterOrEqual(current_version, target_version) {\n    const current = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(current_version);\n    const target = (0,semver__WEBPACK_IMPORTED_MODULE_0__.parse)(target_version);\n    if (!current || !target) {\n        throw new Error(\"Invalid version format.\");\n    }\n    return current.compare(target) >= 0;\n}\nfunction parsePromptIdentifier(identifier) {\n    if (!identifier || identifier.split(\"/\").length > 2 || identifier.startsWith(\"/\") || identifier.endsWith(\"/\") || identifier.split(\":\").length > 2) {\n        throw new Error(`Invalid identifier format: ${identifier}`);\n    }\n    const [ownerNamePart, commitPart] = identifier.split(\":\");\n    const commit = commitPart || \"latest\";\n    if (ownerNamePart.includes(\"/\")) {\n        const [owner, name] = ownerNamePart.split(\"/\", 2);\n        if (!owner || !name) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            owner,\n            name,\n            commit\n        ];\n    } else {\n        if (!ownerNamePart) {\n            throw new Error(`Invalid identifier format: ${identifier}`);\n        }\n        return [\n            \"-\",\n            ownerNamePart,\n            commit\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvcHJvbXB0cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFDeEMsU0FBU0Usd0JBQXdCQyxlQUFlLEVBQUVDLGNBQWM7SUFDbkUsTUFBTUMsVUFBVUosNkNBQVlBLENBQUNFO0lBQzdCLE1BQU1HLFNBQVNMLDZDQUFZQSxDQUFDRztJQUM1QixJQUFJLENBQUNDLFdBQVcsQ0FBQ0MsUUFBUTtRQUNyQixNQUFNLElBQUlDLE1BQU07SUFDcEI7SUFDQSxPQUFPRixRQUFRRyxPQUFPLENBQUNGLFdBQVc7QUFDdEM7QUFDTyxTQUFTRyxzQkFBc0JDLFVBQVU7SUFDNUMsSUFBSSxDQUFDQSxjQUNEQSxXQUFXQyxLQUFLLENBQUMsS0FBS0MsTUFBTSxHQUFHLEtBQy9CRixXQUFXRyxVQUFVLENBQUMsUUFDdEJILFdBQVdJLFFBQVEsQ0FBQyxRQUNwQkosV0FBV0MsS0FBSyxDQUFDLEtBQUtDLE1BQU0sR0FBRyxHQUFHO1FBQ2xDLE1BQU0sSUFBSUwsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7SUFDOUQ7SUFDQSxNQUFNLENBQUNLLGVBQWVDLFdBQVcsR0FBR04sV0FBV0MsS0FBSyxDQUFDO0lBQ3JELE1BQU1NLFNBQVNELGNBQWM7SUFDN0IsSUFBSUQsY0FBY0csUUFBUSxDQUFDLE1BQU07UUFDN0IsTUFBTSxDQUFDQyxPQUFPQyxLQUFLLEdBQUdMLGNBQWNKLEtBQUssQ0FBQyxLQUFLO1FBQy9DLElBQUksQ0FBQ1EsU0FBUyxDQUFDQyxNQUFNO1lBQ2pCLE1BQU0sSUFBSWIsTUFBTSxDQUFDLDJCQUEyQixFQUFFRyxXQUFXLENBQUM7UUFDOUQ7UUFDQSxPQUFPO1lBQUNTO1lBQU9DO1lBQU1IO1NBQU87SUFDaEMsT0FDSztRQUNELElBQUksQ0FBQ0YsZUFBZTtZQUNoQixNQUFNLElBQUlSLE1BQU0sQ0FBQywyQkFBMkIsRUFBRUcsV0FBVyxDQUFDO1FBQzlEO1FBQ0EsT0FBTztZQUFDO1lBQUtLO1lBQWVFO1NBQU87SUFDdkM7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dGlscy9wcm9tcHRzLmpzPzc5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgYXMgcGFyc2VWZXJzaW9uIH0gZnJvbSBcInNlbXZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsKGN1cnJlbnRfdmVyc2lvbiwgdGFyZ2V0X3ZlcnNpb24pIHtcbiAgICBjb25zdCBjdXJyZW50ID0gcGFyc2VWZXJzaW9uKGN1cnJlbnRfdmVyc2lvbik7XG4gICAgY29uc3QgdGFyZ2V0ID0gcGFyc2VWZXJzaW9uKHRhcmdldF92ZXJzaW9uKTtcbiAgICBpZiAoIWN1cnJlbnQgfHwgIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZlcnNpb24gZm9ybWF0LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQuY29tcGFyZSh0YXJnZXQpID49IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQcm9tcHRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoIWlkZW50aWZpZXIgfHxcbiAgICAgICAgaWRlbnRpZmllci5zcGxpdChcIi9cIikubGVuZ3RoID4gMiB8fFxuICAgICAgICBpZGVudGlmaWVyLnN0YXJ0c1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuZW5kc1dpdGgoXCIvXCIpIHx8XG4gICAgICAgIGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGlkZW50aWZpZXIgZm9ybWF0OiAke2lkZW50aWZpZXJ9YCk7XG4gICAgfVxuICAgIGNvbnN0IFtvd25lck5hbWVQYXJ0LCBjb21taXRQYXJ0XSA9IGlkZW50aWZpZXIuc3BsaXQoXCI6XCIpO1xuICAgIGNvbnN0IGNvbW1pdCA9IGNvbW1pdFBhcnQgfHwgXCJsYXRlc3RcIjtcbiAgICBpZiAob3duZXJOYW1lUGFydC5pbmNsdWRlcyhcIi9cIikpIHtcbiAgICAgICAgY29uc3QgW293bmVyLCBuYW1lXSA9IG93bmVyTmFtZVBhcnQuc3BsaXQoXCIvXCIsIDIpO1xuICAgICAgICBpZiAoIW93bmVyIHx8ICFuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW293bmVyLCBuYW1lLCBjb21taXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvd25lck5hbWVQYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWRlbnRpZmllciBmb3JtYXQ6ICR7aWRlbnRpZmllcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1wiLVwiLCBvd25lck5hbWVQYXJ0LCBjb21taXRdO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6WyJwYXJzZSIsInBhcnNlVmVyc2lvbiIsImlzVmVyc2lvbkdyZWF0ZXJPckVxdWFsIiwiY3VycmVudF92ZXJzaW9uIiwidGFyZ2V0X3ZlcnNpb24iLCJjdXJyZW50IiwidGFyZ2V0IiwiRXJyb3IiLCJjb21wYXJlIiwicGFyc2VQcm9tcHRJZGVudGlmaWVyIiwiaWRlbnRpZmllciIsInNwbGl0IiwibGVuZ3RoIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwib3duZXJOYW1lUGFydCIsImNvbW1pdFBhcnQiLCJjb21taXQiLCJpbmNsdWRlcyIsIm93bmVyIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/prompts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/utils/warn.js":
/*!***************************************************!*\
  !*** ./node_modules/langsmith/dist/utils/warn.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   warnOnce: () => (/* binding */ warnOnce)\n/* harmony export */ });\nconst warnedMessages = {};\nfunction warnOnce(message) {\n    if (!warnedMessages[message]) {\n        console.warn(message);\n        warnedMessages[message] = true;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsTUFBTUEsaUJBQWlCLENBQUM7QUFDakIsU0FBU0MsU0FBU0MsT0FBTztJQUM1QixJQUFJLENBQUNGLGNBQWMsQ0FBQ0UsUUFBUSxFQUFFO1FBQzFCQyxRQUFRQyxJQUFJLENBQUNGO1FBQ2JGLGNBQWMsQ0FBQ0UsUUFBUSxHQUFHO0lBQzlCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXRpbHMvd2Fybi5qcz8wMmQwIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdhcm5lZE1lc3NhZ2VzID0ge307XG5leHBvcnQgZnVuY3Rpb24gd2Fybk9uY2UobWVzc2FnZSkge1xuICAgIGlmICghd2FybmVkTWVzc2FnZXNbbWVzc2FnZV0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB3YXJuZWRNZXNzYWdlc1ttZXNzYWdlXSA9IHRydWU7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbIndhcm5lZE1lc3NhZ2VzIiwid2Fybk9uY2UiLCJtZXNzYWdlIiwiY29uc29sZSIsIndhcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/utils/warn.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/dist/uuid.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/dist/uuid.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   uuid7: () => (/* binding */ uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v7.js\");\n/* harmony import */ var _utils_uuid_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/_uuid.js */ \"(rsc)/./node_modules/langsmith/dist/utils/_uuid.js\");\n\n\n/**\n * Generate a random UUID v7 string.\n */ function uuid7() {\n    return (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2Rpc3QvdXVpZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9DO0FBQ2E7QUFDakQ7O0NBRUMsR0FDTSxTQUFTRztJQUNaLE9BQU9GLGdEQUFNQTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvZGlzdC91dWlkLmpzPzU2NmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdjcgYXMgdXVpZHY3IH0gZnJvbSBcInV1aWRcIjtcbmV4cG9ydCB7IHV1aWQ3RnJvbVRpbWUgfSBmcm9tIFwiLi91dGlscy9fdXVpZC5qc1wiO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSBVVUlEIHY3IHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQ3KCkge1xuICAgIHJldHVybiB1dWlkdjcoKTtcbn1cbiJdLCJuYW1lcyI6WyJ2NyIsInV1aWR2NyIsInV1aWQ3RnJvbVRpbWUiLCJ1dWlkNyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/dist/uuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/index.js":
/*!*****************************************!*\
  !*** ./node_modules/langsmith/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Client),\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   __version__: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.__version__),\n/* harmony export */   getDefaultProjectName: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.getDefaultProjectName),\n/* harmony export */   overrideFetchImplementation: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.overrideFetchImplementation),\n/* harmony export */   uuid7: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7),\n/* harmony export */   uuid7FromTime: () => (/* reexport safe */ _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.uuid7FromTime)\n/* harmony export */ });\n/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ \"(rsc)/./node_modules/langsmith/dist/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLy4vbm9kZV9tb2R1bGVzL2xhbmdzbWl0aC9pbmRleC5qcz8xODFiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vZGlzdC9pbmRleC5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/run_trees.js":
/*!*********************************************!*\
  !*** ./node_modules/langsmith/run_trees.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.RunTree),\n/* harmony export */   convertToDottedOrderFormat: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.convertToDottedOrderFormat),\n/* harmony export */   isRunTree: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunTree),\n/* harmony export */   isRunnableConfigLike: () => (/* reexport safe */ _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__.isRunnableConfigLike)\n/* harmony export */ });\n/* harmony import */ var _dist_run_trees_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/run_trees.js */ \"(rsc)/./node_modules/langsmith/dist/run_trees.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3J1bl90cmVlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvcnVuX3RyZWVzLmpzPzA1MmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9kaXN0L3J1bl90cmVlcy5qcyciXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/run_trees.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/langsmith/singletons/traceable.js":
/*!********************************************************!*\
  !*** ./node_modules/langsmith/singletons/traceable.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AsyncLocalStorageProviderSingleton: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.AsyncLocalStorageProviderSingleton),\n/* harmony export */   ROOT: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.ROOT),\n/* harmony export */   getCurrentRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentRunTree),\n/* harmony export */   isTraceableFunction: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.isTraceableFunction),\n/* harmony export */   withRunTree: () => (/* reexport safe */ _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__.withRunTree)\n/* harmony export */ });\n/* harmony import */ var _dist_singletons_traceable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/singletons/traceable.js */ \"(rsc)/./node_modules/langsmith/dist/singletons/traceable.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbGFuZ3NtaXRoL3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy8uL25vZGVfbW9kdWxlcy9sYW5nc21pdGgvc2luZ2xldG9ucy90cmFjZWFibGUuanM/MjZmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgKiBmcm9tICcuLi9kaXN0L3NpbmdsZXRvbnMvdHJhY2VhYmxlLmpzJyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/langsmith/singletons/traceable.js\n");

/***/ })

};
;